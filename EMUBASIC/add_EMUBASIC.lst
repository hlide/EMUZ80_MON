 AS V1.42 Beta [Bld 227] - Source File add_EMUBASIC.ASM - Page 1 - 10/3/2022 13:24:0


       1/       0 :                     	page	0
       2/       0 :                     	cpu	z80
       3/       0 :                     ;	EMUBASIC based on GRANT's BASIC
       4/       0 :                     ;	TARGET: EMUZ80
       5/       0 :                     ;	ASSEMBLER: ARCPIT XZ80.EXE
       6/       0 :                     ;
       7/       0 :                     ;	START UP ROUTINE
       8/       0 :                     ;	VERSION 1.0, 2022/02/15
       9/       0 :                     ;	WRITTEN by TETSUYA SUZUKI
      10/       0 :                     ;	Modified Akihito Honda
      11/       0 :                     ;
      12/       0 :                     
      13/       0 : =1H                  RAM12K = 1
      14/       0 :                     
      15/       0 :                     ;	MEMORY ASIGN
      16/       0 : =2000H               ROMTOP	EQU	2000H		; 0000H - 1FFFH for unimon
      17/       0 :                     
      18/       0 : =>TRUE               	IF RAM12K
      19/       0 : =0C000H              RAMTOP	EQU	0C000H
      20/       0 : =>FALSE              	ELSE
      21/       0 :                     RAMTOP	EQU	08000H
      22/       0 : [18]                 	ENDIF
      23/       0 :                     ;
      24/       0 :                     ;	UART REGISTER ADDRESS
      25/       0 : =0FF00H              UARTDR	EQU	0FF00H	; UART DATA REGISTOR
      26/       0 : =0FF01H              UARTCR	EQU	0FF01H	; UART CONTROL REGISTOR
      27/       0 :                     
      28/       0 :                     ; Universal Monitor CSTART
      29/       0 : =0H                  UNI_CST	EQU	0000H
      30/       0 :                     
      31/       0 :                     ;
      32/       0 :                     ;	RESET (RST 00H)
      33/    2000 :                     	ORG	ROMTOP
      34/    2000 : C3 06 20            	JP	STARTB		; Jump for cold start
      35/    2003 : C3 7B 20            	JP	WARMST		; Jump for warm start
      36/    2006 :                     
      37/    2006 : =>FALSE              	if	0
      38/    2006 :                     ;
      39/    2006 :                     ;	PUT 1CHAR (RST 08H)
      40/    2006 :                     ;	ORG	ROMTOP+08H
      41/    2006 :                     	ds	ROMTOP+08H - $, 0x00
      42/    2006 :                     	JP	TXA
      43/    2006 :                     ;
      44/    2006 :                     ;	GET 1CHAR (RST 10H)
      45/    2006 :                     ;	ORG	ROMTOP+10H
      46/    2006 :                     	ds	ROMTOP+10H - $, 0x00
      47/    2006 :                     	JP	RXA
      48/    2006 :                     ;
      49/    2006 :                     ;	KBHIT (RST 18H)
      50/    2006 :                     ;	ORG	ROMTOP+18H
      51/    2006 :                     	ds	ROMTOP+18H - $, 0x00
      52/    2006 :                     	JP	KBHIT
      53/    2006 :                     ;
      54/    2006 :                     ;	UART -> A
      55/    2006 :                     RXA:	LD	A,(UARTCR)
      56/    2006 :                     	BIT	0,A
      57/    2006 :                     	JR	Z,RXA
      58/    2006 :                     	LD	A,(UARTDR)
      59/    2006 :                     	CP	'a'
      60/    2006 :                     	RET	C
      61/    2006 :                     	CP	'z'+1
      62/    2006 :                     	RET	NC
      63/    2006 :                     	AND	0DFH
      64/    2006 :                     	RET
      65/    2006 :                     ;
      66/    2006 :                     ;	CHECK RECEIVE STATUS
      67/    2006 :                     KBHIT:	LD	A,(UARTCR)
      68/    2006 :                     	BIT	0,A
      69/    2006 :                     	RET
      70/    2006 :                     ;
      71/    2006 :                     ;	A -> UART
      72/    2006 :                     TXA:	PUSH	AF
      73/    2006 :                     TXAST1:	LD	A,(UARTCR)
      74/    2006 :                     	BIT	1,A
      75/    2006 :                     	JR	Z,TXAST1
      76/    2006 :                     	POP	AF
      77/    2006 :                     	LD	(UARTDR),A
      78/    2006 :                     	RET
      79/    2006 : [37]                 	endif
      80/    2006 :                     ;
      81/    2006 :                     ;==================================================================================
      82/    2006 :                     ; The updates to the original BASIC within this file are copyright Grant Searle
      83/    2006 :                     ;
      84/    2006 :                     ; You have permission to use this for NON COMMERCIAL USE ONLY
      85/    2006 :                     ; If you wish to use it elsewhere, please include an acknowledgement to myself.
      86/    2006 :                     ;
      87/    2006 :                     ; http://searle.hostei.com/grant/index.html
      88/    2006 :                     ;
      89/    2006 :                     ; eMail: home.micros01@btinternet.com
      90/    2006 :                     ;
      91/    2006 :                     ; If the above don't work, please perform an Internet search to see if I have
      92/    2006 :                     ; updated the web page hosting service.
      93/    2006 :                     ;
      94/    2006 :                     ;==================================================================================
      95/    2006 :                     ;
      96/    2006 :                     ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
      97/    2006 :                     ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
      98/    2006 :                     ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
      99/    2006 :                     ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
     100/    2006 :                     ; the original ROM code (checksum A934H). PA
     101/    2006 :                     ;
     102/    2006 :                     ; GENERAL EQUATES
     103/    2006 :                     ;
     104/    2006 : =3H                  CTRLC	EQU	03H		; Control "C"
     105/    2006 : =7H                  CTRLG	EQU	07H		; Control "G"
     106/    2006 : =8H                  BKSP	EQU	08H		; Back space
     107/    2006 : =0AH                 LF	EQU	0AH		; Line feed
     108/    2006 : =0CH                 CS	EQU	0CH		; Clear screen
     109/    2006 : =0DH                 CR	EQU	0DH		; Carriage return
     110/    2006 : =0FH                 CTRLO	EQU	0FH		; Control "O"
     111/    2006 : =11H                 CTRLQ	EQU	11H		; Control "Q"
     112/    2006 : =12H                 CTRLR	EQU	12H		; Control "R"
     113/    2006 : =13H                 CTRLS	EQU	13H		; Control "S"
     114/    2006 : =15H                 CTRLU	EQU	15H		; Control "U"
     115/    2006 : =1BH                 ESC	EQU	1BH		; Escape
     116/    2006 : =7FH                 DEL	EQU	7FH		; Delete
     117/    2006 :                     ;
     118/    2006 :                     ; BASIC WORK SPACE LOCATIONS
     119/    2006 :                     ;
     120/    2006 : =0C045H              WRKSPC	EQU	RAMTOP + 45H	; BASIC Work space
     121/    2006 : =0C048H              USR	EQU	WRKSPC+3H	; "USR (x)" jump
     122/    2006 : =0C04BH              OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
     123/    2006 : =0C04CH              OTPORT	EQU	WRKSPC+7H	; Port (p)
     124/    2006 : =0C04EH              DIVSUP	EQU	WRKSPC+9H	; Division support routine
     125/    2006 : =0C04FH              DIV1	EQU	WRKSPC+0AH	; <- Values
     126/    2006 : =0C053H              DIV2	EQU	WRKSPC+0EH	; <- to
     127/    2006 : =0C057H              DIV3	EQU	WRKSPC+12H	; <- be
     128/    2006 : =0C05AH              DIV4	EQU	WRKSPC+15H	; <- inserted
     129/    2006 : =0C05CH              SEED	EQU	WRKSPC+17H	; Random number seed
     130/    2006 : =0C07FH              LSTRND	EQU	WRKSPC+3AH	; Last random number
     131/    2006 : =0C083H              INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
     132/    2006 : =0C084H              INPORT	EQU	WRKSPC+3FH	; PORT (x)
     133/    2006 : =0C086H              NULLS	EQU	WRKSPC+41H	; Number of nulls
     134/    2006 : =0C087H              LWIDTH	EQU	WRKSPC+42H	; Terminal width
     135/    2006 : =0C088H              COMMAN	EQU	WRKSPC+43H	; Width for commas
     136/    2006 : =0C089H              NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
     137/    2006 : =0C08AH              CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
     138/    2006 : =0C08BH              LINESC	EQU	WRKSPC+46H	; Lines counter
     139/    2006 : =0C08DH              LINESN	EQU	WRKSPC+48H	; Lines number
     140/    2006 : =0C08FH              CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
     141/    2006 : =0C091H              NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
     142/    2006 : =0C092H              BRKFLG	EQU	WRKSPC+4DH	; Break flag
     143/    2006 : =0C093H              RINPUT	EQU	WRKSPC+4EH	; Input reflection
     144/    2006 : =0C096H              POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
     145/    2006 : =0C099H              PSET	EQU	WRKSPC+54H	; "SET"	reflection
     146/    2006 : =0C09CH              RESET	EQU	WRKSPC+57H	; "RESET" reflection
     147/    2006 : =0C09FH              STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
     148/    2006 : =0C0A1H              LINEAT	EQU	WRKSPC+5CH	; Current line number
     149/    2006 : =0C0A3H              BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
     150/    2006 : =0C0A6H              BUFFER	EQU	WRKSPC+61H	; Input buffer
     151/    2006 : =0C0ABH              STACK	EQU	WRKSPC+66H	; Initial stack
     152/    2006 : =0C0F0H              CURPOS	EQU	WRKSPC+0ABH	; Character position on line
     153/    2006 : =0C0F1H              LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
     154/    2006 : =0C0F2H              TYPE	EQU	WRKSPC+0ADH	; Data type flag
     155/    2006 : =0C0F3H              DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
     156/    2006 : =0C0F4H              LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
     157/    2006 : =0C0F6H              TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
     158/    2006 : =0C0F8H              TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
     159/    2006 : =0C104H              TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
     160/    2006 : =0C108H              STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
     161/    2006 : =0C10AH              CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
     162/    2006 : =0C10CH              LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
     163/    2006 : =0C10EH              DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
     164/    2006 : =0C110H              FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
     165/    2006 : =0C111H              LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
     166/    2006 : =0C112H              READFG	EQU	WRKSPC+0CDH	; Read/Input flag
     167/    2006 : =0C113H              BRKLIN	EQU	WRKSPC+0CEH	; Line of break
     168/    2006 : =0C115H              NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
     169/    2006 : =0C117H              ERRLIN	EQU	WRKSPC+0D2H	; Line of error
     170/    2006 : =0C119H              CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
     171/    2006 : =0C11BH              PROGND	EQU	WRKSPC+0D6H	; End of program
     172/    2006 : =0C11DH              VAREND	EQU	WRKSPC+0D8H	; End of variables
     173/    2006 : =0C11FH              ARREND	EQU	WRKSPC+0DAH	; End of arrays
     174/    2006 : =0C121H              NXTDAT	EQU	WRKSPC+0DCH	; Next data item
     175/    2006 : =0C123H              FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
     176/    2006 : =0C125H              FNARG	EQU	WRKSPC+0E0H	; FN argument value
     177/    2006 : =0C129H              FPREG	EQU	WRKSPC+0E4H	; Floating point register
     178/    2006 : =0C12CH              FPEXP	EQU	FPREG+3		; Floating point exponent
     179/    2006 : =0C12DH              SGNRES	EQU	WRKSPC+0E8H	; Sign of result
     180/    2006 : =0C12EH              PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
     181/    2006 : =0C13BH              MULVAL	EQU	WRKSPC+0F6H	; Multiplier
     182/    2006 : =0C13EH              PROGST	EQU	WRKSPC+0F9H	; Start of program text area
     183/    2006 : =0C1A2H              STLOOK	EQU	WRKSPC+15DH	; Start of memory test
     184/    2006 :                     ;
     185/    2006 :                     ; BASIC ERROR CODE VALUES
     186/    2006 :                     ;
     187/    2006 : =0H                  NF	EQU	00H		; NEXT without FOR
     188/    2006 : =2H                  SN	EQU	02H		; Syntax error
     189/    2006 : =4H                  RG	EQU	04H		; RETURN without GOSUB
     190/    2006 : =6H                  OD	EQU	06H		; Out of DATA
     191/    2006 : =8H                  FC	EQU	08H		; Function call error
     192/    2006 : =0AH                 OV	EQU	0AH		; Overflow
     193/    2006 : =0CH                 OM	EQU	0CH		; Out of memory
     194/    2006 : =0EH                 UL	EQU	0EH		; Undefined line number
     195/    2006 : =10H                 BS	EQU	10H		; Bad subscript
     196/    2006 : =12H                 RD	EQU	12H		; Re-DIMensioned array
     197/    2006 : =14H                 DZ	EQU	14H		; Division by zero (/0)
     198/    2006 : =16H                 ID	EQU	16H		; Illegal direct
     199/    2006 : =18H                 TM	EQU	18H		; Type miss-match
     200/    2006 : =1AH                 OS	EQU	1AH		; Out of string space
     201/    2006 : =1CH                 LS	EQU	1CH		; String too long
     202/    2006 : =1EH                 ST	EQU	1EH		; String formula too complex
     203/    2006 : =20H                 CN	EQU	20H		; Can't CONTinue
     204/    2006 : =22H                 UF	EQU	22H		; UnDEFined FN function
     205/    2006 : =24H                 MO	EQU	24H		; Missing operand
     206/    2006 : =26H                 HX	EQU	26H		; HEX error
     207/    2006 : =28H                 BN	EQU	28H		; BIN error
     208/    2006 :                     ;
     209/    2006 : C3 0D 20            STARTB: JP	CSTART		; Jump to initialise
     210/    2009 :                     ;
     211/    2009 : BC 28               	DW	DEINT		; Get integer -32768 to 32767
     212/    200B : 32 30               	DW	ABPASS		; Return integer in AB
     213/    200D :                     ;
     214/    200D : 21 45 C0            CSTART: LD	HL,WRKSPC	; Start of workspace RAM
     215/    2010 : F9                  	LD	SP,HL		; Set up a temporary stack
     216/    2011 : C3 46 3C            	JP	INITST		; Go to initialise
     217/    2014 :                     ;
     218/    2014 : 11 E5 22            INIT:	LD	DE,INITAB	; Initialise workspace
     219/    2017 : 06 63               	LD	B,INITBE-INITAB+3; Bytes to copy
     220/    2019 : 21 45 C0            	LD	HL,WRKSPC	; Into workspace RAM
     221/    201C : 1A                  COPY:	LD	A,(DE)		; Get source
     222/    201D : 77                  	LD	(HL),A		; To destination
     223/    201E : 23                  	INC	HL		; Next destination
     224/    201F : 13                  	INC	DE		; Next source
     225/    2020 : 05                  	DEC	B		; Count bytes
     226/    2021 : C2 1C 20            	JP	NZ,COPY		; More to move
     227/    2024 : F9                  	LD	SP,HL		; Temporary stack
     228/    2025 : CD E6 24            	CALL	CLREG		; Clear registers and stack
     229/    2028 : CD B2 2A            	CALL	PRCRLF		; Output CRLF
     230/    202B : 32 EF C0            	LD	(BUFFER+72+1),A	; Mark end of buffer
     231/    202E : 32 3E C1            	LD	(PROGST),A	; Initialise program area
     232/    2031 : 21 A2 C1            MSIZE:	LD	HL,STLOOK	; Point to start of RAM
     233/    2034 : 23                  MLOOP:	INC	HL		; Next byte
     234/    2035 : 7C                  	LD	A,H		; Above address FFFF ?
     235/    2036 : B5                  	OR	L
     236/    2037 : CA 43 20            	JP	Z,SETTOP	; Yes - 64K RAM
     237/    203A : 7E                  	LD	A,(HL)		; Get contents
     238/    203B : 47                  	LD	B,A		; Save it
     239/    203C : 2F                  	CPL			; Flip all bits
     240/    203D : 77                  	LD	(HL),A		; Put it back
     241/    203E : BE                  	CP	(HL)		; RAM there if same
     242/    203F : 70                  	LD	(HL),B		; Restore old contents
     243/    2040 : CA 34 20            	JP	Z,MLOOP		; If RAM - test next byte
     244/    2043 :                     ;
     245/    2043 : 2B                  SETTOP: DEC	HL		; Back one byte
     246/    2044 : 11 A1 C1            	LD	DE,STLOOK-1	; See if enough RAM
     247/    2047 : CD 7C 26            	CALL	CPDEHL		; Compare DE with HL
     248/    204A : DA 84 20            	JP	C,NEMEM		; If not enough RAM
     249/    204D : 11 CE FF            	LD	DE,0-50		; 50 Bytes string space
     250/    2050 : 22 F4 C0            	LD	(LSTRAM),HL	; Save last available RAM
     251/    2053 : 19                  	ADD	HL,DE		; Allocate string space
     252/    2054 : 22 9F C0            	LD	(STRSPC),HL	; Save string space
     253/    2057 : CD C1 24            	CALL	CLRPTR		; Clear program area
     254/    205A : 2A 9F C0            	LD	HL,(STRSPC)	; Get end of memory
     255/    205D : 11 EF FF            	LD	DE,0-17		; Offset for free bytes
     256/    2060 : 19                  	ADD	HL,DE		; Adjust HL
     257/    2061 : 11 3E C1            	LD	DE,PROGST	; Start of program text
     258/    2064 : 7D                  	LD	A,L		; Get LSB
     259/    2065 : 93                  	SUB	E		; Adjust it
     260/    2066 : 6F                  	LD	L,A		; Re-save
     261/    2067 : 7C                  	LD	A,H		; Get MSB
     262/    2068 : 9A                  	SBC	A,D		; Adjust it
     263/    2069 : 67                  	LD	H,A		; Re-save
     264/    206A : E5                  	PUSH	HL		; Save bytes free
     265/    206B : 21 9C 20            	LD	HL,SIGNON	; Sign-on message
     266/    206E : CD 50 31            	CALL	PRS		; Output string
     267/    2071 : E1                  	POP	HL		; Get bytes free back
     268/    2072 : CD F3 37            	CALL	PRNTHL		; Output amount of free memory
     269/    2075 : 21 8D 20            	LD	HL,BFREE	; " Bytes free" message
     270/    2078 : CD 50 31            	CALL	PRS		; Output string
     271/    207B :                     ;
     272/    207B : 31 AB C0            WARMST: LD	SP,STACK	; Temporary stack
     273/    207E : CD E6 24            BRKRET: CALL	CLREG		; Clear registers and stack
     274/    2081 : C3 FF 23            	JP	PRNTOK		; Go to get command line
     275/    2084 :                     ;
     276/    2084 : 21 D3 20            NEMEM:	LD	HL,MEMMSG	; Memory size not enough
     277/    2087 : CD 50 31            	CALL	PRS		; Print it
     278/    208A : C3 8A 20            XXXXX:	JP	XXXXX		; Stop
     279/    208D :                     ;
     280/    208D : 20 42 79 74 65 73   BFREE:	DB	" Bytes free",CR,LF,0,0
             2093 : 20 66 72 65 65 0D 
             2099 : 0A 00 00          
     281/    209C :                     ;
     282/    209C : 5A 38 30 20 42 41   SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
             20A2 : 53 49 43 20 56 65 
             20A8 : 72 20 34 2E 37 62 
             20AE : 0D 0A             
     283/    20B0 : 43 6F 70 79 72 69   	DB	"Copyright ",40,"C",41
             20B6 : 67 68 74 20 28 43 
             20BC : 29                
     284/    20BD : 20 31 39 37 38 20   	DB	" 1978 by Microsoft",CR,LF,0,0
             20C3 : 62 79 20 4D 69 63 
             20C9 : 72 6F 73 6F 66 74 
             20CF : 0D 0A 00 00       
     285/    20D3 :                     ;
     286/    20D3 : 4D 65 6D 6F 72 79   MEMMSG: DB	"Memory size not enough",CR,LF
             20D9 : 20 73 69 7A 65 20 
             20DF : 6E 6F 74 20 65 6E 
             20E5 : 6F 75 67 68 0D 0A 
     287/    20EB : 54 68 65 20 73 79   	DB	"The system is stopped.",CR,LF,0,0
             20F1 : 73 74 65 6D 20 69 
             20F7 : 73 20 73 74 6F 70 
             20FD : 70 65 64 2E 0D 0A 
             2103 : 00 00             
     288/    2105 :                     ;
     289/    2105 :                     ; FUNCTION ADDRESS TABLE
     290/    2105 :                     ;
     291/    2105 : 68 36               FNCTAB: DW	SGN
     292/    2107 : 2C 37               	DW	INT
     293/    2109 : 7E 36               	DW	ABS
     294/    210B : 48 C0               	DW	USR
     295/    210D : 10 30               	DW	FRE
     296/    210F : 95 33               	DW	INP
     297/    2111 : 3E 30               	DW	POS
     298/    2113 : F2 38               	DW	SQR
     299/    2115 : D1 39               	DW	RND
     300/    2117 : 0D 35               	DW	LOG
     301/    2119 : 40 39               	DW	EXP
     302/    211B : 46 3A               	DW	COS
     303/    211D : 4C 3A               	DW	SIN
     304/    211F : AD 3A               	DW	TAN
     305/    2121 : C2 3A               	DW	ATN
     306/    2123 : E9 33               	DW	PEEK
     307/    2125 : 2C 3B               	DW	DEEK
     308/    2127 : 96 C0               	DW	POINT
     309/    2129 : C2 32               	DW	LEN
     310/    212B : DA 30               	DW	STR
     311/    212D : 5C 33               	DW	VAL
     312/    212F : D1 32               	DW	ASC
     313/    2131 : E2 32               	DW	CHR
     314/    2133 : 4E 3B               	DW	HEX
     315/    2135 : E1 3B               	DW	BIN
     316/    2137 : F2 32               	DW	LEFT
     317/    2139 : 22 33               	DW	RIGHT
     318/    213B : 2C 33               	DW	MID
     319/    213D :                     ;
     320/    213D :                     ; RESERVED WORD LIST
     321/    213D :                     ;
     322/    213D : C5 4E 44            WORDS:	DB	0C5H,"ND"
     323/    2140 : C6 4F 52            	DB	0C6H,"OR"
     324/    2143 : CE 45 58 54         	DB	0CEH,"EXT"
     325/    2147 : C4 41 54 41         	DB	0C4H,"ATA"
     326/    214B : C9 4E 50 55 54      	DB	0C9H,"NPUT"
     327/    2150 : C4 49 4D            	DB	0C4H,"IM"
     328/    2153 : D2 45 41 44         	DB	0D2H,"EAD"
     329/    2157 : CC 45 54            	DB	0CCH,"ET"
     330/    215A : C7 4F 54 4F         	DB	0C7H,"OTO"
     331/    215E : D2 55 4E            	DB	0D2H,"UN"
     332/    2161 : C9 46               	DB	0C9H,"F"
     333/    2163 : D2 45 53 54 4F 52   	DB	0D2H,"ESTORE"
             2169 : 45                
     334/    216A : C7 4F 53 55 42      	DB	0C7H,"OSUB"
     335/    216F : D2 45 54 55 52 4E   	DB	0D2H,"ETURN"
     336/    2175 : D2 45 4D            	DB	0D2H,"EM"
     337/    2178 : D3 54 4F 50         	DB	0D3H,"TOP"
     338/    217C : CF 55 54            	DB	0CFH,"UT"
     339/    217F : CF 4E               	DB	0CFH,"N"
     340/    2181 : CE 55 4C 4C         	DB	0CEH,"ULL"
     341/    2185 : D7 41 49 54         	DB	0D7H,"AIT"
     342/    2189 : C4 45 46            	DB	0C4H,"EF"
     343/    218C : D0 4F 4B 45         	DB	0D0H,"OKE"
     344/    2190 : C4 4F 4B 45         	DB	0C4H,"OKE"
     345/    2194 : D3 43 52 45 45 4E   	DB	0D3H,"CREEN"
     346/    219A : CC 49 4E 45 53      	DB	0CCH,"INES"
     347/    219F : C3 4C 53            	DB	0C3H,"LS"
     348/    21A2 : D7 49 44 54 48      	DB	0D7H,"IDTH"
     349/    21A7 : CD 4F 4E 49 54 4F   	DB	0CDH,"ONITOR"
             21AD : 52                
     350/    21AE : D3 45 54            	DB	0D3H,"ET"
     351/    21B1 : D2 45 53 45 54      	DB	0D2H,"ESET"
     352/    21B6 : D0 52 49 4E 54      	DB	0D0H,"RINT"
     353/    21BB : C3 4F 4E 54         	DB	0C3H,"ONT"
     354/    21BF : CC 49 53 54         	DB	0CCH,"IST"
     355/    21C3 : C3 4C 45 41 52      	DB	0C3H,"LEAR"
     356/    21C8 : C3 4C 4F 41 44      	DB	0C3H,"LOAD"
     357/    21CD : C3 53 41 56 45      	DB	0C3H,"SAVE"
     358/    21D2 : CE 45 57            	DB	0CEH,"EW"
     359/    21D5 :                     ;
     360/    21D5 : D4 41 42 28         	DB	0D4H,"AB("
     361/    21D9 : D4 4F               	DB	0D4H,"O"
     362/    21DB : C6 4E               	DB	0C6H,"N"
     363/    21DD : D3 50 43 28         	DB	0D3H,"PC("
     364/    21E1 : D4 48 45 4E         	DB	0D4H,"HEN"
     365/    21E5 : CE 4F 54            	DB	0CEH,"OT"
     366/    21E8 : D3 54 45 50         	DB	0D3H,"TEP"
     367/    21EC :                     ;
     368/    21EC : AB                  	DB	0ABH
     369/    21ED : AD                  	DB	0ADH
     370/    21EE : AA                  	DB	0AAH
     371/    21EF : AF                  	DB	0AFH
     372/    21F0 : DE                  	DB	0DEH
     373/    21F1 : C1 4E 44            	DB	0C1H,"ND"
     374/    21F4 : CF 52               	DB	0CFH,"R"
     375/    21F6 : BE                  	DB	0BEH
     376/    21F7 : BD                  	DB	0BDH
     377/    21F8 : BC                  	DB	0BCH
     378/    21F9 :                     ;
     379/    21F9 : D3 47 4E            	DB	0D3H,"GN"
     380/    21FC : C9 4E 54            	DB	0C9H,"NT"
     381/    21FF : C1 42 53            	DB	0C1H,"BS"
     382/    2202 : D5 53 52            	DB	0D5H,"SR"
     383/    2205 : C6 52 45            	DB	0C6H,"RE"
     384/    2208 : C9 4E 50            	DB	0C9H,"NP"
     385/    220B : D0 4F 53            	DB	0D0H,"OS"
     386/    220E : D3 51 52            	DB	0D3H,"QR"
     387/    2211 : D2 4E 44            	DB	0D2H,"ND"
     388/    2214 : CC 4F 47            	DB	0CCH,"OG"
     389/    2217 : C5 58 50            	DB	0C5H,"XP"
     390/    221A : C3 4F 53            	DB	0C3H,"OS"
     391/    221D : D3 49 4E            	DB	0D3H,"IN"
     392/    2220 : D4 41 4E            	DB	0D4H,"AN"
     393/    2223 : C1 54 4E            	DB	0C1H,"TN"
     394/    2226 : D0 45 45 4B         	DB	0D0H,"EEK"
     395/    222A : C4 45 45 4B         	DB	0C4H,"EEK"
     396/    222E : D0 4F 49 4E 54      	DB	0D0H,"OINT"
     397/    2233 : CC 45 4E            	DB	0CCH,"EN"
     398/    2236 : D3 54 52 24         	DB	0D3H,"TR$"
     399/    223A : D6 41 4C            	DB	0D6H,"AL"
     400/    223D : C1 53 43            	DB	0C1H,"SC"
     401/    2240 : C3 48 52 24         	DB	0C3H,"HR$"
     402/    2244 : C8 45 58 24         	DB	0C8H,"EX$"
     403/    2248 : C2 49 4E 24         	DB	0C2H,"IN$"
     404/    224C : CC 45 46 54 24      	DB	0CCH,"EFT$"
     405/    2251 : D2 49 47 48 54 24   	DB	0D2H,"IGHT$"
     406/    2257 : CD 49 44 24         	DB	0CDH,"ID$"
     407/    225B : 80                  	DB	80H		; End of list marker
     408/    225C :                     ;
     409/    225C :                     ; KEYWORD ADDRESS TABLE
     410/    225C :                     ;
     411/    225C : 54 28               WORDTB: DW	PEND
     412/    225E : 51 27               	DW	FOR
     413/    2260 : 2C 2C               	DW	NEXT
     414/    2262 : A1 29               	DW	DATA
     415/    2264 : 33 2B               	DW	INPUT
     416/    2266 : 68 2E               	DW	DIM
     417/    2268 : 62 2B               	DW	READ
     418/    226A : B8 29               	DW	LET
     419/    226C : 5E 29               	DW	GOTO
     420/    226E : 41 29               	DW	RUN
     421/    2270 : 30 2A               	DW	IF_
     422/    2272 : 1A 28               	DW	RESTOR
     423/    2274 : 4D 29               	DW	GOSUB
     424/    2276 : 7C 29               	DW	RETURN
     425/    2278 : A3 29               	DW	REM
     426/    227A : 52 28               	DW	STOP
     427/    227C : A1 33               	DW	POUT
     428/    227E : 12 2A               	DW	ON
     429/    2280 : 93 28               	DW	NULL
     430/    2282 : A7 33               	DW	WAIT
     431/    2284 : 46 30               	DW	DEF
     432/    2286 : F0 33               	DW	POKE
     433/    2288 : 37 3B               	DW	DOKE
     434/    228A : A3 29               	DW	REM
     435/    228C : 1D 3B               	DW	LINES
     436/    228E : 11 3B               	DW	CLS
     437/    2290 : 15 3B               	DW	WIDTH
     438/    2292 : 43 3C               	DW	MONITR
     439/    2294 : 99 C0               	DW	PSET
     440/    2296 : 9C C0               	DW	RESET
     441/    2298 : 54 2A               	DW	PRINT
     442/    229A : 80 28               	DW	CONT
     443/    229C : C6 26               	DW	LIST
     444/    229E : FB 28               	DW	CLEAR
     445/    22A0 : A3 29               	DW	REM
     446/    22A2 : A3 29               	DW	REM
     447/    22A4 : C0 24               	DW	NEW
     448/    22A6 :                     ;
     449/    22A6 :                     ; RESERVED WORD TOKEN VALUES
     450/    22A6 :                     ;
     451/    22A6 : =80H                 ZEND	EQU	080H		; END
     452/    22A6 : =81H                 ZFOR	EQU	081H		; FOR
     453/    22A6 : =83H                 ZDATA	EQU	083H		; DATA
     454/    22A6 : =88H                 ZGOTO	EQU	088H		; GOTO
     455/    22A6 : =8CH                 ZGOSUB	EQU	08CH		; GOSUB
     456/    22A6 : =8EH                 ZREM	EQU	08EH		; REM
     457/    22A6 : =9EH                 ZPRINT	EQU	09EH		; PRINT
     458/    22A6 : =0A4H                ZNEW	EQU	0A4H		; NEW
     459/    22A6 :                     ;
     460/    22A6 : =0A5H                ZTAB	EQU	0A5H		; TAB
     461/    22A6 : =0A6H                ZTO	EQU	0A6H		; TO
     462/    22A6 : =0A7H                ZFN	EQU	0A7H		; FN
     463/    22A6 : =0A8H                ZSPC	EQU	0A8H		; SPC
     464/    22A6 : =0A9H                ZTHEN	EQU	0A9H		; THEN
     465/    22A6 : =0AAH                ZNOT	EQU	0AAH		; NOT
     466/    22A6 : =0ABH                ZSTEP	EQU	0ABH		; STEP
     467/    22A6 :                     ;
     468/    22A6 : =0ACH                ZPLUS	EQU	0ACH		; +
     469/    22A6 : =0ADH                ZMINUS	EQU	0ADH		; -
     470/    22A6 : =0AEH                ZTIMES	EQU	0AEH		; *
     471/    22A6 : =0AFH                ZDIV	EQU	0AFH		; /
     472/    22A6 : =0B2H                ZOR	EQU	0B2H		; OR
     473/    22A6 : =0B3H                ZGTR	EQU	0B3H		; >
     474/    22A6 : =0B4H                ZEQUAL	EQU	0B4H		; M
     475/    22A6 : =0B5H                ZLTH	EQU	0B5H		; <
     476/    22A6 : =0B6H                ZSGN	EQU	0B6H		; SGN
     477/    22A6 : =0C7H                ZPOINT	EQU	0C7H		; POINT
     478/    22A6 : =0CFH                ZLEFT	EQU	0CDH +2		; LEFT$
     479/    22A6 :                     ;
     480/    22A6 :                     ; ARITHMETIC PRECEDENCE TABLE
     481/    22A6 :                     ;
     482/    22A6 : 79                  PRITAB: DB	79H		; Precedence value
     483/    22A7 : DA 37               	DW	PADD		; FPREG = <last> + FPREG
     484/    22A9 :                     ;
     485/    22A9 : 79                  	DB	79H		; Precedence value
     486/    22AA : 0E 34               	DW	PSUB		; FPREG = <last> - FPREG
     487/    22AC :                     ;
     488/    22AC : 7C                  	DB	7CH		; Precedence value
     489/    22AD : 4C 35               	DW	MULT		; PPREG = <last> * FPREG
     490/    22AF :                     ;
     491/    22AF : 7C                  	DB	7CH		; Precedence value
     492/    22B0 : AD 35               	DW	DIV		; FPREG = <last> / FPREG
     493/    22B2 :                     ;
     494/    22B2 : 7F                  	DB	7FH		; Precedence value
     495/    22B3 : FB 38               	DW	POWER		; FPREG = <last> ^ FPREG
     496/    22B5 :                     ;
     497/    22B5 : 50                  	DB	50H		; Precedence value
     498/    22B6 : C1 2D               	DW	PAND		; FPREG = <last> AND FPREG
     499/    22B8 :                     ;
     500/    22B8 : 46                  	DB	46H		; Precedence value
     501/    22B9 : C0 2D               	DW	POR		; FPREG = <last> OR FPREG
     502/    22BB :                     ;
     503/    22BB :                     ; BASIC ERROR CODE LIST
     504/    22BB :                     ;
     505/    22BB : 4E 46               ERRORS: DB	"NF"		; NEXT without FOR
     506/    22BD : 53 4E               	DB	"SN"		; Syntax error
     507/    22BF : 52 47               	DB	"RG"		; RETURN without GOSUB
     508/    22C1 : 4F 44               	DB	"OD"		; Out of DATA
     509/    22C3 : 46 43               	DB	"FC"		; Illegal function call
     510/    22C5 : 4F 56               	DB	"OV"		; Overflow error
     511/    22C7 : 4F 4D               	DB	"OM"		; Out of memory
     512/    22C9 : 55 4C               	DB	"UL"		; Undefined line
     513/    22CB : 42 53               	DB	"BS"		; Bad subscript
     514/    22CD : 44 44               	DB	"DD"		; Re-DIMensioned array
     515/    22CF : 2F 30               	DB	"/0"		; Division by zero
     516/    22D1 : 49 44               	DB	"ID"		; Illegal direct
     517/    22D3 : 54 4D               	DB	"TM"		; Type mis-match
     518/    22D5 : 4F 53               	DB	"OS"		; Out of string space
     519/    22D7 : 4C 53               	DB	"LS"		; String too long
     520/    22D9 : 53 54               	DB	"ST"		; String formula too complex
     521/    22DB : 43 4E               	DB	"CN"		; Can't CONTinue
     522/    22DD : 55 46               	DB	"UF"		; Undefined FN function
     523/    22DF : 4D 4F               	DB	"MO"		; Missing operand
     524/    22E1 : 48 58               	DB	"HX"		; HEX error
     525/    22E3 : 42 4E               	DB	"BN"		; BIN error
     526/    22E5 :                     ;
     527/    22E5 :                     ; INITIALISATION TABLE -------------------------------------------------------
     528/    22E5 :                     ;
     529/    22E5 : C3 7B 20            INITAB: JP	WARMST		; Warm start jump
     530/    22E8 : C3 D1 28            	JP	FCERR		; "USR (X)" jump (Set to Error)
     531/    22EB : D3 00               	OUT	(0),A		; "OUT p,n" skeleton
     532/    22ED : C9                  	RET
     533/    22EE : D6 00               	SUB	0		; Division support routine
     534/    22F0 : 6F                  	LD	L,A
     535/    22F1 : 7C                  	LD	A,H
     536/    22F2 : DE 00               	SBC	A,0
     537/    22F4 : 67                  	LD	H,A
     538/    22F5 : 78                  	LD	A,B
     539/    22F6 : DE 00               	SBC	A,0
     540/    22F8 : 47                  	LD	B,A
     541/    22F9 : 3E 00               	LD	A,0
     542/    22FB : C9                  	RET
     543/    22FC : 00 00 00            	DB	0,0,0			; Random number seed table used by RND
     544/    22FF : 35 4A CA 99         	DB	035H,04AH,0CAH,099H	;-2.65145E+07
     545/    2303 : 39 1C 76 98         	DB	039H,01CH,076H,098H	; 1.61291E+07
     546/    2307 : 22 95 B3 98         	DB	022H,095H,0B3H,098H	;-1.17691E+07
     547/    230B : 0A DD 47 98         	DB	00AH,0DDH,047H,098H	; 1.30983E+07
     548/    230F : 53 D1 99 99         	DB	053H,0D1H,099H,099H	;-2-01612E+07
     549/    2313 : 0A 1A 9F 98         	DB	00AH,01AH,09FH,098H	;-1.04269E+07
     550/    2317 : 65 BC CD 98         	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
     551/    231B : D6 77 3E 98         	DB	0D6H,077H,03EH,098H	; 1.24825E+07
     552/    231F : 52 C7 4F 80         	DB	052H,0C7H,04FH,080H	; Last random number
     553/    2323 : DB 00               	IN	A,(0)		; INP (x) skeleton
     554/    2325 : C9                  	RET
     555/    2326 : 01                  	DB	1		; POS (x) number (1)
     556/    2327 : FF                  	DB	255		; Terminal width (255 = no auto CRLF)
     557/    2328 : 1C                  	DB	28		; Width for commas (3 columns)
     558/    2329 : 00                  	DB	0		; No nulls after input bytes
     559/    232A : 00                  	DB	0		; Output enabled (^O off)
     560/    232B : 14 00               	DW	20		; Initial lines counter
     561/    232D : 14 00               	DW	20		; Initial lines number
     562/    232F : 00 00               	DW	0		; Array load/save check sum
     563/    2331 : 00                  	DB	0		; Break not by NMI
     564/    2332 : 00                  	DB	0		; Break flag
     565/    2333 : C3 F9 25            	JP	TTYLIN		; Input reflection (set to TTY)
     566/    2336 : C3 00 00            	JP	0000H		; POINT reflection unused
     567/    2339 : C3 00 00            	JP	0000H		; SET reflection
     568/    233C : C3 00 00            	JP	0000H			; RESET reflection
     569/    233F : A2 C1               	DW	STLOOK		; Temp string space
     570/    2341 : FE FF               	DW	-2		; Current line number (cold)
     571/    2343 : 3F C1               	DW	PROGST+1	; Start of program text
     572/    2345 :                     INITBE:			 
     573/    2345 :                     ;
     574/    2345 :                     ; END OF INITIALISATION TABLE ---------------------------------------------------
     575/    2345 :                     ;
     576/    2345 : 20 45 72 72 6F 72   ERRMSG: DB	" Error",0
             234B : 00                
     577/    234C : 20 69 6E 20 00      INMSG:	DB	" in ",0
     578/    2351 : =2350H               ZERBYT	EQU	$-1		; A zero byte
     579/    2351 : 4F 6B 0D 0A 00 00   OKMSG:	DB	"Ok",CR,LF,0,0
     580/    2357 : 42 72 65 61 6B 00   BRKMSG: DB	"Break",0
     581/    235D :                     ;
     582/    235D : 21 04 00            BAKSTK: LD	HL,4		; Look for "FOR" block with
     583/    2360 : 39                  	ADD	HL,SP		; same index as specified
     584/    2361 : 7E                  LOKFOR: LD	A,(HL)		; Get block ID
     585/    2362 : 23                  	INC	HL		; Point to index address
     586/    2363 : FE 81               	CP	ZFOR		; Is it a "FOR" token
     587/    2365 : C0                  	RET	NZ		; No - exit
     588/    2366 : 4E                  	LD	C,(HL)		; BC = Address of "FOR" index
     589/    2367 : 23                  	INC	HL
     590/    2368 : 46                  	LD	B,(HL)
     591/    2369 : 23                  	INC	HL		; Point to sign of STEP
     592/    236A : E5                  	PUSH	HL		; Save pointer to sign
     593/    236B : 69                  	LD	L,C		; HL = address of "FOR" index
     594/    236C : 60                  	LD	H,B
     595/    236D : 7A                  	LD	A,D		; See if an index was specified
     596/    236E : B3                  	OR	E		; DE = 0 if no index specified
     597/    236F : EB                  	EX	DE,HL		; Specified index into HL
     598/    2370 : CA 77 23            	JP	Z,INDFND	; Skip if no index given
     599/    2373 : EB                  	EX	DE,HL		; Index back into DE
     600/    2374 : CD 7C 26            	CALL	CPDEHL		; Compare index with one given
     601/    2377 : 01 0D 00            INDFND: LD	BC,16-3		; Offset to next block
     602/    237A : E1                  	POP	HL		; Restore pointer to sign
     603/    237B : C8                  	RET	Z		; Return if block found
     604/    237C : 09                  	ADD	HL,BC		; Point to next block
     605/    237D : C3 61 23            	JP	LOKFOR		; Keep on looking
     606/    2380 :                     ;
     607/    2380 : CD 9A 23            MOVUP:	CALL	ENFMEM		; See if enough memory
     608/    2383 : C5                  MOVSTR: PUSH	BC		; Save end of source
     609/    2384 : E3                  	EX	(SP),HL		; Swap source and dest" end
     610/    2385 : C1                  	POP	BC		; Get end of destination
     611/    2386 : CD 7C 26            MOVLP:	CALL	CPDEHL		; See if list moved
     612/    2389 : 7E                  	LD	A,(HL)		; Get byte
     613/    238A : 02                  	LD	(BC),A		; Move it
     614/    238B : C8                  	RET	Z		; Exit if all done
     615/    238C : 0B                  	DEC	BC		; Next byte to move to
     616/    238D : 2B                  	DEC	HL		; Next byte to move
     617/    238E : C3 86 23            	JP	MOVLP		; Loop until all bytes moved
     618/    2391 :                     ;
     619/    2391 : E5                  CHKSTK: PUSH	HL		; Save code string address
     620/    2392 : 2A 1F C1            	LD	HL,(ARREND)	; Lowest free memory
     621/    2395 : 06 00               	LD	B,0		; BC = Number of levels to test
     622/    2397 : 09                  	ADD	HL,BC		; 2 Bytes for each level
     623/    2398 : 09                  	ADD	HL,BC
     624/    2399 : 3E                  	DB	3EH		; Skip "PUSH HL"
     625/    239A : E5                  ENFMEM: PUSH	HL		; Save code string address
     626/    239B : 3E D0               	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
     627/    239D : 95                  	SUB	L
     628/    239E : 6F                  	LD	L,A
     629/    239F : 3E FF               	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
     630/    23A1 : 9C                  	SBC	A,H
     631/    23A2 : DA A9 23            	JP	C,OMERR		; Not enough - ?OM Error
     632/    23A5 : 67                  	LD	H,A
     633/    23A6 : 39                  	ADD	HL,SP		; Test if stack is overflowed
     634/    23A7 : E1                  	POP	HL		; Restore code string address
     635/    23A8 : D8                  	RET	C		; Return if enough mmory
     636/    23A9 : 1E 0C               OMERR:	LD	E,OM		; ?OM Error
     637/    23AB : C3 C8 23            	JP	ERROR_
     638/    23AE :                     ;
     639/    23AE : 2A 0E C1            DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
     640/    23B1 : 22 A1 C0            	LD	(LINEAT),HL	; Save as current line
     641/    23B4 : 1E 02               SNERR:	LD	E,SN		; ?SN Error
     642/    23B6 : 01                  	DB	01H		; Skip "LD E,DZ"
     643/    23B7 : 1E 14               DZERR:	LD	E,DZ		; ?/0 Error
     644/    23B9 : 01                  	DB	01H		; Skip "LD E,NF"
     645/    23BA : 1E 00               NFERR:	LD	E,NF		; ?NF Error
     646/    23BC : 01                  	DB	01H		; Skip "LD E,RD"
     647/    23BD : 1E 12               DDERR:	LD	E,RD		; ?DD Error
     648/    23BF : 01                  	DB	01H		; Skip "LD E,UF"
     649/    23C0 : 1E 22               UFERR:	LD	E,UF		; ?UF Error
     650/    23C2 : 01                  	DB	01H		; Skip "LD E,OV
     651/    23C3 : 1E 0A               OVERR:	LD	E,OV		; ?OV Error
     652/    23C5 : 01                  	DB	01H		; Skip "LD E,TM"
     653/    23C6 : 1E 18               TMERR:	LD	E,TM		; ?TM Error
     654/    23C8 :                     ;
     655/    23C8 : CD E6 24            ERROR_:	CALL	CLREG		; Clear registers and stack
     656/    23CB : 32 8A C0            	LD	(CTLOFG),A	; Enable output (A is 0)
     657/    23CE : CD A5 2A            	CALL	STTLIN		; Start new line
     658/    23D1 : 21 BB 22            	LD	HL,ERRORS	; Point to error codes
     659/    23D4 : 57                  	LD	D,A		; D = 0 (A is 0)
     660/    23D5 : 3E 3F               	LD	A,'?'
     661/    23D7 : CD 8D 26            	CALL	OUTC		; Output '?'
     662/    23DA : 19                  	ADD	HL,DE		; Offset to correct error code
     663/    23DB : 7E                  	LD	A,(HL)		; First character
     664/    23DC : CD 8D 26            	CALL	OUTC		; Output it
     665/    23DF : CD 0A 28            	CALL	GETCHR		; Get next character
     666/    23E2 : CD 8D 26            	CALL	OUTC		; Output it
     667/    23E5 : 21 45 23            	LD	HL,ERRMSG	; "Error" message
     668/    23E8 : CD 50 31            ERRIN:	CALL	PRS		; Output message
     669/    23EB : 2A A1 C0            	LD	HL,(LINEAT)	; Get line of error
     670/    23EE : 11 FE FF            	LD	DE,-2		; Cold start error if -2
     671/    23F1 : CD 7C 26            	CALL	CPDEHL		; See if cold start error
     672/    23F4 : CA 0D 20            	JP	Z,CSTART	; Cold start error - Restart
     673/    23F7 : 7C                  	LD	A,H		; Was it a direct error?
     674/    23F8 : A5                  	AND	L		; Line = -1 if direct error
     675/    23F9 : 3C                  	INC	A
     676/    23FA : C4 EB 37            	CALL	NZ,LINEIN	; No - output line of error
     677/    23FD : 3E                  	DB	3EH		; Skip "POP BC"
     678/    23FE : C1                  POPNOK: POP	BC		; Drop address in input buffer
     679/    23FF :                     ;
     680/    23FF : AF                  PRNTOK: XOR	A		; Output "Ok" and get command
     681/    2400 : 32 8A C0            	LD	(CTLOFG),A	; Enable output
     682/    2403 : CD A5 2A            	CALL	STTLIN		; Start new line
     683/    2406 : 21 51 23            	LD	HL,OKMSG	; "Ok" message
     684/    2409 : CD 50 31            	CALL	PRS		; Output "Ok"
     685/    240C : 21 FF FF            GETCMD: LD	HL,-1		; Flag direct mode
     686/    240F : 22 A1 C0            	LD	(LINEAT),HL	; Save as current line
     687/    2412 : CD F9 25            	CALL	GETLIN		; Get an input line
     688/    2415 : DA 0C 24            	JP	C,GETCMD	; Get line again if break
     689/    2418 : CD 0A 28            	CALL	GETCHR		; Get first character
     690/    241B : 3C                  	INC	A		; Test if end of line
     691/    241C : 3D                  	DEC	A		; Without affecting Carry
     692/    241D : CA 0C 24            	JP	Z,GETCMD	; Nothing entered - Get another
     693/    2420 : F5                  	PUSH	AF		; Save Carry status
     694/    2421 : CD D6 28            	CALL	ATOH		; Get line number into DE
     695/    2424 : D5                  	PUSH	DE		; Save line number
     696/    2425 : CD 10 25            	CALL	CRUNCH		; Tokenise rest of line
     697/    2428 : 47                  	LD	B,A		; Length of tokenised line
     698/    2429 : D1                  	POP	DE		; Restore line number
     699/    242A : F1                  	POP	AF		; Restore Carry
     700/    242B : D2 EA 27            	JP	NC,EXCUTE	; No line number - Direct mode
     701/    242E : D5                  	PUSH	DE		; Save line number
     702/    242F : C5                  	PUSH	BC		; Save length of tokenised line
     703/    2430 : AF                  	XOR	A
     704/    2431 : 32 11 C1            	LD	(LSTBIN),A	; Clear last byte input
     705/    2434 : CD 0A 28            	CALL	GETCHR		; Get next character
     706/    2437 : B7                  	OR	A		; Set flags
     707/    2438 : F5                  	PUSH	AF		; And save them
     708/    2439 : CD A0 24            	CALL	SRCHLN		; Search for line number in DE
     709/    243C : DA 45 24            	JP	C,LINFND	; Jump if line found
     710/    243F : F1                  	POP	AF		; Get status
     711/    2440 : F5                  	PUSH	AF		; And re-save
     712/    2441 : CA 77 29            	JP	Z,ULERR	; Nothing after number - Error
     713/    2444 : B7                  	OR	A		; Clear Carry
     714/    2445 : C5                  LINFND: PUSH	BC		; Save address of line in prog
     715/    2446 : D2 5C 24            	JP	NC,INEWLN	; Line not found - Insert new
     716/    2449 : EB                  	EX	DE,HL		; Next line address in DE
     717/    244A : 2A 1B C1            	LD	HL,(PROGND)	; End of program
     718/    244D : 1A                  SFTPRG: LD	A,(DE)		; Shift rest of program down
     719/    244E : 02                  	LD	(BC),A
     720/    244F : 03                  	INC	BC		; Next destination
     721/    2450 : 13                  	INC	DE		; Next source
     722/    2451 : CD 7C 26            	CALL	CPDEHL		; All done?
     723/    2454 : C2 4D 24            	JP	NZ,SFTPRG	; More to do
     724/    2457 : 60                  	LD	H,B		; HL - New end of program
     725/    2458 : 69                  	LD	L,C
     726/    2459 : 22 1B C1            	LD	(PROGND),HL	; Update end of program
     727/    245C :                     ;
     728/    245C : D1                  INEWLN: POP	DE		; Get address of line,
     729/    245D : F1                  	POP	AF		; Get status
     730/    245E : CA 83 24            	JP	Z,SETPTR	; No text - Set up pointers
     731/    2461 : 2A 1B C1            	LD	HL,(PROGND)	; Get end of program
     732/    2464 : E3                  	EX	(SP),HL		; Get length of input line
     733/    2465 : C1                  	POP	BC		; End of program to BC
     734/    2466 : 09                  	ADD	HL,BC		; Find new end
     735/    2467 : E5                  	PUSH	HL		; Save new end
     736/    2468 : CD 80 23            	CALL	MOVUP		; Make space for line
     737/    246B : E1                  	POP	HL		; Restore new end
     738/    246C : 22 1B C1            	LD	(PROGND),HL	; Update end of program pointer
     739/    246F : EB                  	EX	DE,HL		; Get line to move up in HL
     740/    2470 : 74                  	LD	(HL),H		; Save MSB
     741/    2471 : D1                  	POP	DE		; Get new line number
     742/    2472 : 23                  	INC	HL		; Skip pointer
     743/    2473 : 23                  	INC	HL
     744/    2474 : 73                  	LD	(HL),E		; Save LSB of line number
     745/    2475 : 23                  	INC	HL
     746/    2476 : 72                  	LD	(HL),D		; Save MSB of line number
     747/    2477 : 23                  	INC	HL		; To first byte in line
     748/    2478 : 11 A6 C0            	LD	DE,BUFFER	; Copy buffer to program
     749/    247B : 1A                  MOVBUF: LD	A,(DE)		; Get source
     750/    247C : 77                  	LD	(HL),A		; Save destinations
     751/    247D : 23                  	INC	HL		; Next source
     752/    247E : 13                  	INC	DE		; Next destination
     753/    247F : B7                  	OR	A		; Done?
     754/    2480 : C2 7B 24            	JP	NZ,MOVBUF	; No - Repeat
     755/    2483 : CD CC 24            SETPTR: CALL	RUNFST		; Set line pointers
     756/    2486 : 23                  	INC	HL		; To LSB of pointer
     757/    2487 : EB                  	EX	DE,HL		; Address to DE
     758/    2488 : 62                  PTRLP:	LD	H,D		; Address to HL
     759/    2489 : 6B                  	LD	L,E
     760/    248A : 7E                  	LD	A,(HL)		; Get LSB of pointer
     761/    248B : 23                  	INC	HL		; To MSB of pointer
     762/    248C : B6                  	OR	(HL)		; Compare with MSB pointer
     763/    248D : CA 0C 24            	JP	Z,GETCMD	; Get command line if end
     764/    2490 : 23                  	INC	HL		; To LSB of line number
     765/    2491 : 23                  	INC	HL		; Skip line number
     766/    2492 : 23                  	INC	HL		; Point to first byte in line
     767/    2493 : AF                  	XOR	A		; Looking for 00 byte
     768/    2494 : BE                  FNDEND: CP	(HL)		; Found end of line?
     769/    2495 : 23                  	INC	HL		; Move to next byte
     770/    2496 : C2 94 24            	JP	NZ,FNDEND	; No - Keep looking
     771/    2499 : EB                  	EX	DE,HL		; Next line address to HL
     772/    249A : 73                  	LD	(HL),E		; Save LSB of pointer
     773/    249B : 23                  	INC	HL
     774/    249C : 72                  	LD	(HL),D		; Save MSB of pointer
     775/    249D : C3 88 24            	JP	PTRLP		; Do next line
     776/    24A0 :                     ;
     777/    24A0 : 2A A3 C0            SRCHLN: LD	HL,(BASTXT)	; Start of program text
     778/    24A3 : 44                  SRCHLP: LD	B,H		; BC = Address to look at
     779/    24A4 : 4D                  	LD	C,L
     780/    24A5 : 7E                  	LD	A,(HL)		; Get address of next line
     781/    24A6 : 23                  	INC	HL
     782/    24A7 : B6                  	OR	(HL)		; End of program found?
     783/    24A8 : 2B                  	DEC	HL
     784/    24A9 : C8                  	RET	Z		; Yes - Line not found
     785/    24AA : 23                  	INC	HL
     786/    24AB : 23                  	INC	HL
     787/    24AC : 7E                  	LD	A,(HL)		; Get LSB of line number
     788/    24AD : 23                  	INC	HL
     789/    24AE : 66                  	LD	H,(HL)		; Get MSB of line number
     790/    24AF : 6F                  	LD	L,A
     791/    24B0 : CD 7C 26            	CALL	CPDEHL		; Compare with line in DE
     792/    24B3 : 60                  	LD	H,B		; HL = Start of this line
     793/    24B4 : 69                  	LD	L,C
     794/    24B5 : 7E                  	LD	A,(HL)		; Get LSB of next line address
     795/    24B6 : 23                  	INC	HL
     796/    24B7 : 66                  	LD	H,(HL)		; Get MSB of next line address
     797/    24B8 : 6F                  	LD	L,A		; Next line to HL
     798/    24B9 : 3F                  	CCF
     799/    24BA : C8                  	RET	Z		; Lines found - Exit
     800/    24BB : 3F                  	CCF
     801/    24BC : D0                  	RET	NC		; Line not found,at line after
     802/    24BD : C3 A3 24            	JP	SRCHLP		; Keep looking
     803/    24C0 :                     ;
     804/    24C0 : C0                  NEW:	RET	NZ		; Return if any more on line
     805/    24C1 : 2A A3 C0            CLRPTR: LD	HL,(BASTXT)	; Point to start of program
     806/    24C4 : AF                  	XOR	A		; Set program area to empty
     807/    24C5 : 77                  	LD	(HL),A		; Save LSB = 00
     808/    24C6 : 23                  	INC	HL
     809/    24C7 : 77                  	LD	(HL),A		; Save MSB = 00
     810/    24C8 : 23                  	INC	HL
     811/    24C9 : 22 1B C1            	LD	(PROGND),HL	; Set program end
     812/    24CC :                     ;
     813/    24CC : 2A A3 C0            RUNFST: LD	HL,(BASTXT)	; Clear all variables
     814/    24CF : 2B                  	DEC	HL
     815/    24D0 :                     ;
     816/    24D0 : 22 13 C1            INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
     817/    24D3 : 2A F4 C0            	LD	HL,(LSTRAM)	; Get end of RAM
     818/    24D6 : 22 08 C1            	LD	(STRBOT),HL	; Clear string space
     819/    24D9 : AF                  	XOR	A
     820/    24DA : CD 1A 28            	CALL	RESTOR		; Reset DATA pointers
     821/    24DD : 2A 1B C1            	LD	HL,(PROGND)	; Get end of program
     822/    24E0 : 22 1D C1            	LD	(VAREND),HL	; Clear variables
     823/    24E3 : 22 1F C1            	LD	(ARREND),HL	; Clear arrays
     824/    24E6 :                     ;
     825/    24E6 : C1                  CLREG:	POP	BC		; Save return address
     826/    24E7 : 2A 9F C0            	LD	HL,(STRSPC)	; Get end of working RAN
     827/    24EA : F9                  	LD	SP,HL		; Set stack
     828/    24EB : 21 F8 C0            	LD	HL,TMSTPL	; Temporary string pool
     829/    24EE : 22 F6 C0            	LD	(TMSTPT),HL	; Reset temporary string ptr
     830/    24F1 : AF                  	XOR	A		; A = 00
     831/    24F2 : 6F                  	LD	L,A		; HL = 0000
     832/    24F3 : 67                  	LD	H,A
     833/    24F4 : 22 19 C1            	LD	(CONTAD),HL	; No CONTinue
     834/    24F7 : 32 10 C1            	LD	(FORFLG),A	; Clear FOR flag
     835/    24FA : 22 23 C1            	LD	(FNRGNM),HL	; Clear FN argument
     836/    24FD : E5                  	PUSH	HL		; HL = 0000
     837/    24FE : C5                  	PUSH	BC		; Put back return
     838/    24FF : 2A 13 C1            DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
     839/    2502 : C9                  	RET			; Return to execution driver
     840/    2503 :                     ;
     841/    2503 : 3E 3F               PROMPT: LD	A,'?'		; '?'
     842/    2505 : CD 8D 26            	CALL	OUTC		; Output character
     843/    2508 : 3E 20               	LD	A,' '		; Space
     844/    250A : CD 8D 26            	CALL	OUTC		; Output character
     845/    250D : C3 93 C0            	JP	RINPUT		; Get input line
     846/    2510 :                     ;
     847/    2510 : AF                  CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
     848/    2511 : 32 F3 C0            	LD	(DATFLG),A	; Reset literal flag
     849/    2514 : 0E 05               	LD	C,2+3		; 2 byte number and 3 nulls
     850/    2516 : 11 A6 C0            	LD	DE,BUFFER	; Start of input buffer
     851/    2519 : 7E                  CRNCLP: LD	A,(HL)		; Get byte
     852/    251A : FE 20               	CP	' '		; Is it a space?
     853/    251C : CA 98 25            	JP	Z,MOVDIR	; Yes - Copy direct
     854/    251F : 47                  	LD	B,A		; Save character
     855/    2520 : FE 22               	CP	'"'		; Is it a quote?
     856/    2522 : CA B8 25            	JP	Z,CPYLIT	; Yes - Copy literal string
     857/    2525 : B7                  	OR	A		; Is it end of buffer?
     858/    2526 : CA BF 25            	JP	Z,ENDBUF	; Yes - End buffer
     859/    2529 : 3A F3 C0            	LD	A,(DATFLG)	; Get data type
     860/    252C : B7                  	OR	A		; Literal?
     861/    252D : 7E                  	LD	A,(HL)		; Get byte to copy
     862/    252E : C2 98 25            	JP	NZ,MOVDIR	; Literal - Copy direct
     863/    2531 : FE 3F               	CP	'?'		; Is it '?' short for PRINT
     864/    2533 : 3E 9E               	LD	A,ZPRINT	; "PRINT" token
     865/    2535 : CA 98 25            	JP	Z,MOVDIR	; Yes - replace it
     866/    2538 : 7E                  	LD	A,(HL)		; Get byte again
     867/    2539 : FE 30               	CP	'0'		; Is it less than '0'
     868/    253B : DA 43 25            	JP	C,FNDWRD	; Yes - Look for reserved words
     869/    253E : FE 3C               	CP	60		; ";"+1; Is it "0123456789:;" ?
     870/    2540 : DA 98 25            	JP	C,MOVDIR	; Yes - copy it direct
     871/    2543 : D5                  FNDWRD: PUSH	DE		; Look for reserved words
     872/    2544 : 11 3C 21            	LD	DE,WORDS-1	; Point to table
     873/    2547 : C5                  	PUSH	BC		; Save count
     874/    2548 : 01 94 25            	LD	BC,RETNAD	; Where to return to
     875/    254B : C5                  	PUSH	BC		; Save return address
     876/    254C : 06 7F               	LD	B,ZEND-1	; First token value -1
     877/    254E : 7E                  	LD	A,(HL)		; Get byte
     878/    254F : FE 61               	CP	'a'		; Less than 'a' ?
     879/    2551 : DA 5C 25            	JP	C,SEARCH	; Yes - search for words
     880/    2554 : FE 7B               	CP	'z'+1		; Greater than 'z' ?
     881/    2556 : D2 5C 25            	JP	NC,SEARCH	; Yes - search for words
     882/    2559 : E6 5F               	AND	01011111B	; Force upper case
     883/    255B : 77                  	LD	(HL),A		; Replace byte
     884/    255C : 4E                  SEARCH: LD	C,(HL)		; Search for a word
     885/    255D : EB                  	EX	DE,HL
     886/    255E : 23                  GETNXT: INC	HL		; Get next reserved word
     887/    255F : B6                  	OR	(HL)		; Start of word?
     888/    2560 : F2 5E 25            	JP	P,GETNXT	; No - move on
     889/    2563 : 04                  	INC	B		; Increment token value
     890/    2564 : 7E                  	LD	A, (HL)		; Get byte from table
     891/    2565 : E6 7F               	AND	01111111B	; Strip bit 7
     892/    2567 : C8                  	RET	Z		; Return if end of list
     893/    2568 : B9                  	CP	C		; Same character as in buffer?
     894/    2569 : C2 5E 25            	JP	NZ,GETNXT	; No - get next word
     895/    256C : EB                  	EX	DE,HL
     896/    256D : E5                  	PUSH	HL		; Save start of word
     897/    256E :                     ;
     898/    256E : 13                  NXTBYT: INC	DE		; Look through rest of word
     899/    256F : 1A                  	LD	A,(DE)		; Get byte from table
     900/    2570 : B7                  	OR	A		; End of word ?
     901/    2571 : FA 90 25            	JP	M,MATCH		; Yes - Match found
     902/    2574 : 4F                  	LD	C,A		; Save it
     903/    2575 : 78                  	LD	A,B		; Get token value
     904/    2576 : FE 88               	CP	ZGOTO		; Is it "GOTO" token ?
     905/    2578 : C2 7F 25            	JP	NZ,NOSPC	; No - Don't allow spaces
     906/    257B : CD 0A 28            	CALL	GETCHR		; Get next character
     907/    257E : 2B                  	DEC	HL		; Cancel increment from GETCHR
     908/    257F : 23                  NOSPC:	INC	HL		; Next byte
     909/    2580 : 7E                  	LD	A,(HL)		; Get byte
     910/    2581 : FE 61               	CP	'a'		; Less than 'a' ?
     911/    2583 : DA 88 25            	JP	C,NOCHNG	; Yes - don't change
     912/    2586 : E6 5F               	AND	01011111B	; Make upper case
     913/    2588 : B9                  NOCHNG: CP	C		; Same as in buffer ?
     914/    2589 : CA 6E 25            	JP	Z,NXTBYT	; Yes - keep testing
     915/    258C : E1                  	POP	HL		; Get back start of word
     916/    258D : C3 5C 25            	JP	SEARCH		; Look at next word
     917/    2590 :                     ;
     918/    2590 : 48                  MATCH:	LD	C,B		; Word found - Save token value
     919/    2591 : F1                  	POP	AF		; Throw away return
     920/    2592 : EB                  	EX	DE,HL
     921/    2593 : C9                  	RET			; Return to "RETNAD"
     922/    2594 : EB                  RETNAD: EX	DE,HL		; Get address in string
     923/    2595 : 79                  	LD	A,C		; Get token value
     924/    2596 : C1                  	POP	BC		; Restore buffer length
     925/    2597 : D1                  	POP	DE		; Get destination address
     926/    2598 : 23                  MOVDIR: INC	HL		; Next source in buffer
     927/    2599 : 12                  	LD	(DE),A		; Put byte in buffer
     928/    259A : 13                  	INC	DE		; Move up buffer
     929/    259B : 0C                  	INC	C		; Increment length of buffer
     930/    259C : D6 3A               	SUB	':'		; End of statement?
     931/    259E : CA A6 25            	JP	Z,SETLIT	; Jump if multi-statement line
     932/    25A1 : FE 49               	CP	ZDATA-3AH	; Is it DATA statement ?
     933/    25A3 : C2 A9 25            	JP	NZ,TSTREM	; No - see if REM
     934/    25A6 : 32 F3 C0            SETLIT: LD	(DATFLG),A	; Set literal flag
     935/    25A9 : D6 54               TSTREM: SUB	ZREM-3AH	; Is it REM?
     936/    25AB : C2 19 25            	JP	NZ,CRNCLP	; No - Leave flag
     937/    25AE : 47                  	LD	B,A		; Copy rest of buffer
     938/    25AF : 7E                  NXTCHR: LD	A,(HL)		; Get byte
     939/    25B0 : B7                  	OR	A		; End of line ?
     940/    25B1 : CA BF 25            	JP	Z,ENDBUF	; Yes - Terminate buffer
     941/    25B4 : B8                  	CP	B		; End of statement ?
     942/    25B5 : CA 98 25            	JP	Z,MOVDIR	; Yes - Get next one
     943/    25B8 : 23                  CPYLIT: INC	HL		; Move up source string
     944/    25B9 : 12                  	LD	(DE),A		; Save in destination
     945/    25BA : 0C                  	INC	C		; Increment length
     946/    25BB : 13                  	INC	DE		; Move up destination
     947/    25BC : C3 AF 25            	JP	NXTCHR		; Repeat
     948/    25BF :                     ;
     949/    25BF : 21 A5 C0            ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
     950/    25C2 : 12                  	LD	(DE),A		; Mark end of buffer (A = 00)
     951/    25C3 : 13                  	INC	DE
     952/    25C4 : 12                  	LD	(DE),A		; A = 00
     953/    25C5 : 13                  	INC	DE
     954/    25C6 : 12                  	LD	(DE),A		; A = 00
     955/    25C7 : C9                  	RET
     956/    25C8 :                     ;
     957/    25C8 : 3A 89 C0            DODEL:	LD	A,(NULFLG)	; Get null flag status
     958/    25CB : B7                  	OR	A		; Is it zero?
     959/    25CC : 3E 00               	LD	A,0		; Zero A - Leave flags
     960/    25CE : 32 89 C0            	LD	(NULFLG),A	; Zero null flag
     961/    25D1 : C2 DC 25            	JP	NZ,ECHDEL	; Set - Echo it
     962/    25D4 : 05                  	DEC	B		; Decrement length
     963/    25D5 : CA F9 25            	JP	Z,GETLIN	; Get line again if empty
     964/    25D8 : CD 8D 26            	CALL	OUTC		; Output null character
     965/    25DB : 3E                  	DB	3EH		; Skip "DEC B"
     966/    25DC : 05                  ECHDEL: DEC	B		; Count bytes in buffer
     967/    25DD : 2B                  	DEC	HL		; Back space buffer
     968/    25DE : CA F0 25            	JP	Z,OTKLN		; No buffer - Try again
     969/    25E1 : 7E                  	LD	A,(HL)		; Get deleted byte
     970/    25E2 : CD 8D 26            	CALL	OUTC		; Echo it
     971/    25E5 : C3 02 26            	JP	MORINP		; Get more input
     972/    25E8 :                     ;
     973/    25E8 : 05                  DELCHR: DEC	B		; Count bytes in buffer
     974/    25E9 : 2B                  	DEC	HL		; Back space buffer
     975/    25EA : CD 8D 26            	CALL	OUTC		; Output character in A
     976/    25ED : C2 02 26            	JP	NZ,MORINP	; Not end - Get more
     977/    25F0 : CD 8D 26            OTKLN:	CALL	OUTC		; Output character in A
     978/    25F3 : CD B2 2A            KILIN:	CALL	PRCRLF		; Output CRLF
     979/    25F6 : C3 F9 25            	JP	TTYLIN		; Get line again
     980/    25F9 :                     ;
     981/    25F9 :                     GETLIN:
     982/    25F9 : 21 A6 C0            TTYLIN: LD	HL,BUFFER	; Get a line by character
     983/    25FC : 06 01               	LD	B,1		; Set buffer as empty
     984/    25FE : AF                  	XOR	A
     985/    25FF : 32 89 C0            	LD	(NULFLG),A	; Clear null flag
     986/    2602 : CD B5 26            MORINP: CALL	CLOTST		; Get character and test ^O
     987/    2605 : 4F                  	LD	C,A		; Save character in C
     988/    2606 : FE 7F               	CP	DEL		; Delete character?
     989/    2608 : CA C8 25            	JP	Z,DODEL	; Yes - Process it
     990/    260B : 3A 89 C0            	LD	A,(NULFLG)	; Get null flag
     991/    260E : B7                  	OR	A		; Test null flag status
     992/    260F : CA 1B 26            	JP	Z,PROCES	; Reset - Process character
     993/    2612 : 3E 00               	LD	A,0		; Set a null
     994/    2614 : CD 8D 26            	CALL	OUTC		; Output null
     995/    2617 : AF                  	XOR	A		; Clear A
     996/    2618 : 32 89 C0            	LD	(NULFLG),A	; Reset null flag
     997/    261B : 79                  PROCES: LD	A,C		; Get character
     998/    261C : FE 07               	CP	CTRLG		; Bell?
     999/    261E : CA 5F 26            	JP	Z,PUTCTL	; Yes - Save it
    1000/    2621 : FE 03               	CP	CTRLC		; Is it control "C"?
    1001/    2623 : CC B2 2A            	CALL	Z,PRCRLF	; Yes - Output CRLF
    1002/    2626 : 37                  	SCF			; Flag break
    1003/    2627 : C8                  	RET	Z		; Return if control "C"
    1004/    2628 : FE 0D               	CP	CR		; Is it enter?
    1005/    262A : CA AD 2A            	JP	Z,ENDINP	; Yes - Terminate input
    1006/    262D : FE 15               	CP	CTRLU		; Is it control "U"?
    1007/    262F : CA F3 25            	JP	Z,KILIN		; Yes - Get another line
    1008/    2632 : FE 40               	CP	'@'		; Is it "kill line"?
    1009/    2634 : CA F0 25            	JP	Z,OTKLN		; Yes - Kill line
    1010/    2637 : FE 5F               	CP	'_'		; Is it delete?
    1011/    2639 : CA E8 25            	JP	Z,DELCHR	; Yes - Delete character
    1012/    263C : FE 08               	CP	BKSP		; Is it backspace?
    1013/    263E : CA E8 25            	JP	Z,DELCHR	; Yes - Delete character
    1014/    2641 : FE 12               	CP	CTRLR		; Is it control "R"?
    1015/    2643 : C2 5A 26            	JP	NZ,PUTBUF	; No - Put in buffer
    1016/    2646 : C5                  	PUSH	BC		; Save buffer length
    1017/    2647 : D5                  	PUSH	DE		; Save DE
    1018/    2648 : E5                  	PUSH	HL		; Save buffer address
    1019/    2649 : 36 00               	LD	(HL),0		; Mark end of buffer
    1020/    264B : CD 55 3C            	CALL	OUTNCR		; Output and do CRLF
    1021/    264E : 21 A6 C0            	LD	HL,BUFFER	; Point to buffer start
    1022/    2651 : CD 50 31            	CALL	PRS		; Output buffer
    1023/    2654 : E1                  	POP	HL		; Restore buffer address
    1024/    2655 : D1                  	POP	DE		; Restore DE
    1025/    2656 : C1                  	POP	BC		; Restore buffer length
    1026/    2657 : C3 02 26            	JP	MORINP		; Get another character
    1027/    265A :                     ;
    1028/    265A : FE 20               PUTBUF: CP	' '		; Is it a control code?
    1029/    265C : DA 02 26            	JP	C,MORINP	; Yes - Ignore
    1030/    265F : 78                  PUTCTL: LD	A,B		; Get number of bytes in buffer
    1031/    2660 : FE 49               	CP	72+1		; Test for line overflow
    1032/    2662 : 3E 07               	LD	A,CTRLG		; Set a bell
    1033/    2664 : D2 74 26            	JP	NC,OUTNBS	; Ring bell if buffer full
    1034/    2667 : 79                  	LD	A,C		; Get character
    1035/    2668 : 71                  	LD	(HL),C		; Save in buffer
    1036/    2669 : 32 11 C1            	LD	(LSTBIN),A	; Save last input byte
    1037/    266C : 23                  	INC	HL		; Move up buffer
    1038/    266D : 04                  	INC	B		; Increment length
    1039/    266E : CD 8D 26            OUTIT:	CALL	OUTC		; Output the character entered
    1040/    2671 : C3 02 26            	JP	MORINP		; Get another character
    1041/    2674 :                     ;
    1042/    2674 : CD 8D 26            OUTNBS: CALL	OUTC		; Output bell and back over it
    1043/    2677 : 3E 08               	LD	A,BKSP		; Set back space
    1044/    2679 : C3 6E 26            	JP	OUTIT		; Output it and get more
    1045/    267C :                     ;
    1046/    267C : 7C                  CPDEHL: LD	A,H		; Get H
    1047/    267D : 92                  	SUB	D		; Compare with D
    1048/    267E : C0                  	RET	NZ		; Different - Exit
    1049/    267F : 7D                  	LD	A,L		; Get L
    1050/    2680 : 93                  	SUB	E		; Compare with E
    1051/    2681 : C9                  	RET			; Return status
    1052/    2682 :                     ;
    1053/    2682 : 7E                  CHKSYN: LD	A,(HL)		; Check syntax of character
    1054/    2683 : E3                  	EX	(SP),HL		; Address of test byte
    1055/    2684 : BE                  	CP	(HL)		; Same as in code string?
    1056/    2685 : 23                  	INC	HL		; Return address
    1057/    2686 : E3                  	EX	(SP),HL		; Put it back
    1058/    2687 : CA 0A 28            	JP	Z,GETCHR	; Yes - Get next character
    1059/    268A : C3 B4 23            	JP	SNERR		; Different - ?SN Error
    1060/    268D :                     ;
    1061/    268D : F5                  OUTC:	PUSH	AF		; Save character
    1062/    268E : 3A 8A C0            	LD	A,(CTLOFG)	; Get control "O" flag
    1063/    2691 : B7                  	OR	A		; Is it set?
    1064/    2692 : C2 85 31            	JP	NZ,POPAF	; Yes - don't output
    1065/    2695 : F1                  	POP	AF		; Restore character
    1066/    2696 : C5                  	PUSH	BC		; Save buffer length
    1067/    2697 : F5                  	PUSH	AF		; Save character
    1068/    2698 : FE 20               	CP	' '		; Is it a control code?
    1069/    269A : DA B1 26            	JP	C,DINPOS	; Yes - Don't INC POS(X)
    1070/    269D : 3A 87 C0            	LD	A,(LWIDTH)	; Get line width
    1071/    26A0 : 47                  	LD	B,A		; To B
    1072/    26A1 : 3A F0 C0            	LD	A,(CURPOS)	; Get cursor position
    1073/    26A4 : 04                  	INC	B		; Width 255?
    1074/    26A5 : CA AD 26            	JP	Z,INCLEN	; Yes - No width limit
    1075/    26A8 : 05                  	DEC	B		; Restore width
    1076/    26A9 : B8                  	CP	B		; At end of line?
    1077/    26AA : CC B2 2A            	CALL	Z,PRCRLF	; Yes - output CRLF
    1078/    26AD : 3C                  INCLEN: INC	A		; Move on one character
    1079/    26AE : 32 F0 C0            	LD	(CURPOS),A	; Save new position
    1080/    26B1 : F1                  DINPOS: POP	AF		; Restore character
    1081/    26B2 : C1                  	POP	BC		; Restore buffer length
    1082/    26B3 :                     ;	CALL	MONOUT		; Send it
    1083/    26B3 : CF                  	rst	08h
    1084/    26B4 : C9                  	RET
    1085/    26B5 :                     ;
    1086/    26B5 : CD 0F 3B            CLOTST: CALL	GETINP		; Get input character
    1087/    26B8 : E6 7F               	AND	01111111B	; Strip bit 7
    1088/    26BA : FE 0F               	CP	CTRLO		; Is it control "O"?
    1089/    26BC : C0                  	RET	NZ		; No don't flip flag
    1090/    26BD : 3A 8A C0            	LD	A,(CTLOFG)	; Get flag
    1091/    26C0 : 2F                  	CPL			; Flip it
    1092/    26C1 : 32 8A C0            	LD	(CTLOFG),A	; Put it back
    1093/    26C4 : AF                  	XOR	A		; Null character
    1094/    26C5 : C9                  	RET
    1095/    26C6 :                     ;
    1096/    26C6 : CD D6 28            LIST:	CALL	ATOH		; ASCII number to DE
    1097/    26C9 : C0                  	RET	NZ		; Return if anything extra
    1098/    26CA : C1                  	POP	BC		; Rubbish - Not needed
    1099/    26CB : CD A0 24            	CALL	SRCHLN		; Search for line number in DE
    1100/    26CE : C5                  	PUSH	BC		; Save address of line
    1101/    26CF : CD 1C 27            	CALL	SETLIN		; Set up lines counter
    1102/    26D2 : E1                  LISTLP: POP	HL		; Restore address of line
    1103/    26D3 : 4E                  	LD	C,(HL)		; Get LSB of next line
    1104/    26D4 : 23                  	INC	HL
    1105/    26D5 : 46                  	LD	B,(HL)		; Get MSB of next line
    1106/    26D6 : 23                  	INC	HL
    1107/    26D7 : 78                  	LD	A,B		; BC = 0 (End of program)?
    1108/    26D8 : B1                  	OR	C
    1109/    26D9 : CA FF 23            	JP	Z,PRNTOK	; Yes - Go to command mode
    1110/    26DC : CD 25 27            	CALL	COUNT		; Count lines
    1111/    26DF : CD 35 28            	CALL	TSTBRK		; Test for break key
    1112/    26E2 : C5                  	PUSH	BC		; Save address of next line
    1113/    26E3 : CD B2 2A            	CALL	PRCRLF		; Output CRLF
    1114/    26E6 : 5E                  	LD	E,(HL)		; Get LSB of line number
    1115/    26E7 : 23                  	INC	HL
    1116/    26E8 : 56                  	LD	D,(HL)		; Get MSB of line number
    1117/    26E9 : 23                  	INC	HL
    1118/    26EA : E5                  	PUSH	HL		; Save address of line start
    1119/    26EB : EB                  	EX	DE,HL		; Line number to HL
    1120/    26EC : CD F3 37            	CALL	PRNTHL		; Output line number in decimal
    1121/    26EF : 3E 20               	LD	A,' '		; Space after line number
    1122/    26F1 : E1                  	POP	HL		; Restore start of line address
    1123/    26F2 : CD 8D 26            LSTLP2: CALL	OUTC		; Output character in A
    1124/    26F5 : 7E                  LSTLP3: LD	A,(HL)		; Get next byte in line
    1125/    26F6 : B7                  	OR	A		; End of line?
    1126/    26F7 : 23                  	INC	HL		; To next byte in line
    1127/    26F8 : CA D2 26            	JP	Z,LISTLP	; Yes - get next line
    1128/    26FB : F2 F2 26            	JP	P,LSTLP2	; No token - output it
    1129/    26FE : D6 7F               	SUB	ZEND-1		; Find and output word
    1130/    2700 : 4F                  	LD	C,A		; Token offset+1 to C
    1131/    2701 : 11 3D 21            	LD	DE,WORDS	; Reserved word list
    1132/    2704 : 1A                  FNDTOK: LD	A,(DE)		; Get character in list
    1133/    2705 : 13                  	INC	DE		; Move on to next
    1134/    2706 : B7                  	OR	A		; Is it start of word?
    1135/    2707 : F2 04 27            	JP	P,FNDTOK	; No - Keep looking for word
    1136/    270A : 0D                  	DEC	C		; Count words
    1137/    270B : C2 04 27            	JP	NZ,FNDTOK	; Not there - keep looking
    1138/    270E : E6 7F               OUTWRD: AND	01111111B	; Strip bit 7
    1139/    2710 : CD 8D 26            	CALL	OUTC		; Output first character
    1140/    2713 : 1A                  	LD	A,(DE)		; Get next character
    1141/    2714 : 13                  	INC	DE		; Move on to next
    1142/    2715 : B7                  	OR	A		; Is it end of word?
    1143/    2716 : F2 0E 27            	JP	P,OUTWRD	; No - output the rest
    1144/    2719 : C3 F5 26            	JP	LSTLP3		; Next byte in line
    1145/    271C :                     ;
    1146/    271C : E5                  SETLIN: PUSH	HL		; Set up LINES counter
    1147/    271D : 2A 8D C0            	LD	HL,(LINESN)	; Get LINES number
    1148/    2720 : 22 8B C0            	LD	(LINESC),HL	; Save in LINES counter
    1149/    2723 : E1                  	POP	HL
    1150/    2724 : C9                  	RET
    1151/    2725 :                     ;
    1152/    2725 : E5                  COUNT:	PUSH	HL		; Save code string address
    1153/    2726 : D5                  	PUSH	DE
    1154/    2727 : 2A 8B C0            	LD	HL,(LINESC)	; Get LINES counter
    1155/    272A : 11 FF FF            	LD	DE,-1
    1156/    272D : ED 5A               	ADC	HL,DE		; Decrement
    1157/    272F : 22 8B C0            	LD	(LINESC),HL	; Put it back
    1158/    2732 : D1                  	POP	DE
    1159/    2733 : E1                  	POP	HL		; Restore code string address
    1160/    2734 : F0                  	RET	P		; Return if more lines to go
    1161/    2735 : E5                  	PUSH	HL		; Save code string address
    1162/    2736 : 2A 8D C0            	LD	HL,(LINESN)	; Get LINES number
    1163/    2739 : 22 8B C0            	LD	(LINESC),HL	; Reset LINES counter
    1164/    273C : CD 0F 3B            	CALL	GETINP		; Get input character
    1165/    273F : FE 03               	CP	CTRLC		; Is it control "C"?
    1166/    2741 : CA 48 27            	JP	Z,RSLNBK	; Yes - Reset LINES and break
    1167/    2744 : E1                  	POP	HL		; Restore code string address
    1168/    2745 : C3 25 27            	JP	COUNT		; Keep on counting
    1169/    2748 :                     ;
    1170/    2748 : 2A 8D C0            RSLNBK: LD	HL,(LINESN)	; Get LINES number
    1171/    274B : 22 8B C0            	LD	(LINESC),HL	; Reset LINES counter
    1172/    274E : C3 7E 20            	JP	BRKRET		; Go and output "Break"
    1173/    2751 :                     ;
    1174/    2751 : 3E 64               FOR:	LD	A,64H		; Flag "FOR" assignment
    1175/    2753 : 32 10 C1            	LD	(FORFLG),A	; Save "FOR" flag
    1176/    2756 : CD B8 29            	CALL	LET		; Set up initial index
    1177/    2759 : C1                  	POP	BC		; Drop RETurn address
    1178/    275A : E5                  	PUSH	HL		; Save code string address
    1179/    275B : CD A1 29            	CALL	DATA		; Get next statement address
    1180/    275E : 22 0C C1            	LD	(LOOPST),HL	; Save it for start of loop
    1181/    2761 : 21 02 00            	LD	HL,2		; Offset for "FOR" block
    1182/    2764 : 39                  	ADD	HL,SP		; Point to it
    1183/    2765 : CD 61 23            FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
    1184/    2768 : D1                  	POP	DE		; Get code string address
    1185/    2769 : C2 81 27            	JP	NZ,FORFND	; No nesting found
    1186/    276C : 09                  	ADD	HL,BC		; Move into "FOR" block
    1187/    276D : D5                  	PUSH	DE		; Save code string address
    1188/    276E : 2B                  	DEC	HL
    1189/    276F : 56                  	LD	D,(HL)		; Get MSB of loop statement
    1190/    2770 : 2B                  	DEC	HL
    1191/    2771 : 5E                  	LD	E,(HL)		; Get LSB of loop statement
    1192/    2772 : 23                  	INC	HL
    1193/    2773 : 23                  	INC	HL
    1194/    2774 : E5                  	PUSH	HL		; Save block address
    1195/    2775 : 2A 0C C1            	LD	HL,(LOOPST)	; Get address of loop statement
    1196/    2778 : CD 7C 26            	CALL	CPDEHL		; Compare the FOR loops
    1197/    277B : E1                  	POP	HL		; Restore block address
    1198/    277C : C2 65 27            	JP	NZ,FORSLP	; Different FORs - Find another
    1199/    277F : D1                  	POP	DE		; Restore code string address
    1200/    2780 : F9                  	LD	SP,HL		; Remove all nested loops
    1201/    2781 :                     ;
    1202/    2781 : EB                  FORFND: EX	DE,HL		; Code string address to HL
    1203/    2782 : 0E 08               	LD	C,8
    1204/    2784 : CD 91 23            	CALL	CHKSTK		; Check for 8 levels of stack
    1205/    2787 : E5                  	PUSH	HL		; Save code string address
    1206/    2788 : 2A 0C C1            	LD	HL,(LOOPST)	; Get first statement of loop
    1207/    278B : E3                  	EX	(SP),HL		; Save and restore code string
    1208/    278C : E5                  	PUSH	HL		; Re-save code string address
    1209/    278D : 2A A1 C0            	LD	HL,(LINEAT)	; Get current line number
    1210/    2790 : E3                  	EX	(SP),HL		; Save and restore code string
    1211/    2791 : CD 7A 2C            	CALL	TSTNUM		; Make sure it's a number
    1212/    2794 : CD 82 26            	CALL	CHKSYN		; Make sure "TO" is next
    1213/    2797 : A6                  	DB	ZTO		; "TO" token
    1214/    2798 : CD 77 2C            	CALL	GETNUM		; Get "TO" expression value
    1215/    279B : E5                  	PUSH	HL		; Save code string address
    1216/    279C : CD A5 36            	CALL	BCDEFP		; Move "TO" value to BCDE
    1217/    279F : E1                  	POP	HL		; Restore code string address
    1218/    27A0 : C5                  	PUSH	BC		; Save "TO" value in block
    1219/    27A1 : D5                  	PUSH	DE
    1220/    27A2 : 01 00 81            	LD	BC,8100H	; BCDE - 1 (default STEP)
    1221/    27A5 : 51                  	LD	D,C		; C=0
    1222/    27A6 : 5A                  	LD	E,D		; D=0
    1223/    27A7 : 7E                  	LD	A,(HL)		; Get next byte in code string
    1224/    27A8 : FE AB               	CP	ZSTEP		; See if "STEP" is stated
    1225/    27AA : 3E 01               	LD	A,1		; Sign of step = 1
    1226/    27AC : C2 BD 27            	JP	NZ,SAVSTP	; No STEP given - Default to 1
    1227/    27AF : CD 0A 28            	CALL	GETCHR		; Jump over "STEP" token
    1228/    27B2 : CD 77 2C            	CALL	GETNUM		; Get step value
    1229/    27B5 : E5                  	PUSH	HL		; Save code string address
    1230/    27B6 : CD A5 36            	CALL	BCDEFP		; Move STEP to BCDE
    1231/    27B9 : CD 59 36            	CALL	TSTSGN		; Test sign of FPREG
    1232/    27BC : E1                  	POP	HL		; Restore code string address
    1233/    27BD : C5                  SAVSTP: PUSH	BC		; Save the STEP value in block
    1234/    27BE : D5                  	PUSH	DE
    1235/    27BF : F5                  	PUSH	AF		; Save sign of STEP
    1236/    27C0 : 33                  	INC	SP		; Don't save flags
    1237/    27C1 : E5                  	PUSH	HL		; Save code string address
    1238/    27C2 : 2A 13 C1            	LD	HL,(BRKLIN)	; Get address of index variable
    1239/    27C5 : E3                  	EX	(SP),HL		; Save and restore code string
    1240/    27C6 : 06 81               PUTFID: LD	B,ZFOR		; "FOR" block marker
    1241/    27C8 : C5                  	PUSH	BC		; Save it
    1242/    27C9 : 33                  	INC	SP		; Don't save C
    1243/    27CA :                     ;
    1244/    27CA : CD 35 28            RUNCNT: CALL	TSTBRK		; Execution driver - Test break
    1245/    27CD : 22 13 C1            	LD	(BRKLIN),HL	; Save code address for break
    1246/    27D0 : 7E                  	LD	A,(HL)		; Get next byte in code string
    1247/    27D1 : FE 3A               	CP	':'		; Multi statement line?
    1248/    27D3 : CA EA 27            	JP	Z,EXCUTE	; Yes - Execute it
    1249/    27D6 : B7                  	OR	A		; End of line?
    1250/    27D7 : C2 B4 23            	JP	NZ,SNERR	; No - Syntax error
    1251/    27DA : 23                  	INC	HL		; Point to address of next line
    1252/    27DB : 7E                  	LD	A,(HL)		; Get LSB of line pointer
    1253/    27DC : 23                  	INC	HL
    1254/    27DD : B6                  	OR	(HL)		; Is it zero (End of prog)?
    1255/    27DE : CA 5C 28            	JP	Z,ENDPRG	; Yes - Terminate execution
    1256/    27E1 : 23                  	INC	HL		; Point to line number
    1257/    27E2 : 5E                  	LD	E,(HL)		; Get LSB of line number
    1258/    27E3 : 23                  	INC	HL
    1259/    27E4 : 56                  	LD	D,(HL)		; Get MSB of line number
    1260/    27E5 : EB                  	EX	DE,HL		; Line number to HL
    1261/    27E6 : 22 A1 C0            	LD	(LINEAT),HL	; Save as current line number
    1262/    27E9 : EB                  	EX	DE,HL		; Line number back to DE
    1263/    27EA : CD 0A 28            EXCUTE: CALL	GETCHR		; Get key word
    1264/    27ED : 11 CA 27            	LD	DE,RUNCNT	; Where to RETurn to
    1265/    27F0 : D5                  	PUSH	DE		; Save for RETurn
    1266/    27F1 : C8                  IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
    1267/    27F2 : D6 80               ONJMP:	SUB	ZEND		; Is it a token?
    1268/    27F4 : DA B8 29            	JP	C,LET		; No - try to assign it
    1269/    27F7 : FE 25               	CP	ZNEW+1-ZEND	; END to NEW ?
    1270/    27F9 : D2 B4 23            	JP	NC,SNERR	; Not a key word - ?SN Error
    1271/    27FC : 07                  	RLCA			; Double it
    1272/    27FD : 4F                  	LD	C,A		; BC = Offset into table
    1273/    27FE : 06 00               	LD	B,0
    1274/    2800 : EB                  	EX	DE,HL		; Save code string address
    1275/    2801 : 21 5C 22            	LD	HL,WORDTB	; Keyword address table
    1276/    2804 : 09                  	ADD	HL,BC		; Point to routine address
    1277/    2805 : 4E                  	LD	C,(HL)		; Get LSB of routine address
    1278/    2806 : 23                  	INC	HL
    1279/    2807 : 46                  	LD	B,(HL)		; Get MSB of routine address
    1280/    2808 : C5                  	PUSH	BC		; Save routine address
    1281/    2809 : EB                  	EX	DE,HL		; Restore code string address
    1282/    280A :                     ;
    1283/    280A : 23                  GETCHR: INC	HL		; Point to next character
    1284/    280B : 7E                  	LD	A,(HL)		; Get next code string byte
    1285/    280C : FE 3A               	CP	':'		; Z if ':'
    1286/    280E : D0                  	RET	NC		; NC if > "9"
    1287/    280F : FE 20               	CP	' '
    1288/    2811 : CA 0A 28            	JP	Z,GETCHR	; Skip over spaces
    1289/    2814 : FE 30               	CP	'0'
    1290/    2816 : 3F                  	CCF			; NC if < '0'
    1291/    2817 : 3C                  	INC	A		; Test for zero - Leave carry
    1292/    2818 : 3D                  	DEC	A		; Z if Null
    1293/    2819 : C9                  	RET
    1294/    281A :                     ;
    1295/    281A : EB                  RESTOR: EX	DE,HL		; Save code string address
    1296/    281B : 2A A3 C0            	LD	HL,(BASTXT)	; Point to start of program
    1297/    281E : CA 2F 28            	JP	Z,RESTNL	; Just RESTORE - reset pointer
    1298/    2821 : EB                  	EX	DE,HL		; Restore code string address
    1299/    2822 : CD D6 28            	CALL	ATOH		; Get line number to DE
    1300/    2825 : E5                  	PUSH	HL		; Save code string address
    1301/    2826 : CD A0 24            	CALL	SRCHLN		; Search for line number in DE
    1302/    2829 : 60                  	LD	H,B		; HL = Address of line
    1303/    282A : 69                  	LD	L,C
    1304/    282B : D1                  	POP	DE		; Restore code string address
    1305/    282C : D2 77 29            	JP	NC,ULERR	; ?UL Error if not found
    1306/    282F : 2B                  RESTNL: DEC	HL		; Byte before DATA statement
    1307/    2830 : 22 21 C1            UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
    1308/    2833 : EB                  	EX	DE,HL		; Restore code string address
    1309/    2834 : C9                  	RET
    1310/    2835 :                     ;
    1311/    2835 :                     
    1312/    2835 : DF                  TSTBRK: RST	18H		; Check input status
    1313/    2836 : C8                  	RET	Z		; No key, go back
    1314/    2837 : D7                  	RST	10H		; Get the key into A
    1315/    2838 : FE 1B               	CP	ESC		; Escape key?
    1316/    283A : 28 11               	JR	Z,BRK		; Yes, break
    1317/    283C : FE 03               	CP	CTRLC		; <Ctrl-C>
    1318/    283E : 28 0D               	JR	Z,BRK		; Yes, break
    1319/    2840 : FE 13               	CP	CTRLS		; Stop scrolling?
    1320/    2842 : C0                  	RET	NZ		; Other key, ignore
    1321/    2843 :                     ;
    1322/    2843 :                     
    1323/    2843 : D7                  STALL:	RST	10H		; Wait for key
    1324/    2844 : FE 11               	CP	CTRLQ		; Resume scrolling?
    1325/    2846 : C8                  	RET	Z		; Release the chokehold
    1326/    2847 : FE 03               	CP	CTRLC		; Second break?
    1327/    2849 : 28 07               	JR	Z,STOP		; Break during hold exits prog
    1328/    284B : 18 F6               	JR	STALL		; Loop until <Ctrl-Q> or <brk>
    1329/    284D :                     ;
    1330/    284D : 3E FF               BRK:	LD	A,0FFH		; Set BRKFLG
    1331/    284F : 32 92 C0            	LD	(BRKFLG),A	; Store it
    1332/    2852 :                     ;
    1333/    2852 :                     
    1334/    2852 : C0                  STOP:	RET	NZ		; Exit if anything else
    1335/    2853 : F6                  	DB	0F6H		; Flag "STOP"
    1336/    2854 : C0                  PEND:	RET	NZ		; Exit if anything else
    1337/    2855 : 22 13 C1            	LD	(BRKLIN),HL	; Save point of break
    1338/    2858 : 21                  	DB	21H		; Skip "OR 11111111B"
    1339/    2859 : F6 FF               INPBRK: OR	11111111B	; Flag "Break" wanted
    1340/    285B : C1                  	POP	BC		; Return not needed and more
    1341/    285C : 2A A1 C0            ENDPRG: LD	HL,(LINEAT)	; Get current line number
    1342/    285F : F5                  	PUSH	AF		; Save STOP / END status
    1343/    2860 : 7D                  	LD	A,L		; Is it direct break?
    1344/    2861 : A4                  	AND	H
    1345/    2862 : 3C                  	INC	A		; Line is -1 if direct break
    1346/    2863 : CA 6F 28            	JP	Z,NOLIN		; Yes - No line number
    1347/    2866 : 22 17 C1            	LD	(ERRLIN),HL	; Save line of break
    1348/    2869 : 2A 13 C1            	LD	HL,(BRKLIN)	; Get point of break
    1349/    286C : 22 19 C1            	LD	(CONTAD),HL	; Save point to CONTinue
    1350/    286F : AF                  NOLIN:	XOR	A
    1351/    2870 : 32 8A C0            	LD	(CTLOFG),A	; Enable output
    1352/    2873 : CD A5 2A            	CALL	STTLIN		; Start a new line
    1353/    2876 : F1                  	POP	AF		; Restore STOP / END status
    1354/    2877 : 21 57 23            	LD	HL,BRKMSG	; "Break" message
    1355/    287A : C2 E8 23            	JP	NZ,ERRIN	; "in line" wanted?
    1356/    287D : C3 FF 23            	JP	PRNTOK		; Go to command mode
    1357/    2880 :                     ;
    1358/    2880 : 2A 19 C1            CONT:	LD	HL,(CONTAD)	; Get CONTinue address
    1359/    2883 : 7C                  	LD	A,H		; Is it zero?
    1360/    2884 : B5                  	OR	L
    1361/    2885 : 1E 20               	LD	E,CN		; ?CN Error
    1362/    2887 : CA C8 23            	JP	Z,ERROR_	; Yes - output "?CN Error"
    1363/    288A : EB                  	EX	DE,HL		; Save code string address
    1364/    288B : 2A 17 C1            	LD	HL,(ERRLIN)	; Get line of last break
    1365/    288E : 22 A1 C0            	LD	(LINEAT),HL	; Set up current line number
    1366/    2891 : EB                  	EX	DE,HL		; Restore code string address
    1367/    2892 : C9                  	RET			; CONTinue where left off
    1368/    2893 :                     ;
    1369/    2893 : CD D8 33            NULL:	CALL	GETINT		; Get integer 0-255
    1370/    2896 : C0                  	RET	NZ		; Return if bad value
    1371/    2897 : 32 86 C0            	LD	(NULLS),A	; Set nulls number
    1372/    289A : C9                  	RET
    1373/    289B :                     ;
    1374/    289B :                     
    1375/    289B : E5                  ACCSUM: PUSH	HL		; Save address in array
    1376/    289C : 2A 8F C0            	LD	HL,(CHKSUM)	; Get check sum
    1377/    289F : 06 00               	LD	B,0		; BC - Value of byte
    1378/    28A1 : 4F                  	LD	C,A
    1379/    28A2 : 09                  	ADD	HL,BC		; Add byte to check sum
    1380/    28A3 : 22 8F C0            	LD	(CHKSUM),HL	; Re-save check sum
    1381/    28A6 : E1                  	POP	HL		; Restore address in array
    1382/    28A7 : C9                  	RET
    1383/    28A8 :                     ;
    1384/    28A8 : 7E                  CHKLTR: LD	A,(HL)		; Get byte
    1385/    28A9 : FE 41               	CP	'A'		; < 'a' ?
    1386/    28AB : D8                  	RET	C		; Carry set if not letter
    1387/    28AC : FE 5B               	CP	'Z'+1		; > 'z' ?
    1388/    28AE : 3F                  	CCF
    1389/    28AF : C9                  	RET			; Carry set if not letter
    1390/    28B0 :                     ;
    1391/    28B0 : CD 0A 28            FPSINT: CALL	GETCHR		; Get next character
    1392/    28B3 : CD 77 2C            POSINT: CALL	GETNUM		; Get integer 0 to 32767
    1393/    28B6 : CD 59 36            DEPINT: CALL	TSTSGN		; Test sign of FPREG
    1394/    28B9 : FA D1 28            	JP	M,FCERR		; Negative - ?FC Error
    1395/    28BC : 3A 2C C1            DEINT:	LD	A,(FPEXP)	; Get integer value to DE
    1396/    28BF : FE 90               	CP	80H+16		; Exponent in range (16 bits)?
    1397/    28C1 : DA 01 37            	JP	C,FPINT		; Yes - convert it
    1398/    28C4 : 01 80 90            	LD	BC,9080H	; BCDE = -32768
    1399/    28C7 : 11 00 00            	LD	DE,0000
    1400/    28CA : E5                  	PUSH	HL		; Save code string address
    1401/    28CB : CD D4 36            	CALL	CMPNUM		; Compare FPREG with BCDE
    1402/    28CE : E1                  	POP	HL		; Restore code string address
    1403/    28CF : 51                  	LD	D,C		; MSB to D
    1404/    28D0 : C8                  	RET	Z		; Return if in range
    1405/    28D1 : 1E 08               FCERR:	LD	E,FC		; ?FC Error
    1406/    28D3 : C3 C8 23            	JP	ERROR_		; Output error-
    1407/    28D6 :                     ;
    1408/    28D6 : 2B                  ATOH:	DEC	HL		; ASCII number to DE binary
    1409/    28D7 : 11 00 00            GETLN:	LD	DE,0		; Get number to DE
    1410/    28DA : CD 0A 28            GTLNLP: CALL	GETCHR		; Get next character
    1411/    28DD : D0                  	RET	NC		; Exit if not a digit
    1412/    28DE : E5                  	PUSH	HL		; Save code string address
    1413/    28DF : F5                  	PUSH	AF		; Save digit
    1414/    28E0 : 21 98 19            	LD	HL,65529/10	; Largest number 65529
    1415/    28E3 : CD 7C 26            	CALL	CPDEHL		; Number in range?
    1416/    28E6 : DA B4 23            	JP	C,SNERR		; No - ?SN Error
    1417/    28E9 : 62                  	LD	H,D		; HL = Number
    1418/    28EA : 6B                  	LD	L,E
    1419/    28EB : 19                  	ADD	HL,DE		; Times 2
    1420/    28EC : 29                  	ADD	HL,HL		; Times 4
    1421/    28ED : 19                  	ADD	HL,DE		; Times 5
    1422/    28EE : 29                  	ADD	HL,HL		; Times 10
    1423/    28EF : F1                  	POP	AF		; Restore digit
    1424/    28F0 : D6 30               	SUB	'0'		; Make it 0 to 9
    1425/    28F2 : 5F                  	LD	E,A		; DE = Value of digit
    1426/    28F3 : 16 00               	LD	D,0
    1427/    28F5 : 19                  	ADD	HL,DE		; Add to number
    1428/    28F6 : EB                  	EX	DE,HL		; Number to DE
    1429/    28F7 : E1                  	POP	HL		; Restore code string address
    1430/    28F8 : C3 DA 28            	JP	GTLNLP		; Go to next character
    1431/    28FB :                     ;
    1432/    28FB : CA D0 24            CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
    1433/    28FE : CD B3 28            	CALL	POSINT		; Get integer 0 to 32767 to DE
    1434/    2901 : 2B                  	DEC	HL		; Cancel increment
    1435/    2902 : CD 0A 28            	CALL	GETCHR		; Get next character
    1436/    2905 : E5                  	PUSH	HL		; Save code string address
    1437/    2906 : 2A F4 C0            	LD	HL,(LSTRAM)	; Get end of RAM
    1438/    2909 : CA 1E 29            	JP	Z,STORED	; No value given - Use stored
    1439/    290C : E1                  	POP	HL		; Restore code string address
    1440/    290D : CD 82 26            	CALL	CHKSYN		; Check for comma
    1441/    2910 : 2C                  	DB	','
    1442/    2911 : D5                  	PUSH	DE		; Save number
    1443/    2912 : CD B3 28            	CALL	POSINT		; Get integer 0 to 32767
    1444/    2915 : 2B                  	DEC	HL		; Cancel increment
    1445/    2916 : CD 0A 28            	CALL	GETCHR		; Get next character
    1446/    2919 : C2 B4 23            	JP	NZ,SNERR	; ?SN Error if more on line
    1447/    291C : E3                  	EX	(SP),HL		; Save code string address
    1448/    291D : EB                  	EX	DE,HL		; Number to DE
    1449/    291E : 7D                  STORED: LD	A,L		; Get LSB of new RAM top
    1450/    291F : 93                  	SUB	E		; Subtract LSB of string space
    1451/    2920 : 5F                  	LD	E,A		; Save LSB
    1452/    2921 : 7C                  	LD	A,H		; Get MSB of new RAM top
    1453/    2922 : 9A                  	SBC	A,D		; Subtract MSB of string space
    1454/    2923 : 57                  	LD	D,A		; Save MSB
    1455/    2924 : DA A9 23            	JP	C,OMERR		; ?OM Error if not enough mem
    1456/    2927 : E5                  	PUSH	HL		; Save RAM top
    1457/    2928 : 2A 1B C1            	LD	HL,(PROGND)	; Get program end
    1458/    292B : 01 28 00            	LD	BC,40		; 40 Bytes minimum working RAM
    1459/    292E : 09                  	ADD	HL,BC		; Get lowest address
    1460/    292F : CD 7C 26            	CALL	CPDEHL		; Enough memory?
    1461/    2932 : D2 A9 23            	JP	NC,OMERR	; No - ?OM Error
    1462/    2935 : EB                  	EX	DE,HL		; RAM top to HL
    1463/    2936 : 22 9F C0            	LD	(STRSPC),HL	; Set new string space
    1464/    2939 : E1                  	POP	HL		; End of memory to use
    1465/    293A : 22 F4 C0            	LD	(LSTRAM),HL	; Set new top of RAM
    1466/    293D : E1                  	POP	HL		; Restore code string address
    1467/    293E : C3 D0 24            	JP	INTVAR		; Initialise variables
    1468/    2941 :                     ;
    1469/    2941 : CA CC 24            RUN:	JP	Z,RUNFST	; RUN from start if just RUN
    1470/    2944 : CD D0 24            	CALL	INTVAR		; Initialise variables
    1471/    2947 : 01 CA 27            	LD	BC,RUNCNT	; Execution driver loop
    1472/    294A : C3 5D 29            	JP	RUNLIN		; RUN from line number
    1473/    294D :                     ;
    1474/    294D : 0E 03               GOSUB:	LD	C,3		; 3 Levels of stack needed
    1475/    294F : CD 91 23            	CALL	CHKSTK		; Check for 3 levels of stack
    1476/    2952 : C1                  	POP	BC		; Get return address
    1477/    2953 : E5                  	PUSH	HL		; Save code string for RETURN
    1478/    2954 : E5                  	PUSH	HL		; And for GOSUB routine
    1479/    2955 : 2A A1 C0            	LD	HL,(LINEAT)	; Get current line
    1480/    2958 : E3                  	EX	(SP),HL		; Into stack - Code string out
    1481/    2959 : 3E 8C               	LD	A,ZGOSUB	; "GOSUB" token
    1482/    295B : F5                  	PUSH	AF		; Save token
    1483/    295C : 33                  	INC	SP		; Don't save flags
    1484/    295D :                     ;
    1485/    295D : C5                  RUNLIN: PUSH	BC		; Save return address
    1486/    295E : CD D6 28            GOTO:	CALL	ATOH		; ASCII number to DE binary
    1487/    2961 : CD A3 29            	CALL	REM		; Get end of line
    1488/    2964 : E5                  	PUSH	HL		; Save end of line
    1489/    2965 : 2A A1 C0            	LD	HL,(LINEAT)	; Get current line
    1490/    2968 : CD 7C 26            	CALL	CPDEHL		; Line after current?
    1491/    296B : E1                  	POP	HL		; Restore end of line
    1492/    296C : 23                  	INC	HL		; Start of next line
    1493/    296D : DC A3 24            	CALL	C,SRCHLP	; Line is after current line
    1494/    2970 : D4 A0 24            	CALL	NC,SRCHLN	; Line is before current line
    1495/    2973 : 60                  	LD	H,B		; Set up code string address
    1496/    2974 : 69                  	LD	L,C
    1497/    2975 : 2B                  	DEC	HL		; Incremented after
    1498/    2976 : D8                  	RET	C		; Line found
    1499/    2977 : 1E 0E               ULERR:	LD	E,UL		; ?UL Error
    1500/    2979 : C3 C8 23            	JP	ERROR_		; Output error message
    1501/    297C :                     ;
    1502/    297C : C0                  RETURN: RET	NZ		; Return if not just RETURN
    1503/    297D : 16 FF               	LD	D,-1		; Flag "GOSUB" search
    1504/    297F : CD 5D 23            	CALL	BAKSTK		; Look "GOSUB" block
    1505/    2982 : F9                  	LD	SP,HL		; Kill all FORs in subroutine
    1506/    2983 : FE 8C               	CP	ZGOSUB		; Test for "GOSUB" token
    1507/    2985 : 1E 04               	LD	E,RG		; ?RG Error
    1508/    2987 : C2 C8 23            	JP	NZ,ERROR_	; Error if no "GOSUB" found
    1509/    298A : E1                  	POP	HL		; Get RETURN line number
    1510/    298B : 22 A1 C0            	LD	(LINEAT),HL	; Save as current
    1511/    298E : 23                  	INC	HL		; Was it from direct statement?
    1512/    298F : 7C                  	LD	A,H
    1513/    2990 : B5                  	OR	L		; Return to line
    1514/    2991 : C2 9B 29            	JP	NZ,RETLIN	; No - Return to line
    1515/    2994 : 3A 11 C1            	LD	A,(LSTBIN)	; Any INPUT in subroutine?
    1516/    2997 : B7                  	OR	A		; If so buffer is corrupted
    1517/    2998 : C2 FE 23            	JP	NZ,POPNOK	; Yes - Go to command mode
    1518/    299B : 21 CA 27            RETLIN: LD	HL,RUNCNT	; Execution driver loop
    1519/    299E : E3                  	EX	(SP),HL		; Into stack - Code string out
    1520/    299F : 3E                  	DB	3EH		; Skip "POP HL"
    1521/    29A0 : E1                  NXTDTA: POP	HL		; Restore code string address
    1522/    29A1 :                     ;
    1523/    29A1 : 01 3A               DATA:	DB	01H,3AH		; ':' End of statement
    1524/    29A3 : 0E 00               REM:	LD	C,0		; 00	End of statement
    1525/    29A5 : 06 00               	LD	B,0
    1526/    29A7 : 79                  NXTSTL: LD	A,C		; Statement and byte
    1527/    29A8 : 48                  	LD	C,B
    1528/    29A9 : 47                  	LD	B,A		; Statement end byte
    1529/    29AA : 7E                  NXTSTT: LD	A,(HL)		; Get byte
    1530/    29AB : B7                  	OR	A		; End of line?
    1531/    29AC : C8                  	RET	Z		; Yes - Exit
    1532/    29AD : B8                  	CP	B		; End of statement?
    1533/    29AE : C8                  	RET	Z		; Yes - Exit
    1534/    29AF : 23                  	INC	HL		; Next byte
    1535/    29B0 : FE 22               	CP	'"'		; Literal string?
    1536/    29B2 : CA A7 29            	JP	Z,NXTSTL	; Yes - Look for another '"'
    1537/    29B5 : C3 AA 29            	JP	NXTSTT		; Keep looking
    1538/    29B8 :                     ;
    1539/    29B8 : CD 6D 2E            LET:	CALL	GETVAR		; Get variable name
    1540/    29BB : CD 82 26            	CALL	CHKSYN		; Make sure "=" follows
    1541/    29BE : B4                  	DB	ZEQUAL		; "=" token
    1542/    29BF : D5                  	PUSH	DE		; Save address of variable
    1543/    29C0 : 3A F2 C0            	LD	A,(TYPE)	; Get data type
    1544/    29C3 : F5                  	PUSH	AF		; Save type
    1545/    29C4 : CD 89 2C            	CALL	EVAL		; Evaluate expression
    1546/    29C7 : F1                  	POP	AF		; Restore type
    1547/    29C8 : E3                  	EX	(SP),HL		; Save code - Get var addr
    1548/    29C9 : 22 13 C1            	LD	(BRKLIN),HL	; Save address of variable
    1549/    29CC : 1F                  	RRA			; Adjust type
    1550/    29CD : CD 7C 2C            	CALL	CHKTYP		; Check types are the same
    1551/    29D0 : CA 0B 2A            	JP	Z,LETNUM	; Numeric - Move value
    1552/    29D3 : E5                  LETSTR: PUSH	HL		; Save address of string var
    1553/    29D4 : 2A 29 C1            	LD	HL,(FPREG)	; Pointer to string entry
    1554/    29D7 : E5                  	PUSH	HL		; Save it on stack
    1555/    29D8 : 23                  	INC	HL		; Skip over length
    1556/    29D9 : 23                  	INC	HL
    1557/    29DA : 5E                  	LD	E,(HL)		; LSB of string address
    1558/    29DB : 23                  	INC	HL
    1559/    29DC : 56                  	LD	D,(HL)		; MSB of string address
    1560/    29DD : 2A A3 C0            	LD	HL,(BASTXT)	; Point to start of program
    1561/    29E0 : CD 7C 26            	CALL	CPDEHL		; Is string before program?
    1562/    29E3 : D2 FA 29            	JP	NC,CRESTR	; Yes - Create string entry
    1563/    29E6 : 2A 9F C0            	LD	HL,(STRSPC)	; Point to string space
    1564/    29E9 : CD 7C 26            	CALL	CPDEHL		; Is string literal in program?
    1565/    29EC : D1                  	POP	DE		; Restore address of string
    1566/    29ED : D2 02 2A            	JP	NC,MVSTPT	; Yes - Set up pointer
    1567/    29F0 : 21 04 C1            	LD	HL,TMPSTR	; Temporary string pool
    1568/    29F3 : CD 7C 26            	CALL	CPDEHL		; Is string in temporary pool?
    1569/    29F6 : D2 02 2A            	JP	NC,MVSTPT	; No - Set up pointer
    1570/    29F9 : 3E                  	DB	3EH		; Skip "POP DE"
    1571/    29FA : D1                  CRESTR: POP	DE		; Restore address of string
    1572/    29FB : CD B1 32            	CALL	BAKTMP		; Back to last tmp-str entry
    1573/    29FE : EB                  	EX	DE,HL		; Address of string entry
    1574/    29FF : CD EA 30            	CALL	SAVSTR		; Save string in string area
    1575/    2A02 : CD B1 32            MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
    1576/    2A05 : E1                  	POP	HL		; Get string pointer
    1577/    2A06 : CD B4 36            	CALL	DETHL4		; Move string pointer to var
    1578/    2A09 : E1                  	POP	HL		; Restore code string address
    1579/    2A0A : C9                  	RET
    1580/    2A0B :                     ;
    1581/    2A0B : E5                  LETNUM: PUSH	HL		; Save address of variable
    1582/    2A0C : CD B1 36            	CALL	FPTHL		; Move value to variable
    1583/    2A0F : D1                  	POP	DE		; Restore address of variable
    1584/    2A10 : E1                  	POP	HL		; Restore code string address
    1585/    2A11 : C9                  	RET
    1586/    2A12 :                     ;
    1587/    2A12 : CD D8 33            ON:	CALL	GETINT		; Get integer 0-255
    1588/    2A15 : 7E                  	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
    1589/    2A16 : 47                  	LD	B,A		; Save in B
    1590/    2A17 : FE 8C               	CP	ZGOSUB		; "GOSUB" token?
    1591/    2A19 : CA 21 2A            	JP	Z,ONGO		; Yes - Find line number
    1592/    2A1C : CD 82 26            	CALL	CHKSYN		; Make sure it's "GOTO"
    1593/    2A1F : 88                  	DB	ZGOTO		; "GOTO" token
    1594/    2A20 : 2B                  	DEC	HL		; Cancel increment
    1595/    2A21 : 4B                  ONGO:	LD	C,E		; Integer of branch value
    1596/    2A22 : 0D                  ONGOLP: DEC	C		; Count branches
    1597/    2A23 : 78                  	LD	A,B		; Get "GOTO" or "GOSUB" token
    1598/    2A24 : CA F2 27            	JP	Z,ONJMP		; Go to that line if right one
    1599/    2A27 : CD D7 28            	CALL	GETLN		; Get line number to DE
    1600/    2A2A : FE 2C               	CP	','		; Another line number?
    1601/    2A2C : C0                  	RET	NZ		; No - Drop through
    1602/    2A2D : C3 22 2A            	JP	ONGOLP		; Yes - loop
    1603/    2A30 :                     ;
    1604/    2A30 : CD 89 2C            IF_:	CALL	EVAL		; Evaluate expression
    1605/    2A33 : 7E                  	LD	A,(HL)		; Get token
    1606/    2A34 : FE 88               	CP	ZGOTO		; "GOTO" token?
    1607/    2A36 : CA 3E 2A            	JP	Z,IFGO		; Yes - Get line
    1608/    2A39 : CD 82 26            	CALL	CHKSYN		; Make sure it's "THEN"
    1609/    2A3C : A9                  	DB	ZTHEN		; "THEN" token
    1610/    2A3D : 2B                  	DEC	HL		; Cancel increment
    1611/    2A3E : CD 7A 2C            IFGO:	CALL	TSTNUM		; Make sure it's numeric
    1612/    2A41 : CD 59 36            	CALL	TSTSGN		; Test state of expression
    1613/    2A44 : CA A3 29            	JP	Z,REM		; False - Drop through
    1614/    2A47 : CD 0A 28            	CALL	GETCHR		; Get next character
    1615/    2A4A : DA 5E 29            	JP	C,GOTO		; Number - GOTO that line
    1616/    2A4D : C3 F1 27            	JP	IFJMP		; Otherwise do statement
    1617/    2A50 :                     ;
    1618/    2A50 : 2B                  MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
    1619/    2A51 : CD 0A 28            	CALL	GETCHR		; Get next character
    1620/    2A54 : CA B2 2A            PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
    1621/    2A57 : C8                  PRNTLP: RET	Z		; End of list - Exit
    1622/    2A58 : FE A5               	CP	ZTAB		; "TAB(" token?
    1623/    2A5A : CA E5 2A            	JP	Z,DOTAB		; Yes - Do TAB routine
    1624/    2A5D : FE A8               	CP	ZSPC		; "SPC(" token?
    1625/    2A5F : CA E5 2A            	JP	Z,DOTAB		; Yes - Do SPC routine
    1626/    2A62 : E5                  	PUSH	HL		; Save code string address
    1627/    2A63 : FE 2C               	CP	','		; Comma?
    1628/    2A65 : CA CE 2A            	JP	Z,DOCOM		; Yes - Move to next zone
    1629/    2A68 : FE 3B               	CP	59;";"		; Semi-colon?
    1630/    2A6A : CA 08 2B            	JP	Z,NEXITM	; Do semi-colon routine
    1631/    2A6D : C1                  	POP	BC		; Code string address to BC
    1632/    2A6E : CD 89 2C            	CALL	EVAL		; Evaluate expression
    1633/    2A71 : E5                  	PUSH	HL		; Save code string address
    1634/    2A72 : 3A F2 C0            	LD	A,(TYPE)	; Get variable type
    1635/    2A75 : B7                  	OR	A		; Is it a string variable?
    1636/    2A76 : C2 9E 2A            	JP	NZ,PRNTST	; Yes - Output string contents
    1637/    2A79 : CD FE 37            	CALL	NUMASC		; Convert number to text
    1638/    2A7C : CD 0E 31            	CALL	CRTST		; Create temporary string
    1639/    2A7F : 36 20               	LD	(HL),' '	; Followed by a space
    1640/    2A81 : 2A 29 C1            	LD	HL,(FPREG)	; Get length of output
    1641/    2A84 : 34                  	INC	(HL)		; Plus 1 for the space
    1642/    2A85 : 2A 29 C1            	LD	HL,(FPREG)	; < Not needed >
    1643/    2A88 : 3A 87 C0            	LD	A,(LWIDTH)	; Get width of line
    1644/    2A8B : 47                  	LD	B,A		; To B
    1645/    2A8C : 04                  	INC	B		; Width 255 (No limit)?
    1646/    2A8D : CA 9A 2A            	JP	Z,PRNTNB	; Yes - Output number string
    1647/    2A90 : 04                  	INC	B		; Adjust it
    1648/    2A91 : 3A F0 C0            	LD	A,(CURPOS)	; Get cursor position
    1649/    2A94 : 86                  	ADD	A,(HL)		; Add length of string
    1650/    2A95 : 3D                  	DEC	A		; Adjust it
    1651/    2A96 : B8                  	CP	B		; Will output fit on this line?
    1652/    2A97 : D4 B2 2A            	CALL	NC,PRCRLF	; No - CRLF first
    1653/    2A9A : CD 53 31            PRNTNB: CALL	PRS1		; Output string at (HL)
    1654/    2A9D : AF                  	XOR	A		; Skip CALL by setting 'z' flag
    1655/    2A9E : C4 53 31            PRNTST: CALL	NZ,PRS1		; Output string at (HL)
    1656/    2AA1 : E1                  	POP	HL		; Restore code string address
    1657/    2AA2 : C3 50 2A            	JP	MRPRNT		; See if more to PRINT
    1658/    2AA5 :                     ;
    1659/    2AA5 : 3A F0 C0            STTLIN: LD	A,(CURPOS)	; Make sure on new line
    1660/    2AA8 : B7                  	OR	A		; Already at start?
    1661/    2AA9 : C8                  	RET	Z		; Yes - Do nothing
    1662/    2AAA : C3 B2 2A            	JP	PRCRLF		; Start a new line
    1663/    2AAD :                     ;
    1664/    2AAD : 36 00               ENDINP: LD	(HL),0		; Mark end of buffer
    1665/    2AAF : 21 A5 C0            	LD	HL,BUFFER-1	; Point to buffer
    1666/    2AB2 : 3E 0D               PRCRLF: LD	A,CR		; Load a CR
    1667/    2AB4 : CD 8D 26            	CALL	OUTC		; Output character
    1668/    2AB7 : 3E 0A               	LD	A,LF		; Load a LF
    1669/    2AB9 : CD 8D 26            	CALL	OUTC		; Output character
    1670/    2ABC : AF                  DONULL: XOR	A		; Set to position 0
    1671/    2ABD : 32 F0 C0            	LD	(CURPOS),A	; Store it
    1672/    2AC0 : 3A 86 C0            	LD	A,(NULLS)	; Get number of nulls
    1673/    2AC3 : 3D                  NULLP:	DEC	A		; Count them
    1674/    2AC4 : C8                  	RET	Z		; Return if done
    1675/    2AC5 : F5                  	PUSH	AF		; Save count
    1676/    2AC6 : AF                  	XOR	A		; Load a null
    1677/    2AC7 : CD 8D 26            	CALL	OUTC		; Output it
    1678/    2ACA : F1                  	POP	AF		; Restore count
    1679/    2ACB : C3 C3 2A            	JP	NULLP		; Keep counting
    1680/    2ACE :                     ;
    1681/    2ACE : 3A 88 C0            DOCOM:	LD	A,(COMMAN)	; Get comma width
    1682/    2AD1 : 47                  	LD	B,A		; Save in B
    1683/    2AD2 : 3A F0 C0            	LD	A,(CURPOS)	; Get current position
    1684/    2AD5 : B8                  	CP	B		; Within the limit?
    1685/    2AD6 : D4 B2 2A            	CALL	NC,PRCRLF	; No - output CRLF
    1686/    2AD9 : D2 08 2B            	JP	NC,NEXITM	; Get next item
    1687/    2ADC : D6 0E               ZONELP: SUB	14		; Next zone of 14 characters
    1688/    2ADE : D2 DC 2A            	JP	NC,ZONELP	; Repeat if more zones
    1689/    2AE1 : 2F                  	CPL			; Number of spaces to output
    1690/    2AE2 : C3 FD 2A            	JP	ASPCS		; Output them
    1691/    2AE5 :                     ;
    1692/    2AE5 : F5                  DOTAB:	PUSH	AF		; Save token
    1693/    2AE6 : CD D5 33            	CALL	FNDNUM		; Evaluate expression
    1694/    2AE9 : CD 82 26            	CALL	CHKSYN		; Make sure ")" follows
    1695/    2AEC : 29                  	DB	")"
    1696/    2AED : 2B                  	DEC	HL		; Back space on to ")"
    1697/    2AEE : F1                  	POP	AF		; Restore token
    1698/    2AEF : D6 A8               	SUB	ZSPC		; Was it "SPC(" ?
    1699/    2AF1 : E5                  	PUSH	HL		; Save code string address
    1700/    2AF2 : CA F8 2A            	JP	Z,DOSPC	; Yes - Do 'E' spaces
    1701/    2AF5 : 3A F0 C0            	LD	A,(CURPOS)	; Get current position
    1702/    2AF8 : 2F                  DOSPC:	CPL			; Number of spaces to print to
    1703/    2AF9 : 83                  	ADD	A,E		; Total number to print
    1704/    2AFA : D2 08 2B            	JP	NC,NEXITM	; TAB < Current POS(X)
    1705/    2AFD : 3C                  ASPCS:	INC	A		; Output A spaces
    1706/    2AFE : 47                  	LD	B,A		; Save number to print
    1707/    2AFF : 3E 20               	LD	A,' '		; Space
    1708/    2B01 : CD 8D 26            SPCLP:	CALL	OUTC		; Output character in A
    1709/    2B04 : 05                  	DEC	B		; Count them
    1710/    2B05 : C2 01 2B            	JP	NZ,SPCLP	; Repeat if more
    1711/    2B08 : E1                  NEXITM: POP	HL		; Restore code string address
    1712/    2B09 : CD 0A 28            	CALL	GETCHR		; Get next character
    1713/    2B0C : C3 57 2A            	JP	PRNTLP		; More to print
    1714/    2B0F :                     ;
    1715/    2B0F : 3F 52 65 64 6F 20   REDO:	DB	"?Redo from start",CR,LF,0
             2B15 : 66 72 6F 6D 20 73 
             2B1B : 74 61 72 74 0D 0A 
             2B21 : 00                
    1716/    2B22 :                     ;
    1717/    2B22 : 3A 12 C1            BADINP: LD	A,(READFG)	; READ or INPUT?
    1718/    2B25 : B7                  	OR	A
    1719/    2B26 : C2 AE 23            	JP	NZ,DATSNR	; READ - ?SN Error
    1720/    2B29 : C1                  	POP	BC		; Throw away code string addr
    1721/    2B2A : 21 0F 2B            	LD	HL,REDO		; "Redo from start" message
    1722/    2B2D : CD 50 31            	CALL	PRS		; Output string
    1723/    2B30 : C3 FF 24            	JP	DOAGN		; Do last INPUT again
    1724/    2B33 :                     ;
    1725/    2B33 : CD BB 30            INPUT:	CALL	IDTEST		; Test for illegal direct
    1726/    2B36 : 7E                  	LD	A,(HL)		; Get character after "INPUT"
    1727/    2B37 : FE 22               	CP	'"'		; Is there a prompt string?
    1728/    2B39 : 3E 00               	LD	A,0		; Clear A and leave flags
    1729/    2B3B : 32 8A C0            	LD	(CTLOFG),A	; Enable output
    1730/    2B3E : C2 4D 2B            	JP	NZ,NOPMPT	; No prompt - get input
    1731/    2B41 : CD 0F 31            	CALL	QTSTR		; Get string terminated by '"'
    1732/    2B44 : CD 82 26            	CALL	CHKSYN		; Check for ';' after prompt
    1733/    2B47 : 3B                  	DB	';'
    1734/    2B48 : E5                  	PUSH	HL		; Save code string address
    1735/    2B49 : CD 53 31            	CALL	PRS1		; Output prompt string
    1736/    2B4C : 3E                  	DB	3EH		; Skip "PUSH HL"
    1737/    2B4D : E5                  NOPMPT: PUSH	HL		; Save code string address
    1738/    2B4E : CD 03 25            	CALL	PROMPT		; Get input with "? " prompt
    1739/    2B51 : C1                  	POP	BC		; Restore code string address
    1740/    2B52 : DA 59 28            	JP	C,INPBRK	; Break pressed - Exit
    1741/    2B55 : 23                  	INC	HL		; Next byte
    1742/    2B56 : 7E                  	LD	A,(HL)		; Get it
    1743/    2B57 : B7                  	OR	A		; End of line?
    1744/    2B58 : 2B                  	DEC	HL		; Back again
    1745/    2B59 : C5                  	PUSH	BC		; Re-save code string address
    1746/    2B5A : CA A0 29            	JP	Z,NXTDTA	; Yes - Find next DATA stmt
    1747/    2B5D : 36 2C               	LD	(HL),','	; Store comma as separator
    1748/    2B5F : C3 67 2B            	JP	NXTITM		; Get next item
    1749/    2B62 :                     ;
    1750/    2B62 : E5                  READ:	PUSH	HL		; Save code string address
    1751/    2B63 : 2A 21 C1            	LD	HL,(NXTDAT)	; Next DATA statement
    1752/    2B66 : F6                  	DB	0F6H		; Flag "READ"
    1753/    2B67 : AF                  NXTITM: XOR	A		; Flag "INPUT"
    1754/    2B68 : 32 12 C1            	LD	(READFG),A	; Save "READ"/"INPUT" flag
    1755/    2B6B : E3                  	EX	(SP),HL		; Get code str' , Save pointer
    1756/    2B6C : C3 73 2B            	JP	GTVLUS		; Get values
    1757/    2B6F :                     ;
    1758/    2B6F : CD 82 26            NEDMOR: CALL	CHKSYN		; Check for comma between items
    1759/    2B72 : 2C                  	DB	','
    1760/    2B73 : CD 6D 2E            GTVLUS: CALL	GETVAR		; Get variable name
    1761/    2B76 : E3                  	EX	(SP),HL		; Save code str" , Get pointer
    1762/    2B77 : D5                  	PUSH	DE		; Save variable address
    1763/    2B78 : 7E                  	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
    1764/    2B79 : FE 2C               	CP	','		; Comma?
    1765/    2B7B : CA 9B 2B            	JP	Z,ANTVLU	; Yes - Get another value
    1766/    2B7E : 3A 12 C1            	LD	A,(READFG)	; Is it READ?
    1767/    2B81 : B7                  	OR	A
    1768/    2B82 : C2 08 2C            	JP	NZ,FDTLP	; Yes - Find next DATA stmt
    1769/    2B85 : 3E 3F               	LD	A,'?'		; More INPUT needed
    1770/    2B87 : CD 8D 26            	CALL	OUTC		; Output character
    1771/    2B8A : CD 03 25            	CALL	PROMPT		; Get INPUT with prompt
    1772/    2B8D : D1                  	POP	DE		; Variable address
    1773/    2B8E : C1                  	POP	BC		; Code string address
    1774/    2B8F : DA 59 28            	JP	C,INPBRK	; Break pressed
    1775/    2B92 : 23                  	INC	HL		; Point to next DATA byte
    1776/    2B93 : 7E                  	LD	A,(HL)		; Get byte
    1777/    2B94 : B7                  	OR	A		; Is it zero (No input) ?
    1778/    2B95 : 2B                  	DEC	HL		; Back space INPUT pointer
    1779/    2B96 : C5                  	PUSH	BC		; Save code string address
    1780/    2B97 : CA A0 29            	JP	Z,NXTDTA	; Find end of buffer
    1781/    2B9A : D5                  	PUSH	DE		; Save variable address
    1782/    2B9B : 3A F2 C0            ANTVLU: LD	A,(TYPE)	; Check data type
    1783/    2B9E : B7                  	OR	A		; Is it numeric?
    1784/    2B9F : CA C5 2B            	JP	Z,INPBIN	; Yes - Convert to binary
    1785/    2BA2 : CD 0A 28            	CALL	GETCHR		; Get next character
    1786/    2BA5 : 57                  	LD	D,A		; Save input character
    1787/    2BA6 : 47                  	LD	B,A		; Again
    1788/    2BA7 : FE 22               	CP	'"'		; Start of literal sting?
    1789/    2BA9 : CA B9 2B            	JP	Z,STRENT	; Yes - Create string entry
    1790/    2BAC : 3A 12 C1            	LD	A,(READFG)	; "READ" or "INPUT" ?
    1791/    2BAF : B7                  	OR	A
    1792/    2BB0 : 57                  	LD	D,A		; Save 00 if "INPUT"
    1793/    2BB1 : CA B6 2B            	JP	Z,ITMSEP	; "INPUT" - End with 00
    1794/    2BB4 : 16 3A               	LD	D,':'		; "DATA" - End with 00 or ':'
    1795/    2BB6 : 06 2C               ITMSEP: LD	B,','		; Item separator
    1796/    2BB8 : 2B                  	DEC	HL		; Back space for DTSTR
    1797/    2BB9 : CD 12 31            STRENT: CALL	DTSTR		; Get string terminated by D
    1798/    2BBC : EB                  	EX	DE,HL		; String address to DE
    1799/    2BBD : 21 D0 2B            	LD	HL,LTSTND	; Where to go after LETSTR
    1800/    2BC0 : E3                  	EX	(SP),HL		; Save HL , get input pointer
    1801/    2BC1 : D5                  	PUSH	DE		; Save address of string
    1802/    2BC2 : C3 D3 29            	JP	LETSTR		; Assign string to variable
    1803/    2BC5 :                     ;
    1804/    2BC5 : CD 0A 28            INPBIN: CALL	GETCHR		; Get next character
    1805/    2BC8 : CD 60 37            	CALL	ASCTFP		; Convert ASCII to FP number
    1806/    2BCB : E3                  	EX	(SP),HL		; Save input ptr, Get var addr
    1807/    2BCC : CD B1 36            	CALL	FPTHL		; Move FPREG to variable
    1808/    2BCF : E1                  	POP	HL		; Restore input pointer
    1809/    2BD0 : 2B                  LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
    1810/    2BD1 : CD 0A 28            	CALL	GETCHR		; Get next character
    1811/    2BD4 : CA DC 2B            	JP	Z,MORDT		; End of line - More needed?
    1812/    2BD7 : FE 2C               	CP	','		; Another value?
    1813/    2BD9 : C2 22 2B            	JP	NZ,BADINP	; No - Bad input
    1814/    2BDC : E3                  MORDT:	EX	(SP),HL		; Get code string address
    1815/    2BDD : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    1816/    2BDE : CD 0A 28            	CALL	GETCHR		; Get next character
    1817/    2BE1 : C2 6F 2B            	JP	NZ,NEDMOR	; More needed - Get it
    1818/    2BE4 : D1                  	POP	DE		; Restore DATA pointer
    1819/    2BE5 : 3A 12 C1            	LD	A,(READFG)	; "READ" or "INPUT" ?
    1820/    2BE8 : B7                  	OR	A
    1821/    2BE9 : EB                  	EX	DE,HL		; DATA pointer to HL
    1822/    2BEA : C2 30 28            	JP	NZ,UPDATA	; Update DATA pointer if "READ"
    1823/    2BED : D5                  	PUSH	DE		; Save code string address
    1824/    2BEE : B6                  	OR	(HL)		; More input given?
    1825/    2BEF : 21 F7 2B            	LD	HL,EXTIG	; "?Extra ignored" message
    1826/    2BF2 : C4 50 31            	CALL	NZ,PRS		; Output string if extra given
    1827/    2BF5 : E1                  	POP	HL		; Restore code string address
    1828/    2BF6 : C9                  	RET
    1829/    2BF7 :                     ;
    1830/    2BF7 : 3F 45 78 74 72 61   EXTIG:	DB	"?Extra ignored",CR,LF,0
             2BFD : 20 69 67 6E 6F 72 
             2C03 : 65 64 0D 0A 00    
    1831/    2C08 :                     ;
    1832/    2C08 : CD A1 29            FDTLP:	CALL	DATA		; Get next statement
    1833/    2C0B : B7                  	OR	A		; End of line?
    1834/    2C0C : C2 21 2C            	JP	NZ,FANDT	; No - See if DATA statement
    1835/    2C0F : 23                  	INC	HL
    1836/    2C10 : 7E                  	LD	A,(HL)		; End of program?
    1837/    2C11 : 23                  	INC	HL
    1838/    2C12 : B6                  	OR	(HL)		; 00 00 Ends program
    1839/    2C13 : 1E 06               	LD	E,OD		; ?OD Error
    1840/    2C15 : CA C8 23            	JP	Z,ERROR_	; Yes - Out of DATA
    1841/    2C18 : 23                  	INC	HL
    1842/    2C19 : 5E                  	LD	E,(HL)		; LSB of line number
    1843/    2C1A : 23                  	INC	HL
    1844/    2C1B : 56                  	LD	D,(HL)		; MSB of line number
    1845/    2C1C : EB                  	EX	DE,HL
    1846/    2C1D : 22 0E C1            	LD	(DATLIN),HL	; Set line of current DATA item
    1847/    2C20 : EB                  	EX	DE,HL
    1848/    2C21 : CD 0A 28            FANDT:	CALL	GETCHR		; Get next character
    1849/    2C24 : FE 83               	CP	ZDATA		; "DATA" token
    1850/    2C26 : C2 08 2C            	JP	NZ,FDTLP	; No "DATA" - Keep looking
    1851/    2C29 : C3 9B 2B            	JP	ANTVLU		; Found - Convert input
    1852/    2C2C :                     ;
    1853/    2C2C : 11 00 00            NEXT:	LD	DE,0		; In case no index given
    1854/    2C2F : C4 6D 2E            NEXT1:	CALL	NZ,GETVAR	; Get index address
    1855/    2C32 : 22 13 C1            	LD	(BRKLIN),HL	; Save code string address
    1856/    2C35 : CD 5D 23            	CALL	BAKSTK		; Look for "FOR" block
    1857/    2C38 : C2 BA 23            	JP	NZ,NFERR	; No "FOR" - ?NF Error
    1858/    2C3B : F9                  	LD	SP,HL		; Clear nested loops
    1859/    2C3C : D5                  	PUSH	DE		; Save index address
    1860/    2C3D : 7E                  	LD	A,(HL)		; Get sign of STEP
    1861/    2C3E : 23                  	INC	HL
    1862/    2C3F : F5                  	PUSH	AF		; Save sign of STEP
    1863/    2C40 : D5                  	PUSH	DE		; Save index address
    1864/    2C41 : CD 97 36            	CALL	PHLTFP		; Move index value to FPREG
    1865/    2C44 : E3                  	EX	(SP),HL		; Save address of TO value
    1866/    2C45 : E5                  	PUSH	HL		; Save address of index
    1867/    2C46 : CD 04 34            	CALL	ADDPHL		; Add STEP to index value
    1868/    2C49 : E1                  	POP	HL		; Restore address of index
    1869/    2C4A : CD B1 36            	CALL	FPTHL		; Move value to index variable
    1870/    2C4D : E1                  	POP	HL		; Restore address of TO value
    1871/    2C4E : CD A8 36            	CALL	LOADFP		; Move TO value to BCDE
    1872/    2C51 : E5                  	PUSH	HL		; Save address of line of FOR
    1873/    2C52 : CD D4 36            	CALL	CMPNUM		; Compare index with TO value
    1874/    2C55 : E1                  	POP	HL		; Restore address of line num
    1875/    2C56 : C1                  	POP	BC		; Address of sign of STEP
    1876/    2C57 : 90                  	SUB	B		; Compare with expected sign
    1877/    2C58 : CD A8 36            	CALL	LOADFP		; BC = Loop stmt,DE = Line num
    1878/    2C5B : CA 67 2C            	JP	Z,KILFOR	; Loop finished - Terminate it
    1879/    2C5E : EB                  	EX	DE,HL		; Loop statement line number
    1880/    2C5F : 22 A1 C0            	LD	(LINEAT),HL	; Set loop line number
    1881/    2C62 : 69                  	LD	L,C		; Set code string to loop
    1882/    2C63 : 60                  	LD	H,B
    1883/    2C64 : C3 C6 27            	JP	PUTFID		; Put back "FOR" and continue
    1884/    2C67 :                     ;
    1885/    2C67 : F9                  KILFOR: LD	SP,HL		; Remove "FOR" block
    1886/    2C68 : 2A 13 C1            	LD	HL,(BRKLIN)	; Code string after "NEXT"
    1887/    2C6B : 7E                  	LD	A,(HL)		; Get next byte in code string
    1888/    2C6C : FE 2C               	CP	','		; More NEXTs ?
    1889/    2C6E : C2 CA 27            	JP	NZ,RUNCNT	; No - Do next statement
    1890/    2C71 : CD 0A 28            	CALL	GETCHR		; Position to index name
    1891/    2C74 : CD 2F 2C            	CALL	NEXT1		; Re-enter NEXT routine
    1892/    2C77 :                     ; < will not RETurn to here , Exit to RUNCNT or Loop >
    1893/    2C77 :                     ;
    1894/    2C77 : CD 89 2C            GETNUM: CALL	EVAL		; Get a numeric expression
    1895/    2C7A : F6                  TSTNUM: DB	0F6H		; Clear carry (numeric)
    1896/    2C7B : 37                  TSTSTR: SCF			; Set carry (string)
    1897/    2C7C : 3A F2 C0            CHKTYP: LD	A,(TYPE)	; Check types match
    1898/    2C7F : 8F                  	ADC	A,A		; Expected + actual
    1899/    2C80 : B7                  	OR	A		; Clear carry , set parity
    1900/    2C81 : E8                  	RET	PE		; Even parity - Types match
    1901/    2C82 : C3 C6 23            	JP	TMERR		; Different types - Error
    1902/    2C85 :                     ;
    1903/    2C85 : CD 82 26            OPNPAR: CALL	CHKSYN		; Make sure "(" follows
    1904/    2C88 : 28                  	DB	"("
    1905/    2C89 : 2B                  EVAL:	DEC	HL		; Evaluate expression & save
    1906/    2C8A : 16 00               	LD	D,0		; Precedence value
    1907/    2C8C : D5                  EVAL1:	PUSH	DE		; Save precedence
    1908/    2C8D : 0E 01               	LD	C,1
    1909/    2C8F : CD 91 23            	CALL	CHKSTK		; Check for 1 level of stack
    1910/    2C92 : CD 00 2D            	CALL	OPRND		; Get next expression value
    1911/    2C95 : 22 15 C1            EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
    1912/    2C98 : 2A 15 C1            EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
    1913/    2C9B : C1                  	POP	BC		; Precedence value and operator
    1914/    2C9C : 78                  	LD	A,B		; Get precedence value
    1915/    2C9D : FE 78               	CP	78H		; "AND" or "OR" ?
    1916/    2C9F : D4 7A 2C            	CALL	NC,TSTNUM	; No - Make sure it's a number
    1917/    2CA2 : 7E                  	LD	A,(HL)		; Get next operator / function
    1918/    2CA3 : 16 00               	LD	D,0		; Clear Last relation
    1919/    2CA5 : D6 B3               RLTLP:	SUB	ZGTR		; ">" Token
    1920/    2CA7 : DA C1 2C            	JP	C,FOPRND	; + - * / ^ AND OR - Test it
    1921/    2CAA : FE 03               	CP	ZLTH+1-ZGTR	; < = >
    1922/    2CAC : D2 C1 2C            	JP	NC,FOPRND	; Function - Call it
    1923/    2CAF : FE 01               	CP	ZEQUAL-ZGTR	; "="
    1924/    2CB1 : 17                  	RLA			; <- Test for legal
    1925/    2CB2 : AA                  	XOR	D		; <- combinations of < = >
    1926/    2CB3 : BA                  	CP	D		; <- by combining last token
    1927/    2CB4 : 57                  	LD	D,A		; <- with current one
    1928/    2CB5 : DA B4 23            	JP	C,SNERR		; Error if "<<' '==" or ">>"
    1929/    2CB8 : 22 0A C1            	LD	(CUROPR),HL	; Save address of current token
    1930/    2CBB : CD 0A 28            	CALL	GETCHR		; Get next character
    1931/    2CBE : C3 A5 2C            	JP	RLTLP		; Treat the two as one
    1932/    2CC1 :                     ;
    1933/    2CC1 : 7A                  FOPRND: LD	A,D		; < = > found ?
    1934/    2CC2 : B7                  	OR	A
    1935/    2CC3 : C2 E8 2D            	JP	NZ,TSTRED	; Yes - Test for reduction
    1936/    2CC6 : 7E                  	LD	A,(HL)		; Get operator token
    1937/    2CC7 : 22 0A C1            	LD	(CUROPR),HL	; Save operator address
    1938/    2CCA : D6 AC               	SUB	ZPLUS		; Operator or function?
    1939/    2CCC : D8                  	RET	C		; Neither - Exit
    1940/    2CCD : FE 07               	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
    1941/    2CCF : D0                  	RET	NC		; No - Exit
    1942/    2CD0 : 5F                  	LD	E,A		; Coded operator
    1943/    2CD1 : 3A F2 C0            	LD	A,(TYPE)	; Get data type
    1944/    2CD4 : 3D                  	DEC	A		; FF = numeric , 00 = string
    1945/    2CD5 : B3                  	OR	E		; Combine with coded operator
    1946/    2CD6 : 7B                  	LD	A,E		; Get coded operator
    1947/    2CD7 : CA 46 32            	JP	Z,CONCAT	; String concatenation
    1948/    2CDA : 07                  	RLCA			; Times 2
    1949/    2CDB : 83                  	ADD	A,E		; Times 3
    1950/    2CDC : 5F                  	LD	E,A		; To DE (D is 0)
    1951/    2CDD : 21 A6 22            	LD	HL,PRITAB	; Precedence table
    1952/    2CE0 : 19                  	ADD	HL,DE		; To the operator concerned
    1953/    2CE1 : 78                  	LD	A,B		; Last operator precedence
    1954/    2CE2 : 56                  	LD	D,(HL)		; Get evaluation precedence
    1955/    2CE3 : BA                  	CP	D		; Compare with eval precedence
    1956/    2CE4 : D0                  	RET	NC		; Exit if higher precedence
    1957/    2CE5 : 23                  	INC	HL		; Point to routine address
    1958/    2CE6 : CD 7A 2C            	CALL	TSTNUM		; Make sure it's a number
    1959/    2CE9 :                     ;
    1960/    2CE9 : C5                  STKTHS: PUSH	BC		; Save last precedence & token
    1961/    2CEA : 01 98 2C            	LD	BC,EVAL3	; Where to go on prec' break
    1962/    2CED : C5                  	PUSH	BC		; Save on stack for return
    1963/    2CEE : 43                  	LD	B,E		; Save operator
    1964/    2CEF : 4A                  	LD	C,D		; Save precedence
    1965/    2CF0 : CD 8A 36            	CALL	STAKFP		; Move value to stack
    1966/    2CF3 : 58                  	LD	E,B		; Restore operator
    1967/    2CF4 : 51                  	LD	D,C		; Restore precedence
    1968/    2CF5 : 4E                  	LD	C,(HL)		; Get LSB of routine address
    1969/    2CF6 : 23                  	INC	HL
    1970/    2CF7 : 46                  	LD	B,(HL)		; Get MSB of routine address
    1971/    2CF8 : 23                  	INC	HL
    1972/    2CF9 : C5                  	PUSH	BC		; Save routine address
    1973/    2CFA : 2A 0A C1            	LD	HL,(CUROPR)	; Address of current operator
    1974/    2CFD : C3 8C 2C            	JP	EVAL1		; Loop until prec' break
    1975/    2D00 :                     ;
    1976/    2D00 : AF                  OPRND:	XOR	A		; Get operand routine
    1977/    2D01 : 32 F2 C0            	LD	(TYPE),A	; Set numeric expected
    1978/    2D04 : CD 0A 28            	CALL	GETCHR		; Get next character
    1979/    2D07 : 1E 24               	LD	E,MO		; ?MO Error
    1980/    2D09 : CA C8 23            	JP	Z,ERROR_	; No operand - Error
    1981/    2D0C : DA 60 37            	JP	C,ASCTFP	; Number - Get value
    1982/    2D0F : CD A8 28            	CALL	CHKLTR		; See if a letter
    1983/    2D12 : D2 67 2D            	JP	NC,CONVAR	; Letter - Find variable
    1984/    2D15 : FE 26               	CP	'&'		; &H = HEX, &B = BINARY
    1985/    2D17 : 20 12               	JR	NZ, NOTAMP
    1986/    2D19 : CD 0A 28            	CALL	GETCHR		; Get next character
    1987/    2D1C : FE 48               	CP	'H'		; Hex number indicated? [function added]
    1988/    2D1E : CA A3 3B            	JP	Z,HEXTFP	; Convert Hex to FPREG
    1989/    2D21 : FE 42               	CP	'B'		; Binary number indicated? [function added]
    1990/    2D23 : CA 13 3C            	JP	Z,BINTFP	; Convert Bin to FPREG
    1991/    2D26 : 1E 02               	LD	E,SN		; If neither then a ?SN Error
    1992/    2D28 : CA C8 23            	JP	Z,ERROR_
    1993/    2D2B : FE AC               NOTAMP: CP	ZPLUS		; '+' Token ?
    1994/    2D2D : CA 00 2D            	JP	Z,OPRND		; Yes - Look for operand
    1995/    2D30 : FE 2E               	CP	'.'		; '.' ?
    1996/    2D32 : CA 60 37            	JP	Z,ASCTFP	; Yes - Create FP number
    1997/    2D35 : FE AD               	CP	ZMINUS		; '-' Token ?
    1998/    2D37 : CA 56 2D            	JP	Z,MINUS		; Yes - Do minus
    1999/    2D3A : FE 22               	CP	'"'		; Literal string ?
    2000/    2D3C : CA 0F 31            	JP	Z,QTSTR		; Get string terminated by '"'
    2001/    2D3F : FE AA               	CP	ZNOT		; "NOT" Token ?
    2002/    2D41 : CA 48 2E            	JP	Z,EVNOT		; Yes - Eval NOT expression
    2003/    2D44 : FE A7               	CP	ZFN		; "FN" Token ?
    2004/    2D46 : CA 73 30            	JP	Z,DOFN		; Yes - Do FN routine
    2005/    2D49 : D6 B6               	SUB	ZSGN		; Is it a function?
    2006/    2D4B : D2 78 2D            	JP	NC,FNOFST	; Yes - Evaluate function
    2007/    2D4E : CD 85 2C            EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
    2008/    2D51 : CD 82 26            	CALL	CHKSYN		; Make sure ")" follows
    2009/    2D54 : 29                  	DB	")"
    2010/    2D55 : C9                  	RET
    2011/    2D56 :                     ;
    2012/    2D56 : 16 7D               MINUS:	LD	D,7DH		; '-' precedence
    2013/    2D58 : CD 8C 2C            	CALL	EVAL1		; Evaluate until prec' break
    2014/    2D5B : 2A 15 C1            	LD	HL,(NXTOPR)	; Get next operator address
    2015/    2D5E : E5                  	PUSH	HL		; Save next operator address
    2016/    2D5F : CD 82 36            	CALL	INVSGN		; Negate value
    2017/    2D62 : CD 7A 2C            RETNUM: CALL	TSTNUM		; Make sure it's a number
    2018/    2D65 : E1                  	POP	HL		; Restore next operator address
    2019/    2D66 : C9                  	RET
    2020/    2D67 :                     ;
    2021/    2D67 : CD 6D 2E            CONVAR: CALL	GETVAR		; Get variable address to DE
    2022/    2D6A : E5                  FRMEVL: PUSH	HL		; Save code string address
    2023/    2D6B : EB                  	EX	DE,HL		; Variable address to HL
    2024/    2D6C : 22 29 C1            	LD	(FPREG),HL	; Save address of variable
    2025/    2D6F : 3A F2 C0            	LD	A,(TYPE)	; Get type
    2026/    2D72 : B7                  	OR	A		; Numeric?
    2027/    2D73 : CC 97 36            	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
    2028/    2D76 : E1                  	POP	HL		; Restore code string address
    2029/    2D77 : C9                  	RET
    2030/    2D78 :                     ;
    2031/    2D78 : 06 00               FNOFST: LD	B,0		; Get address of function
    2032/    2D7A : 07                  	RLCA			; Double function offset
    2033/    2D7B : 4F                  	LD	C,A		; BC = Offset in function table
    2034/    2D7C : C5                  	PUSH	BC		; Save adjusted token value
    2035/    2D7D : CD 0A 28            	CALL	GETCHR		; Get next character
    2036/    2D80 : 79                  	LD	A,C		; Get adjusted token value
    2037/    2D81 : FE 31               	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
    2038/    2D83 : DA 9F 2D            	JP	C,FNVAL		; No - Do function
    2039/    2D86 : CD 85 2C            	CALL	OPNPAR		; Evaluate expression	(X,...
    2040/    2D89 : CD 82 26            	CALL	CHKSYN		; Make sure ',' follows
    2041/    2D8C : 2C                  	DB	','
    2042/    2D8D : CD 7B 2C            	CALL	TSTSTR		; Make sure it's a string
    2043/    2D90 : EB                  	EX	DE,HL		; Save code string address
    2044/    2D91 : 2A 29 C1            	LD	HL,(FPREG)	; Get address of string
    2045/    2D94 : E3                  	EX	(SP),HL		; Save address of string
    2046/    2D95 : E5                  	PUSH	HL		; Save adjusted token value
    2047/    2D96 : EB                  	EX	DE,HL		; Restore code string address
    2048/    2D97 : CD D8 33            	CALL	GETINT		; Get integer 0-255
    2049/    2D9A : EB                  	EX	DE,HL		; Save code string address
    2050/    2D9B : E3                  	EX	(SP),HL		; Save integer,HL = adj' token
    2051/    2D9C : C3 A7 2D            	JP	GOFUNC		; Jump to string function
    2052/    2D9F :                     ;
    2053/    2D9F : CD 4E 2D            FNVAL:	CALL	EVLPAR		; Evaluate expression
    2054/    2DA2 : E3                  	EX	(SP),HL		; HL = Adjusted token value
    2055/    2DA3 : 11 62 2D            	LD	DE,RETNUM	; Return number from function
    2056/    2DA6 : D5                  	PUSH	DE		; Save on stack
    2057/    2DA7 : 01 05 21            GOFUNC: LD	BC,FNCTAB	; Function routine addresses
    2058/    2DAA : 09                  	ADD	HL,BC		; Point to right address
    2059/    2DAB : 4E                  	LD	C,(HL)		; Get LSB of address
    2060/    2DAC : 23                  	INC	HL		;
    2061/    2DAD : 66                  	LD	H,(HL)		; Get MSB of address
    2062/    2DAE : 69                  	LD	L,C		; Address to HL
    2063/    2DAF : E9                  	JP	(HL)		; Jump to function
    2064/    2DB0 :                     ;
    2065/    2DB0 : 15                  SGNEXP: DEC	D		; Dee to flag negative exponent
    2066/    2DB1 : FE AD               	CP	ZMINUS		; '-' token ?
    2067/    2DB3 : C8                  	RET	Z		; Yes - Return
    2068/    2DB4 : FE 2D               	CP	'-'		; '-' ASCII ?
    2069/    2DB6 : C8                  	RET	Z		; Yes - Return
    2070/    2DB7 : 14                  	INC	D		; Inc to flag positive exponent
    2071/    2DB8 : FE 2B               	CP	'+'		; '+' ASCII ?
    2072/    2DBA : C8                  	RET	Z		; Yes - Return
    2073/    2DBB : FE AC               	CP	ZPLUS		; '+' token ?
    2074/    2DBD : C8                  	RET	Z		; Yes - Return
    2075/    2DBE : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2076/    2DBF : C9                  	RET			; Return "NZ"
    2077/    2DC0 :                     ;
    2078/    2DC0 : F6                  POR:	DB	0F6H		; Flag "OR"
    2079/    2DC1 : AF                  PAND:	XOR	A		; Flag "AND"
    2080/    2DC2 : F5                  	PUSH	AF		; Save "AND" / "OR" flag
    2081/    2DC3 : CD 7A 2C            	CALL	TSTNUM		; Make sure it's a number
    2082/    2DC6 : CD BC 28            	CALL	DEINT		; Get integer -32768 to 32767
    2083/    2DC9 : F1                  	POP	AF		; Restore "AND" / "OR" flag
    2084/    2DCA : EB                  	EX	DE,HL		; <- Get last
    2085/    2DCB : C1                  	POP	BC		; <- value
    2086/    2DCC : E3                  	EX	(SP),HL		; <- from
    2087/    2DCD : EB                  	EX	DE,HL		; <- stack
    2088/    2DCE : CD 9A 36            	CALL	FPBCDE		; Move last value to FPREG
    2089/    2DD1 : F5                  	PUSH	AF		; Save "AND" / "OR" flag
    2090/    2DD2 : CD BC 28            	CALL	DEINT		; Get integer -32768 to 32767
    2091/    2DD5 : F1                  	POP	AF		; Restore "AND" / "OR" flag
    2092/    2DD6 : C1                  	POP	BC		; Get value
    2093/    2DD7 : 79                  	LD	A,C		; Get LSB
    2094/    2DD8 : 21 31 30            	LD	HL,ACPASS	; Address of save AC as current
    2095/    2DDB : C2 E3 2D            	JP	NZ,POR1		; Jump if OR
    2096/    2DDE : A3                  	AND	E		; "AND" LSBs
    2097/    2DDF : 4F                  	LD	C,A		; Save LSB
    2098/    2DE0 : 78                  	LD	A,B		; Get MBS
    2099/    2DE1 : A2                  	AND	D		; "AND" MSBs
    2100/    2DE2 : E9                  	JP	(HL)		; Save AC as current (ACPASS)
    2101/    2DE3 :                     ;
    2102/    2DE3 : B3                  POR1:	OR	E		; "OR" LSBs
    2103/    2DE4 : 4F                  	LD	C,A		; Save LSB
    2104/    2DE5 : 78                  	LD	A,B		; Get MSB
    2105/    2DE6 : B2                  	OR	D		; "OR" MSBs
    2106/    2DE7 : E9                  	JP	(HL)		; Save AC as current (ACPASS)
    2107/    2DE8 :                     ;
    2108/    2DE8 : 21 FA 2D            TSTRED: LD	HL,CMPLOG	; Logical compare routine
    2109/    2DEB : 3A F2 C0            	LD	A,(TYPE)	; Get data type
    2110/    2DEE : 1F                  	RRA			; Carry set = string
    2111/    2DEF : 7A                  	LD	A,D		; Get last precedence value
    2112/    2DF0 : 17                  	RLA			; Times 2 plus carry
    2113/    2DF1 : 5F                  	LD	E,A		; To E
    2114/    2DF2 : 16 64               	LD	D,64H		; Relational precedence
    2115/    2DF4 : 78                  	LD	A,B		; Get current precedence
    2116/    2DF5 : BA                  	CP	D		; Compare with last
    2117/    2DF6 : D0                  	RET	NC		; Eval if last was rel' or log'
    2118/    2DF7 : C3 E9 2C            	JP	STKTHS		; Stack this one and get next
    2119/    2DFA :                     ;
    2120/    2DFA : FC 2D               CMPLOG: DW	CMPLG1		; Compare two values / strings
    2121/    2DFC : 79                  CMPLG1: LD	A,C		; Get data type
    2122/    2DFD : B7                  	OR	A
    2123/    2DFE : 1F                  	RRA
    2124/    2DFF : C1                  	POP	BC		; Get last expression to BCDE
    2125/    2E00 : D1                  	POP	DE
    2126/    2E01 : F5                  	PUSH	AF		; Save status
    2127/    2E02 : CD 7C 2C            	CALL	CHKTYP		; Check that types match
    2128/    2E05 : 21 3E 2E            	LD	HL,CMPRES	; Result to comparison
    2129/    2E08 : E5                  	PUSH	HL		; Save for RETurn
    2130/    2E09 : CA D4 36            	JP	Z,CMPNUM	; Compare values if numeric
    2131/    2E0C : AF                  	XOR	A		; Compare two strings
    2132/    2E0D : 32 F2 C0            	LD	(TYPE),A	; Set type to numeric
    2133/    2E10 : D5                  	PUSH	DE		; Save string name
    2134/    2E11 : CD 93 32            	CALL	GSTRCU		; Get current string
    2135/    2E14 : 7E                  	LD	A,(HL)		; Get length of string
    2136/    2E15 : 23                  	INC	HL
    2137/    2E16 : 23                  	INC	HL
    2138/    2E17 : 4E                  	LD	C,(HL)		; Get LSB of address
    2139/    2E18 : 23                  	INC	HL
    2140/    2E19 : 46                  	LD	B,(HL)		; Get MSB of address
    2141/    2E1A : D1                  	POP	DE		; Restore string name
    2142/    2E1B : C5                  	PUSH	BC		; Save address of string
    2143/    2E1C : F5                  	PUSH	AF		; Save length of string
    2144/    2E1D : CD 97 32            	CALL	GSTRDE		; Get second string
    2145/    2E20 : CD A8 36            	CALL	LOADFP		; Get address of second string
    2146/    2E23 : F1                  	POP	AF		; Restore length of string 1
    2147/    2E24 : 57                  	LD	D,A		; Length to D
    2148/    2E25 : E1                  	POP	HL		; Restore address of string 1
    2149/    2E26 : 7B                  CMPSTR: LD	A,E		; Bytes of string 2 to do
    2150/    2E27 : B2                  	OR	D		; Bytes of string 1 to do
    2151/    2E28 : C8                  	RET	Z		; Exit if all bytes compared
    2152/    2E29 : 7A                  	LD	A,D		; Get bytes of string 1 to do
    2153/    2E2A : D6 01               	SUB	1
    2154/    2E2C : D8                  	RET	C		; Exit if end of string 1
    2155/    2E2D : AF                  	XOR	A
    2156/    2E2E : BB                  	CP	E		; Bytes of string 2 to do
    2157/    2E2F : 3C                  	INC	A
    2158/    2E30 : D0                  	RET	NC		; Exit if end of string 2
    2159/    2E31 : 15                  	DEC	D		; Count bytes in string 1
    2160/    2E32 : 1D                  	DEC	E		; Count bytes in string 2
    2161/    2E33 : 0A                  	LD	A,(BC)		; Byte in string 2
    2162/    2E34 : BE                  	CP	(HL)		; Compare to byte in string 1
    2163/    2E35 : 23                  	INC	HL		; Move up string 1
    2164/    2E36 : 03                  	INC	BC		; Move up string 2
    2165/    2E37 : CA 26 2E            	JP	Z,CMPSTR	; Same - Try next bytes
    2166/    2E3A : 3F                  	CCF			; Flag difference (">" or "<")
    2167/    2E3B : C3 64 36            	JP	FLGDIF		; "<" gives -1 , ">" gives +1
    2168/    2E3E :                     ;
    2169/    2E3E : 3C                  CMPRES: INC	A		; Increment current value
    2170/    2E3F : 8F                  	ADC	A,A		; Double plus carry
    2171/    2E40 : C1                  	POP	BC		; Get other value
    2172/    2E41 : A0                  	AND	B		; Combine them
    2173/    2E42 : C6 FF               	ADD	A,-1		; Carry set if different
    2174/    2E44 : 9F                  	SBC	A,A		; 00 - Equal , FF - Different
    2175/    2E45 : C3 6B 36            	JP	FLGREL		; Set current value & continue
    2176/    2E48 :                     ;
    2177/    2E48 : 16 5A               EVNOT:	LD	D,5AH		; Precedence value for "NOT"
    2178/    2E4A : CD 8C 2C            	CALL	EVAL1		; Eval until precedence break
    2179/    2E4D : CD 7A 2C            	CALL	TSTNUM		; Make sure it's a number
    2180/    2E50 : CD BC 28            	CALL	DEINT		; Get integer -32768 - 32767
    2181/    2E53 : 7B                  	LD	A,E		; Get LSB
    2182/    2E54 : 2F                  	CPL			; Invert LSB
    2183/    2E55 : 4F                  	LD	C,A		; Save "NOT" of LSB
    2184/    2E56 : 7A                  	LD	A,D		; Get MSB
    2185/    2E57 : 2F                  	CPL			; Invert MSB
    2186/    2E58 : CD 31 30            	CALL	ACPASS		; Save AC as current
    2187/    2E5B : C1                  	POP	BC		; Clean up stack
    2188/    2E5C : C3 98 2C            	JP	EVAL3		; Continue evaluation
    2189/    2E5F :                     ;
    2190/    2E5F : 2B                  DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
    2191/    2E60 : CD 0A 28            	CALL	GETCHR		; Get next character
    2192/    2E63 : C8                  	RET	Z		; End of DIM statement
    2193/    2E64 : CD 82 26            	CALL	CHKSYN		; Make sure ',' follows
    2194/    2E67 : 2C                  	DB	','
    2195/    2E68 : 01 5F 2E            DIM:	LD	BC,DIMRET	; Return to "DIMRET"
    2196/    2E6B : C5                  	PUSH	BC		; Save on stack
    2197/    2E6C : F6                  	DB	0F6H		; Flag "Create" variable
    2198/    2E6D : AF                  GETVAR: XOR	A		; Find variable address,to DE
    2199/    2E6E : 32 F1 C0            	LD	(LCRFLG),A	; Set locate / create flag
    2200/    2E71 : 46                  	LD	B,(HL)		; Get First byte of name
    2201/    2E72 : CD A8 28            GTFNAM: CALL	CHKLTR		; See if a letter
    2202/    2E75 : DA B4 23            	JP	C,SNERR		; ?SN Error if not a letter
    2203/    2E78 : AF                  	XOR	A
    2204/    2E79 : 4F                  	LD	C,A		; Clear second byte of name
    2205/    2E7A : 32 F2 C0            	LD	(TYPE),A	; Set type to numeric
    2206/    2E7D : CD 0A 28            	CALL	GETCHR		; Get next character
    2207/    2E80 : DA 89 2E            	JP	C,SVNAM2	; Numeric - Save in name
    2208/    2E83 : CD A8 28            	CALL	CHKLTR		; See if a letter
    2209/    2E86 : DA 96 2E            	JP	C,CHARTY	; Not a letter - Check type
    2210/    2E89 : 4F                  SVNAM2: LD	C,A		; Save second byte of name
    2211/    2E8A : CD 0A 28            ENDNAM: CALL	GETCHR		; Get next character
    2212/    2E8D : DA 8A 2E            	JP	C,ENDNAM	; Numeric - Get another
    2213/    2E90 : CD A8 28            	CALL	CHKLTR		; See if a letter
    2214/    2E93 : D2 8A 2E            	JP	NC,ENDNAM	; Letter - Get another
    2215/    2E96 : D6 24               CHARTY: SUB	'$'		; String variable?
    2216/    2E98 : C2 A5 2E            	JP	NZ,NOTSTR	; No - Numeric variable
    2217/    2E9B : 3C                  	INC	A		; A = 1 (string type)
    2218/    2E9C : 32 F2 C0            	LD	(TYPE),A	; Set type to string
    2219/    2E9F : 0F                  	RRCA			; A = 80H , Flag for string
    2220/    2EA0 : 81                  	ADD	A,C		; 2nd byte of name has bit 7 on
    2221/    2EA1 : 4F                  	LD	C,A		; Resave second byte on name
    2222/    2EA2 : CD 0A 28            	CALL	GETCHR		; Get next character
    2223/    2EA5 : 3A 10 C1            NOTSTR: LD	A,(FORFLG)	; Array name needed ?
    2224/    2EA8 : 3D                  	DEC	A
    2225/    2EA9 : CA 52 2F            	JP	Z,ARLDSV	; Yes - Get array name
    2226/    2EAC : F2 B5 2E            	JP	P,NSCFOR	; No array with "FOR" or "FN"
    2227/    2EAF : 7E                  	LD	A,(HL)		; Get byte again
    2228/    2EB0 : D6 28               	SUB	'('		; Subscripted variable?
    2229/    2EB2 : CA 2A 2F            	JP	Z,SBSCPT	; Yes - Sort out subscript
    2230/    2EB5 :                     ;
    2231/    2EB5 : AF                  NSCFOR: XOR	A		; Simple variable
    2232/    2EB6 : 32 10 C1            	LD	(FORFLG),A	; Clear "FOR" flag
    2233/    2EB9 : E5                  	PUSH	HL		; Save code string address
    2234/    2EBA : 50                  	LD	D,B		; DE = Variable name to find
    2235/    2EBB : 59                  	LD	E,C
    2236/    2EBC : 2A 23 C1            	LD	HL,(FNRGNM)	; FN argument name
    2237/    2EBF : CD 7C 26            	CALL	CPDEHL		; Is it the FN argument?
    2238/    2EC2 : 11 25 C1            	LD	DE,FNARG	; Point to argument value
    2239/    2EC5 : CA 9A 35            	JP	Z,POPHRT	; Yes - Return FN argument value
    2240/    2EC8 : 2A 1D C1            	LD	HL,(VAREND)	; End of variables
    2241/    2ECB : EB                  	EX	DE,HL		; Address of end of search
    2242/    2ECC : 2A 1B C1            	LD	HL,(PROGND)	; Start of variables address
    2243/    2ECF : CD 7C 26            FNDVAR: CALL	CPDEHL		; End of variable list table?
    2244/    2ED2 : CA E8 2E            	JP	Z,CFEVAL	; Yes - Called from EVAL?
    2245/    2ED5 : 79                  	LD	A,C		; Get second byte of name
    2246/    2ED6 : 96                  	SUB	(HL)		; Compare with name in list
    2247/    2ED7 : 23                  	INC	HL		; Move on to first byte
    2248/    2ED8 : C2 DD 2E            	JP	NZ,FNTHR	; Different - Find another
    2249/    2EDB : 78                  	LD	A,B		; Get first byte of name
    2250/    2EDC : 96                  	SUB	(HL)		; Compare with name in list
    2251/    2EDD : 23                  FNTHR:	INC	HL		; Move on to LSB of value
    2252/    2EDE : CA 1C 2F            	JP	Z,RETADR	; Found - Return address
    2253/    2EE1 : 23                  	INC	HL		; <- Skip
    2254/    2EE2 : 23                  	INC	HL		; <- over
    2255/    2EE3 : 23                  	INC	HL		; <- F.P.
    2256/    2EE4 : 23                  	INC	HL		; <- value
    2257/    2EE5 : C3 CF 2E            	JP	FNDVAR		; Keep looking
    2258/    2EE8 :                     ;
    2259/    2EE8 : E1                  CFEVAL: POP	HL		; Restore code string address
    2260/    2EE9 : E3                  	EX	(SP),HL		; Get return address
    2261/    2EEA : D5                  	PUSH	DE		; Save address of variable
    2262/    2EEB : 11 6A 2D            	LD	DE,FRMEVL	; Return address in EVAL
    2263/    2EEE : CD 7C 26            	CALL	CPDEHL		; Called from EVAL ?
    2264/    2EF1 : D1                  	POP	DE		; Restore address of variable
    2265/    2EF2 : CA 1F 2F            	JP	Z,RETNUL	; Yes - Return null variable
    2266/    2EF5 : E3                  	EX	(SP),HL		; Put back return
    2267/    2EF6 : E5                  	PUSH	HL		; Save code string address
    2268/    2EF7 : C5                  	PUSH	BC		; Save variable name
    2269/    2EF8 : 01 06 00            	LD	BC,6		; 2 byte name plus 4 byte data
    2270/    2EFB : 2A 1F C1            	LD	HL,(ARREND)	; End of arrays
    2271/    2EFE : E5                  	PUSH	HL		; Save end of arrays
    2272/    2EFF : 09                  	ADD	HL,BC		; Move up 6 bytes
    2273/    2F00 : C1                  	POP	BC		; Source address in BC
    2274/    2F01 : E5                  	PUSH	HL		; Save new end address
    2275/    2F02 : CD 80 23            	CALL	MOVUP		; Move arrays up
    2276/    2F05 : E1                  	POP	HL		; Restore new end address
    2277/    2F06 : 22 1F C1            	LD	(ARREND),HL	; Set new end address
    2278/    2F09 : 60                  	LD	H,B		; End of variables to HL
    2279/    2F0A : 69                  	LD	L,C
    2280/    2F0B : 22 1D C1            	LD	(VAREND),HL	; Set new end address
    2281/    2F0E :                     ;
    2282/    2F0E : 2B                  ZEROLP: DEC	HL		; Back through to zero variable
    2283/    2F0F : 36 00               	LD	(HL),0		; Zero byte in variable
    2284/    2F11 : CD 7C 26            	CALL	CPDEHL		; Done them all?
    2285/    2F14 : C2 0E 2F            	JP	NZ,ZEROLP	; No - Keep on going
    2286/    2F17 : D1                  	POP	DE		; Get variable name
    2287/    2F18 : 73                  	LD	(HL),E		; Store second character
    2288/    2F19 : 23                  	INC	HL
    2289/    2F1A : 72                  	LD	(HL),D		; Store first character
    2290/    2F1B : 23                  	INC	HL
    2291/    2F1C : EB                  RETADR: EX	DE,HL		; Address of variable in DE
    2292/    2F1D : E1                  	POP	HL		; Restore code string address
    2293/    2F1E : C9                  	RET
    2294/    2F1F :                     ;
    2295/    2F1F : 32 2C C1            RETNUL: LD	(FPEXP),A	; Set result to zero
    2296/    2F22 : 21 50 23            	LD	HL,ZERBYT	; Also set a null string
    2297/    2F25 : 22 29 C1            	LD	(FPREG),HL	; Save for EVAL
    2298/    2F28 : E1                  	POP	HL		; Restore code string address
    2299/    2F29 : C9                  	RET
    2300/    2F2A :                     ;
    2301/    2F2A : E5                  SBSCPT: PUSH	HL		; Save code string address
    2302/    2F2B : 2A F1 C0            	LD	HL,(LCRFLG)	; Locate/Create and Type
    2303/    2F2E : E3                  	EX	(SP),HL		; Save and get code string
    2304/    2F2F : 57                  	LD	D,A		; Zero number of dimensions
    2305/    2F30 : D5                  SCPTLP: PUSH	DE		; Save number of dimensions
    2306/    2F31 : C5                  	PUSH	BC		; Save array name
    2307/    2F32 : CD B0 28            	CALL	FPSINT		; Get subscript (0-32767)
    2308/    2F35 : C1                  	POP	BC		; Restore array name
    2309/    2F36 : F1                  	POP	AF		; Get number of dimensions
    2310/    2F37 : EB                  	EX	DE,HL
    2311/    2F38 : E3                  	EX	(SP),HL		; Save subscript value
    2312/    2F39 : E5                  	PUSH	HL		; Save LCRFLG and TYPE
    2313/    2F3A : EB                  	EX	DE,HL
    2314/    2F3B : 3C                  	INC	A		; Count dimensions
    2315/    2F3C : 57                  	LD	D,A		; Save in D
    2316/    2F3D : 7E                  	LD	A,(HL)		; Get next byte in code string
    2317/    2F3E : FE 2C               	CP	','		; Comma (more to come)?
    2318/    2F40 : CA 30 2F            	JP	Z,SCPTLP	; Yes - More subscripts
    2319/    2F43 : CD 82 26            	CALL	CHKSYN		; Make sure ")" follows
    2320/    2F46 : 29                  	DB	")"
    2321/    2F47 : 22 15 C1            	LD	(NXTOPR),HL	; Save code string address
    2322/    2F4A : E1                  	POP	HL		; Get LCRFLG and TYPE
    2323/    2F4B : 22 F1 C0            	LD	(LCRFLG),HL	; Restore Locate/create & type
    2324/    2F4E : 1E 00               	LD	E,0		; Flag not CSAVE* or CLOAD*
    2325/    2F50 : D5                  	PUSH	DE		; Save number of dimensions (D)
    2326/    2F51 : 11                  	DB	11H		; Skip "PUSH HL" and "PUSH AF'
    2327/    2F52 :                     ;
    2328/    2F52 : E5                  ARLDSV: PUSH	HL		; Save code string address
    2329/    2F53 : F5                  	PUSH	AF		; A = 00 , Flags set = Z,N
    2330/    2F54 : 2A 1D C1            	LD	HL,(VAREND)	; Start of arrays
    2331/    2F57 : 3E                  	DB	3EH		; Skip "ADD HL,DE"
    2332/    2F58 : 19                  FNDARY: ADD	HL,DE		; Move to next array start
    2333/    2F59 : EB                  	EX	DE,HL
    2334/    2F5A : 2A 1F C1            	LD	HL,(ARREND)	; End of arrays
    2335/    2F5D : EB                  	EX	DE,HL		; Current array pointer
    2336/    2F5E : CD 7C 26            	CALL	CPDEHL		; End of arrays found?
    2337/    2F61 : CA 8A 2F            	JP	Z,CREARY	; Yes - Create array
    2338/    2F64 : 7E                  	LD	A,(HL)		; Get second byte of name
    2339/    2F65 : B9                  	CP	C		; Compare with name given
    2340/    2F66 : 23                  	INC	HL		; Move on
    2341/    2F67 : C2 6C 2F            	JP	NZ,NXTARY	; Different - Find next array
    2342/    2F6A : 7E                  	LD	A,(HL)		; Get first byte of name
    2343/    2F6B : B8                  	CP	B		; Compare with name given
    2344/    2F6C : 23                  NXTARY: INC	HL		; Move on
    2345/    2F6D : 5E                  	LD	E,(HL)		; Get LSB of next array address
    2346/    2F6E : 23                  	INC	HL
    2347/    2F6F : 56                  	LD	D,(HL)		; Get MSB of next array address
    2348/    2F70 : 23                  	INC	HL
    2349/    2F71 : C2 58 2F            	JP	NZ,FNDARY	; Not found - Keep looking
    2350/    2F74 : 3A F1 C0            	LD	A,(LCRFLG)	; Found Locate or Create it?
    2351/    2F77 : B7                  	OR	A
    2352/    2F78 : C2 BD 23            	JP	NZ,DDERR	; Create - ?DD Error
    2353/    2F7B : F1                  	POP	AF		; Locate - Get number of dim'ns
    2354/    2F7C : 44                  	LD	B,H		; BC Points to array dim'ns
    2355/    2F7D : 4D                  	LD	C,L
    2356/    2F7E : CA 9A 35            	JP	Z,POPHRT	; Jump if array load/save
    2357/    2F81 : 96                  	SUB	(HL)		; Same number of dimensions?
    2358/    2F82 : CA E8 2F            	JP	Z,FINDEL	; Yes - Find element
    2359/    2F85 : 1E 10               BSERR:	LD	E,BS		; ?BS Error
    2360/    2F87 : C3 C8 23            	JP	ERROR_		; Output error
    2361/    2F8A :                     ;
    2362/    2F8A : 11 04 00            CREARY: LD	DE,4		; 4 Bytes per entry
    2363/    2F8D : F1                  	POP	AF		; Array to save or 0 dim'ns?
    2364/    2F8E : CA D1 28            	JP	Z,FCERR		; Yes - ?FC Error
    2365/    2F91 : 71                  	LD	(HL),C		; Save second byte of name
    2366/    2F92 : 23                  	INC	HL
    2367/    2F93 : 70                  	LD	(HL),B		; Save first byte of name
    2368/    2F94 : 23                  	INC	HL
    2369/    2F95 : 4F                  	LD	C,A		; Number of dimensions to C
    2370/    2F96 : CD 91 23            	CALL	CHKSTK		; Check if enough memory
    2371/    2F99 : 23                  	INC	HL		; Point to number of dimensions
    2372/    2F9A : 23                  	INC	HL
    2373/    2F9B : 22 0A C1            	LD	(CUROPR),HL	; Save address of pointer
    2374/    2F9E : 71                  	LD	(HL),C		; Set number of dimensions
    2375/    2F9F : 23                  	INC	HL
    2376/    2FA0 : 3A F1 C0            	LD	A,(LCRFLG)	; Locate of Create?
    2377/    2FA3 : 17                  	RLA			; Carry set = Create
    2378/    2FA4 : 79                  	LD	A,C		; Get number of dimensions
    2379/    2FA5 : 01 0B 00            CRARLP: LD	BC,10+1		; Default dimension size 10
    2380/    2FA8 : D2 AD 2F            	JP	NC,DEFSIZ	; Locate - Set default size
    2381/    2FAB : C1                  	POP	BC		; Get specified dimension size
    2382/    2FAC : 03                  	INC	BC		; Include zero element
    2383/    2FAD : 71                  DEFSIZ: LD	(HL),C		; Save LSB of dimension size
    2384/    2FAE : 23                  	INC	HL
    2385/    2FAF : 70                  	LD	(HL),B		; Save MSB of dimension size
    2386/    2FB0 : 23                  	INC	HL
    2387/    2FB1 : F5                  	PUSH	AF		; Save num' of dim'ns an status
    2388/    2FB2 : E5                  	PUSH	HL		; Save address of dim'n size
    2389/    2FB3 : CD 45 37            	CALL	MLDEBC		; Multiply DE by BC to find
    2390/    2FB6 : EB                  	EX	DE,HL		; amount of mem needed (to DE)
    2391/    2FB7 : E1                  	POP	HL		; Restore address of dimension
    2392/    2FB8 : F1                  	POP	AF		; Restore number of dimensions
    2393/    2FB9 : 3D                  	DEC	A		; Count them
    2394/    2FBA : C2 A5 2F            	JP	NZ,CRARLP	; Do next dimension if more
    2395/    2FBD : F5                  	PUSH	AF		; Save locate/create flag
    2396/    2FBE : 42                  	LD	B,D		; MSB of memory needed
    2397/    2FBF : 4B                  	LD	C,E		; LSB of memory needed
    2398/    2FC0 : EB                  	EX	DE,HL
    2399/    2FC1 : 19                  	ADD	HL,DE		; Add bytes to array start
    2400/    2FC2 : DA A9 23            	JP	C,OMERR		; Too big - Error
    2401/    2FC5 : CD 9A 23            	CALL	ENFMEM		; See if enough memory
    2402/    2FC8 : 22 1F C1            	LD	(ARREND),HL	; Save new end of array
    2403/    2FCB :                     ;
    2404/    2FCB : 2B                  ZERARY: DEC	HL		; Back through array data
    2405/    2FCC : 36 00               	LD	(HL),0		; Set array element to zero
    2406/    2FCE : CD 7C 26            	CALL	CPDEHL		; All elements zeroed?
    2407/    2FD1 : C2 CB 2F            	JP	NZ,ZERARY	; No - Keep on going
    2408/    2FD4 : 03                  	INC	BC		; Number of bytes + 1
    2409/    2FD5 : 57                  	LD	D,A		; A=0
    2410/    2FD6 : 2A 0A C1            	LD	HL,(CUROPR)	; Get address of array
    2411/    2FD9 : 5E                  	LD	E,(HL)		; Number of dimensions
    2412/    2FDA : EB                  	EX	DE,HL		; To HL
    2413/    2FDB : 29                  	ADD	HL,HL		; Two bytes per dimension size
    2414/    2FDC : 09                  	ADD	HL,BC		; Add number of bytes
    2415/    2FDD : EB                  	EX	DE,HL		; Bytes needed to DE
    2416/    2FDE : 2B                  	DEC	HL
    2417/    2FDF : 2B                  	DEC	HL
    2418/    2FE0 : 73                  	LD	(HL),E		; Save LSB of bytes needed
    2419/    2FE1 : 23                  	INC	HL
    2420/    2FE2 : 72                  	LD	(HL),D		; Save MSB of bytes needed
    2421/    2FE3 : 23                  	INC	HL
    2422/    2FE4 : F1                  	POP	AF		; Locate / Create?
    2423/    2FE5 : DA 0C 30            	JP	C,ENDDIM	; A is 0 , End if create
    2424/    2FE8 : 47                  FINDEL: LD	B,A		; Find array element
    2425/    2FE9 : 4F                  	LD	C,A
    2426/    2FEA : 7E                  	LD	A,(HL)		; Number of dimensions
    2427/    2FEB : 23                  	INC	HL
    2428/    2FEC : 16                  	DB	16H		; Skip "POP HL"
    2429/    2FED : E1                  FNDELP: POP	HL		; Address of next dim' size
    2430/    2FEE : 5E                  	LD	E,(HL)		; Get LSB of dim'n size
    2431/    2FEF : 23                  	INC	HL
    2432/    2FF0 : 56                  	LD	D,(HL)		; Get MSB of dim'n size
    2433/    2FF1 : 23                  	INC	HL
    2434/    2FF2 : E3                  	EX	(SP),HL		; Save address - Get index
    2435/    2FF3 : F5                  	PUSH	AF		; Save number of dim'ns
    2436/    2FF4 : CD 7C 26            	CALL	CPDEHL		; Dimension too large?
    2437/    2FF7 : D2 85 2F            	JP	NC,BSERR	; Yes - ?BS Error
    2438/    2FFA : E5                  	PUSH	HL		; Save index
    2439/    2FFB : CD 45 37            	CALL	MLDEBC		; Multiply previous by size
    2440/    2FFE : D1                  	POP	DE		; Index supplied to DE
    2441/    2FFF : 19                  	ADD	HL,DE		; Add index to pointer
    2442/    3000 : F1                  	POP	AF		; Number of dimensions
    2443/    3001 : 3D                  	DEC	A		; Count them
    2444/    3002 : 44                  	LD	B,H		; MSB of pointer
    2445/    3003 : 4D                  	LD	C,L		; LSB of pointer
    2446/    3004 : C2 ED 2F            	JP	NZ,FNDELP	; More - Keep going
    2447/    3007 : 29                  	ADD	HL,HL		; 4 Bytes per element
    2448/    3008 : 29                  	ADD	HL,HL
    2449/    3009 : C1                  	POP	BC		; Start of array
    2450/    300A : 09                  	ADD	HL,BC		; Point to element
    2451/    300B : EB                  	EX	DE,HL		; Address of element to DE
    2452/    300C : 2A 15 C1            ENDDIM: LD	HL,(NXTOPR)	; Got code string address
    2453/    300F : C9                  	RET
    2454/    3010 :                     ;
    2455/    3010 : 2A 1F C1            FRE:	LD	HL,(ARREND)	; Start of free memory
    2456/    3013 : EB                  	EX	DE,HL		; To DE
    2457/    3014 : 21 00 00            	LD	HL,0		; End of free memory
    2458/    3017 : 39                  	ADD	HL,SP		; Current stack value
    2459/    3018 : 3A F2 C0            	LD	A,(TYPE)	; Dummy argument type
    2460/    301B : B7                  	OR	A
    2461/    301C : CA 2C 30            	JP	Z,FRENUM	; Numeric - Free variable space
    2462/    301F : CD 93 32            	CALL	GSTRCU		; Current string to pool
    2463/    3022 : CD 93 31            	CALL	GARBGE		; Garbage collection
    2464/    3025 : 2A 9F C0            	LD	HL,(STRSPC)	; Bottom of string space in use
    2465/    3028 : EB                  	EX	DE,HL		; To DE
    2466/    3029 : 2A 08 C1            	LD	HL,(STRBOT)	; Bottom of string space
    2467/    302C : 7D                  FRENUM: LD	A,L		; Get LSB of end
    2468/    302D : 93                  	SUB	E		; Subtract LSB of beginning
    2469/    302E : 4F                  	LD	C,A		; Save difference if C
    2470/    302F : 7C                  	LD	A,H		; Get MSB of end
    2471/    3030 : 9A                  	SBC	A,D		; Subtract MSB of beginning
    2472/    3031 : 41                  ACPASS: LD	B,C		; Return integer AC
    2473/    3032 : 50                  ABPASS: LD	D,B		; Return integer AB
    2474/    3033 : 1E 00               	LD	E,0
    2475/    3035 : 21 F2 C0            	LD	HL,TYPE		; Point to type
    2476/    3038 : 73                  	LD	(HL),E		; Set type to numeric
    2477/    3039 : 06 90               	LD	B,80H+16	; 16 bit integer
    2478/    303B : C3 70 36            	JP	RETINT		; Return the integr
    2479/    303E :                     ;
    2480/    303E : 3A F0 C0            POS:	LD	A,(CURPOS)	; Get cursor position
    2481/    3041 : 47                  PASSA:	LD	B,A		; Put A into AB
    2482/    3042 : AF                  	XOR	A		; Zero A
    2483/    3043 : C3 32 30            	JP	ABPASS		; Return integer AB
    2484/    3046 :                     ;
    2485/    3046 : CD C9 30            DEF:	CALL	CHEKFN		; Get "FN" and name
    2486/    3049 : CD BB 30            	CALL	IDTEST		; Test for illegal direct
    2487/    304C : 01 A1 29            	LD	BC,DATA		; To get next statement
    2488/    304F : C5                  	PUSH	BC		; Save address for RETurn
    2489/    3050 : D5                  	PUSH	DE		; Save address of function ptr
    2490/    3051 : CD 82 26            	CALL	CHKSYN		; Make sure "(" follows
    2491/    3054 : 28                  	DB	"("
    2492/    3055 : CD 6D 2E            	CALL	GETVAR		; Get argument variable name
    2493/    3058 : E5                  	PUSH	HL		; Save code string address
    2494/    3059 : EB                  	EX	DE,HL		; Argument address to HL
    2495/    305A : 2B                  	DEC	HL
    2496/    305B : 56                  	LD	D,(HL)		; Get first byte of arg name
    2497/    305C : 2B                  	DEC	HL
    2498/    305D : 5E                  	LD	E,(HL)		; Get second byte of arg name
    2499/    305E : E1                  	POP	HL		; Restore code string address
    2500/    305F : CD 7A 2C            	CALL	TSTNUM		; Make sure numeric argument
    2501/    3062 : CD 82 26            	CALL	CHKSYN		; Make sure ")" follows
    2502/    3065 : 29                  	DB	")"
    2503/    3066 : CD 82 26            	CALL	CHKSYN		; Make sure "=" follows
    2504/    3069 : B4                  	DB	ZEQUAL		; "=" token
    2505/    306A : 44                  	LD	B,H		; Code string address to BC
    2506/    306B : 4D                  	LD	C,L
    2507/    306C : E3                  	EX	(SP),HL		; Save code str , Get FN ptr
    2508/    306D : 71                  	LD	(HL),C		; Save LSB of FN code string
    2509/    306E : 23                  	INC	HL
    2510/    306F : 70                  	LD	(HL),B		; Save MSB of FN code string
    2511/    3070 : C3 08 31            	JP	SVSTAD		; Save address and do function
    2512/    3073 :                     ;
    2513/    3073 : CD C9 30            DOFN:	CALL	CHEKFN		; Make sure FN follows
    2514/    3076 : D5                  	PUSH	DE		; Save function pointer address
    2515/    3077 : CD 4E 2D            	CALL	EVLPAR		; Evaluate expression in "()"
    2516/    307A : CD 7A 2C            	CALL	TSTNUM		; Make sure numeric result
    2517/    307D : E3                  	EX	(SP),HL		; Save code str , Get FN ptr
    2518/    307E : 5E                  	LD	E,(HL)		; Get LSB of FN code string
    2519/    307F : 23                  	INC	HL
    2520/    3080 : 56                  	LD	D,(HL)		; Get MSB of FN code string
    2521/    3081 : 23                  	INC	HL
    2522/    3082 : 7A                  	LD	A,D		; And function DEFined?
    2523/    3083 : B3                  	OR	E
    2524/    3084 : CA C0 23            	JP	Z,UFERR		; No - ?UF Error
    2525/    3087 : 7E                  	LD	A,(HL)		; Get LSB of argument address
    2526/    3088 : 23                  	INC	HL
    2527/    3089 : 66                  	LD	H,(HL)		; Get MSB of argument address
    2528/    308A : 6F                  	LD	L,A		; HL = Arg variable address
    2529/    308B : E5                  	PUSH	HL		; Save it
    2530/    308C : 2A 23 C1            	LD	HL,(FNRGNM)	; Get old argument name
    2531/    308F : E3                  	EX	(SP),HL;	; Save old , Get new
    2532/    3090 : 22 23 C1            	LD	(FNRGNM),HL	; Set new argument name
    2533/    3093 : 2A 27 C1            	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
    2534/    3096 : E5                  	PUSH	HL		; Save it
    2535/    3097 : 2A 25 C1            	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
    2536/    309A : E5                  	PUSH	HL		; Save it
    2537/    309B : 21 25 C1            	LD	HL,FNARG	; HL = Value of argument
    2538/    309E : D5                  	PUSH	DE		; Save FN code string address
    2539/    309F : CD B1 36            	CALL	FPTHL		; Move FPREG to argument
    2540/    30A2 : E1                  	POP	HL		; Get FN code string address
    2541/    30A3 : CD 77 2C            	CALL	GETNUM		; Get value from function
    2542/    30A6 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2543/    30A7 : CD 0A 28            	CALL	GETCHR		; Get next character
    2544/    30AA : C2 B4 23            	JP	NZ,SNERR	; Bad character in FN - Error
    2545/    30AD : E1                  	POP	HL		; Get MSB,EXP of old arg
    2546/    30AE : 22 25 C1            	LD	(FNARG),HL	; Restore it
    2547/    30B1 : E1                  	POP	HL		; Get LSB,NLSB of old arg
    2548/    30B2 : 22 27 C1            	LD	(FNARG+2),HL	; Restore it
    2549/    30B5 : E1                  	POP	HL		; Get name of old arg
    2550/    30B6 : 22 23 C1            	LD	(FNRGNM),HL	; Restore it
    2551/    30B9 : E1                  	POP	HL		; Restore code string address
    2552/    30BA : C9                  	RET
    2553/    30BB :                     ;
    2554/    30BB : E5                  IDTEST: PUSH	HL		; Save code string address
    2555/    30BC : 2A A1 C0            	LD	HL,(LINEAT)	; Get current line number
    2556/    30BF : 23                  	INC	HL		; -1 means direct statement
    2557/    30C0 : 7C                  	LD	A,H
    2558/    30C1 : B5                  	OR	L
    2559/    30C2 : E1                  	POP	HL		; Restore code string address
    2560/    30C3 : C0                  	RET	NZ		; Return if in program
    2561/    30C4 : 1E 16               	LD	E,ID		; ?ID Error
    2562/    30C6 : C3 C8 23            	JP	ERROR_
    2563/    30C9 :                     ;
    2564/    30C9 : CD 82 26            CHEKFN: CALL	CHKSYN		; Make sure FN follows
    2565/    30CC : A7                  	DB	ZFN		; "FN" token
    2566/    30CD : 3E 80               	LD	A,80H
    2567/    30CF : 32 10 C1            	LD	(FORFLG),A	; Flag FN name to find
    2568/    30D2 : B6                  	OR	(HL)		; FN name has bit 7 set
    2569/    30D3 : 47                  	LD	B,A		; in first byte of name
    2570/    30D4 : CD 72 2E            	CALL	GTFNAM		; Get FN name
    2571/    30D7 : C3 7A 2C            	JP	TSTNUM		; Make sure numeric function
    2572/    30DA :                     ;
    2573/    30DA : CD 7A 2C            STR:	CALL	TSTNUM		; Make sure it's a number
    2574/    30DD : CD FE 37            	CALL	NUMASC		; Turn number into text
    2575/    30E0 : CD 0E 31            STR1:	CALL	CRTST		; Create string entry for it
    2576/    30E3 : CD 93 32            	CALL	GSTRCU		; Current string to pool
    2577/    30E6 : 01 EE 32            	LD	BC,TOPOOL	; Save in string pool
    2578/    30E9 : C5                  	PUSH	BC		; Save address on stack
    2579/    30EA :                     ;
    2580/    30EA : 7E                  SAVSTR: LD	A,(HL)		; Get string length
    2581/    30EB : 23                  	INC	HL
    2582/    30EC : 23                  	INC	HL
    2583/    30ED : E5                  	PUSH	HL		; Save pointer to string
    2584/    30EE : CD 69 31            	CALL	TESTR		; See if enough string space
    2585/    30F1 : E1                  	POP	HL		; Restore pointer to string
    2586/    30F2 : 4E                  	LD	C,(HL)		; Get LSB of address
    2587/    30F3 : 23                  	INC	HL
    2588/    30F4 : 46                  	LD	B,(HL)		; Get MSB of address
    2589/    30F5 : CD 02 31            	CALL	CRTMST		; Create string entry
    2590/    30F8 : E5                  	PUSH	HL		; Save pointer to MSB of addr
    2591/    30F9 : 6F                  	LD	L,A		; Length of string
    2592/    30FA : CD 86 32            	CALL	TOSTRA		; Move to string area
    2593/    30FD : D1                  	POP	DE		; Restore pointer to MSB
    2594/    30FE : C9                  	RET
    2595/    30FF :                     ;
    2596/    30FF : CD 69 31            MKTMST: CALL	TESTR		; See if enough string space
    2597/    3102 : 21 04 C1            CRTMST: LD	HL,TMPSTR	; Temporary string
    2598/    3105 : E5                  	PUSH	HL		; Save it
    2599/    3106 : 77                  	LD	(HL),A		; Save length of string
    2600/    3107 : 23                  	INC	HL
    2601/    3108 : 23                  SVSTAD: INC	HL
    2602/    3109 : 73                  	LD	(HL),E		; Save LSB of address
    2603/    310A : 23                  	INC	HL
    2604/    310B : 72                  	LD	(HL),D		; Save MSB of address
    2605/    310C : E1                  	POP	HL		; Restore pointer
    2606/    310D : C9                  	RET
    2607/    310E :                     ;
    2608/    310E : 2B                  CRTST:	DEC	HL		; DEC - INCed after
    2609/    310F : 06 22               QTSTR:	LD	B,'"'		; Terminating quote
    2610/    3111 : 50                  	LD	D,B		; Quote to D
    2611/    3112 : E5                  DTSTR:	PUSH	HL		; Save start
    2612/    3113 : 0E FF               	LD	C,-1		; Set counter to -1
    2613/    3115 : 23                  QTSTLP: INC	HL		; Move on
    2614/    3116 : 7E                  	LD	A,(HL)		; Get byte
    2615/    3117 : 0C                  	INC	C		; Count bytes
    2616/    3118 : B7                  	OR	A		; End of line?
    2617/    3119 : CA 24 31            	JP	Z,CRTSTE	; Yes - Create string entry
    2618/    311C : BA                  	CP	D		; Terminator D found?
    2619/    311D : CA 24 31            	JP	Z,CRTSTE	; Yes - Create string entry
    2620/    3120 : B8                  	CP	B		; Terminator B found?
    2621/    3121 : C2 15 31            	JP	NZ,QTSTLP	; No - Keep looking
    2622/    3124 : FE 22               CRTSTE: CP	'"'		; End with '"'?
    2623/    3126 : CC 0A 28            	CALL	Z,GETCHR	; Yes - Get next character
    2624/    3129 : E3                  	EX	(SP),HL		; Starting quote
    2625/    312A : 23                  	INC	HL		; First byte of string
    2626/    312B : EB                  	EX	DE,HL		; To DE
    2627/    312C : 79                  	LD	A,C		; Get length
    2628/    312D : CD 02 31            	CALL	CRTMST		; Create string entry
    2629/    3130 : 11 04 C1            TSTOPL: LD	DE,TMPSTR	; Temporary string
    2630/    3133 : 2A F6 C0            	LD	HL,(TMSTPT)	; Temporary string pool pointer
    2631/    3136 : 22 29 C1            	LD	(FPREG),HL	; Save address of string ptr
    2632/    3139 : 3E 01               	LD	A,1
    2633/    313B : 32 F2 C0            	LD	(TYPE),A	; Set type to string
    2634/    313E : CD B4 36            	CALL	DETHL4		; Move string to pool
    2635/    3141 : CD 7C 26            	CALL	CPDEHL		; Out of string pool?
    2636/    3144 : 22 F6 C0            	LD	(TMSTPT),HL	; Save new pointer
    2637/    3147 : E1                  	POP	HL		; Restore code string address
    2638/    3148 : 7E                  	LD	A,(HL)		; Get next code byte
    2639/    3149 : C0                  	RET	NZ		; Return if pool OK
    2640/    314A : 1E 1E               	LD	E,ST		; ?ST Error
    2641/    314C : C3 C8 23            	JP	ERROR_		; String pool overflow
    2642/    314F :                     ;
    2643/    314F : 23                  PRNUMS: INC	HL		; Skip leading space
    2644/    3150 : CD 0E 31            PRS:	CALL	CRTST		; Create string entry for it
    2645/    3153 : CD 93 32            PRS1:	CALL	GSTRCU		; Current string to pool
    2646/    3156 : CD A8 36            	CALL	LOADFP		; Move string block to BCDE
    2647/    3159 : 1C                  	INC	E		; Length + 1
    2648/    315A : 1D                  PRSLP:	DEC	E		; Count characters
    2649/    315B : C8                  	RET	Z		; End of string
    2650/    315C : 0A                  	LD	A,(BC)		; Get byte to output
    2651/    315D : CD 8D 26            	CALL	OUTC		; Output character in A
    2652/    3160 : FE 0D               	CP	CR		; Return?
    2653/    3162 : CC BC 2A            	CALL	Z,DONULL	; Yes - Do nulls
    2654/    3165 : 03                  	INC	BC		; Next byte in string
    2655/    3166 : C3 5A 31            	JP	PRSLP		; More characters to output
    2656/    3169 :                     ;
    2657/    3169 : B7                  TESTR:	OR	A		; Test if enough room
    2658/    316A : 0E                  	DB	0EH		; No garbage collection done
    2659/    316B : F1                  GRBDON: POP	AF		; Garbage collection done
    2660/    316C : F5                  	PUSH	AF		; Save status
    2661/    316D : 2A 9F C0            	LD	HL,(STRSPC)	; Bottom of string space in use
    2662/    3170 : EB                  	EX	DE,HL		; To DE
    2663/    3171 : 2A 08 C1            	LD	HL,(STRBOT)	; Bottom of string area
    2664/    3174 : 2F                  	CPL			; Negate length (Top down)
    2665/    3175 : 4F                  	LD	C,A		; -Length to BC
    2666/    3176 : 06 FF               	LD	B,-1		; BC = -ve length of string
    2667/    3178 : 09                  	ADD	HL,BC		; Add to bottom of space in use
    2668/    3179 : 23                  	INC	HL		; Plus one for 2's complement
    2669/    317A : CD 7C 26            	CALL	CPDEHL		; Below string RAM area?
    2670/    317D : DA 87 31            	JP	C,TESTOS	; Tidy up if not done else err
    2671/    3180 : 22 08 C1            	LD	(STRBOT),HL	; Save new bottom of area
    2672/    3183 : 23                  	INC	HL		; Point to first byte of string
    2673/    3184 : EB                  	EX	DE,HL		; Address to DE
    2674/    3185 : F1                  POPAF:	POP	AF		; Throw away status push
    2675/    3186 : C9                  	RET
    2676/    3187 :                     ;
    2677/    3187 : F1                  TESTOS: POP	AF		; Garbage collect been done?
    2678/    3188 : 1E 1A               	LD	E,OS		; ?OS Error
    2679/    318A : CA C8 23            	JP	Z,ERROR_	; Yes - Not enough string apace
    2680/    318D : BF                  	CP	A		; Flag garbage collect done
    2681/    318E : F5                  	PUSH	AF		; Save status
    2682/    318F : 01 6B 31            	LD	BC,GRBDON	; Garbage collection done
    2683/    3192 : C5                  	PUSH	BC		; Save for RETurn
    2684/    3193 : 2A F4 C0            GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
    2685/    3196 : 22 08 C1            GARBLP: LD	(STRBOT),HL	; Reset string pointer
    2686/    3199 : 21 00 00            	LD	HL,0
    2687/    319C : E5                  	PUSH	HL		; Flag no string found
    2688/    319D : 2A 9F C0            	LD	HL,(STRSPC)	; Get bottom of string space
    2689/    31A0 : E5                  	PUSH	HL		; Save bottom of string space
    2690/    31A1 : 21 F8 C0            	LD	HL,TMSTPL	; Temporary string pool
    2691/    31A4 : EB                  GRBLP:	EX	DE,HL
    2692/    31A5 : 2A F6 C0            	LD	HL,(TMSTPT)	; Temporary string pool pointer
    2693/    31A8 : EB                  	EX	DE,HL
    2694/    31A9 : CD 7C 26            	CALL	CPDEHL		; Temporary string pool done?
    2695/    31AC : 01 A4 31            	LD	BC,GRBLP	; Loop until string pool done
    2696/    31AF : C2 F8 31            	JP	NZ,STPOOL	; No - See if in string area
    2697/    31B2 : 2A 1B C1            	LD	HL,(PROGND)	; Start of simple variables
    2698/    31B5 : EB                  SMPVAR: EX	DE,HL
    2699/    31B6 : 2A 1D C1            	LD	HL,(VAREND)	; End of simple variables
    2700/    31B9 : EB                  	EX	DE,HL
    2701/    31BA : CD 7C 26            	CALL	CPDEHL		; All simple strings done?
    2702/    31BD : CA CB 31            	JP	Z,ARRLP		; Yes - Do string arrays
    2703/    31C0 : 7E                  	LD	A,(HL)		; Get type of variable
    2704/    31C1 : 23                  	INC	HL
    2705/    31C2 : 23                  	INC	HL
    2706/    31C3 : B7                  	OR	A		; "S" flag set if string
    2707/    31C4 : CD FB 31            	CALL	STRADD		; See if string in string area
    2708/    31C7 : C3 B5 31            	JP	SMPVAR		; Loop until simple ones done
    2709/    31CA :                     ;
    2710/    31CA : C1                  GNXARY: POP	BC		; Scrap address of this array
    2711/    31CB : EB                  ARRLP:	EX	DE,HL
    2712/    31CC : 2A 1F C1            	LD	HL,(ARREND)	; End of string arrays
    2713/    31CF : EB                  	EX	DE,HL
    2714/    31D0 : CD 7C 26            	CALL	CPDEHL		; All string arrays done?
    2715/    31D3 : CA 21 32            	JP	Z,SCNEND	; Yes - Move string if found
    2716/    31D6 : CD A8 36            	CALL	LOADFP		; Get array name to BCDE
    2717/    31D9 : 7B                  	LD	A,E		; Get type of array	
    2718/    31DA : E5                  	PUSH	HL		; Save address of num of dim'ns
    2719/    31DB : 09                  	ADD	HL,BC		; Start of next array
    2720/    31DC : B7                  	OR	A		; Test type of array
    2721/    31DD : F2 CA 31            	JP	P,GNXARY	; Numeric array - Ignore it
    2722/    31E0 : 22 0A C1            	LD	(CUROPR),HL	; Save address of next array
    2723/    31E3 : E1                  	POP	HL		; Get address of num of dim'ns
    2724/    31E4 : 4E                  	LD	C,(HL)		; BC = Number of dimensions
    2725/    31E5 : 06 00               	LD	B,0
    2726/    31E7 : 09                  	ADD	HL,BC		; Two bytes per dimension size
    2727/    31E8 : 09                  	ADD	HL,BC
    2728/    31E9 : 23                  	INC	HL		; Plus one for number of dim'ns
    2729/    31EA : EB                  GRBARY: EX	DE,HL
    2730/    31EB : 2A 0A C1            	LD	HL,(CUROPR)	; Get address of next array
    2731/    31EE : EB                  	EX	DE,HL
    2732/    31EF : CD 7C 26            	CALL	CPDEHL		; Is this array finished?
    2733/    31F2 : CA CB 31            	JP	Z,ARRLP		; Yes - Get next one
    2734/    31F5 : 01 EA 31            	LD	BC,GRBARY	; Loop until array all done
    2735/    31F8 : C5                  STPOOL: PUSH	BC		; Save return address
    2736/    31F9 : F6 80               	OR	80H		; Flag string type
    2737/    31FB : 7E                  STRADD: LD	A,(HL)		; Get string length
    2738/    31FC : 23                  	INC	HL
    2739/    31FD : 23                  	INC	HL
    2740/    31FE : 5E                  	LD	E,(HL)		; Get LSB of string address
    2741/    31FF : 23                  	INC	HL
    2742/    3200 : 56                  	LD	D,(HL)		; Get MSB of string address
    2743/    3201 : 23                  	INC	HL
    2744/    3202 : F0                  	RET	P		; Not a string - Return
    2745/    3203 : B7                  	OR	A		; Set flags on string length
    2746/    3204 : C8                  	RET	Z		; Null string - Return
    2747/    3205 : 44                  	LD	B,H		; Save variable pointer
    2748/    3206 : 4D                  	LD	C,L
    2749/    3207 : 2A 08 C1            	LD	HL,(STRBOT)	; Bottom of new area
    2750/    320A : CD 7C 26            	CALL	CPDEHL		; String been done?
    2751/    320D : 60                  	LD	H,B		; Restore variable pointer
    2752/    320E : 69                  	LD	L,C
    2753/    320F : D8                  	RET	C		; String done - Ignore
    2754/    3210 : E1                  	POP	HL		; Return address
    2755/    3211 : E3                  	EX	(SP),HL		; Lowest available string area
    2756/    3212 : CD 7C 26            	CALL	CPDEHL		; String within string area?
    2757/    3215 : E3                  	EX	(SP),HL		; Lowest available string area
    2758/    3216 : E5                  	PUSH	HL		; Re-save return address
    2759/    3217 : 60                  	LD	H,B		; Restore variable pointer
    2760/    3218 : 69                  	LD	L,C
    2761/    3219 : D0                  	RET	NC		; Outside string area - Ignore
    2762/    321A : C1                  	POP	BC		; Get return , Throw 2 away
    2763/    321B : F1                  	POP	AF		; 
    2764/    321C : F1                  	POP	AF		; 
    2765/    321D : E5                  	PUSH	HL		; Save variable pointer
    2766/    321E : D5                  	PUSH	DE		; Save address of current
    2767/    321F : C5                  	PUSH	BC		; Put back return address
    2768/    3220 : C9                  	RET			; Go to it
    2769/    3221 :                     ;
    2770/    3221 : D1                  SCNEND: POP	DE		; Addresses of strings
    2771/    3222 : E1                  	POP	HL		; 
    2772/    3223 : 7D                  	LD	A,L		; HL = 0 if no more to do
    2773/    3224 : B4                  	OR	H
    2774/    3225 : C8                  	RET	Z		; No more to do - Return
    2775/    3226 : 2B                  	DEC	HL
    2776/    3227 : 46                  	LD	B,(HL)		; MSB of address of string
    2777/    3228 : 2B                  	DEC	HL
    2778/    3229 : 4E                  	LD	C,(HL)		; LSB of address of string
    2779/    322A : E5                  	PUSH	HL		; Save variable address
    2780/    322B : 2B                  	DEC	HL
    2781/    322C : 2B                  	DEC	HL
    2782/    322D : 6E                  	LD	L,(HL)		; HL = Length of string
    2783/    322E : 26 00               	LD	H,0
    2784/    3230 : 09                  	ADD	HL,BC		; Address of end of string+1
    2785/    3231 : 50                  	LD	D,B		; String address to DE
    2786/    3232 : 59                  	LD	E,C
    2787/    3233 : 2B                  	DEC	HL		; Last byte in string
    2788/    3234 : 44                  	LD	B,H		; Address to BC
    2789/    3235 : 4D                  	LD	C,L
    2790/    3236 : 2A 08 C1            	LD	HL,(STRBOT)	; Current bottom of string area
    2791/    3239 : CD 83 23            	CALL	MOVSTR		; Move string to new address
    2792/    323C : E1                  	POP	HL		; Restore variable address
    2793/    323D : 71                  	LD	(HL),C		; Save new LSB of address
    2794/    323E : 23                  	INC	HL
    2795/    323F : 70                  	LD	(HL),B		; Save new MSB of address
    2796/    3240 : 69                  	LD	L,C		; Next string area+1 to HL
    2797/    3241 : 60                  	LD	H,B
    2798/    3242 : 2B                  	DEC	HL		; Next string area address
    2799/    3243 : C3 96 31            	JP	GARBLP		; Look for more strings
    2800/    3246 :                     ;
    2801/    3246 : C5                  CONCAT: PUSH	BC		; Save prec' opr & code string
    2802/    3247 : E5                  	PUSH	HL		; 
    2803/    3248 : 2A 29 C1            	LD	HL,(FPREG)	; Get first string
    2804/    324B : E3                  	EX	(SP),HL		; Save first string
    2805/    324C : CD 00 2D            	CALL	OPRND		; Get second string
    2806/    324F : E3                  	EX	(SP),HL		; Restore first string
    2807/    3250 : CD 7B 2C            	CALL	TSTSTR		; Make sure it's a string
    2808/    3253 : 7E                  	LD	A,(HL)		; Get length of second string
    2809/    3254 : E5                  	PUSH	HL		; Save first string
    2810/    3255 : 2A 29 C1            	LD	HL,(FPREG)	; Get second string
    2811/    3258 : E5                  	PUSH	HL		; Save second string
    2812/    3259 : 86                  	ADD	A,(HL)		; Add length of second string
    2813/    325A : 1E 1C               	LD	E,LS		; ?LS Error
    2814/    325C : DA C8 23            	JP	C,ERROR_	; String too long - Error
    2815/    325F : CD FF 30            	CALL	MKTMST		; Make temporary string
    2816/    3262 : D1                  	POP	DE		; Get second string to DE
    2817/    3263 : CD 97 32            	CALL	GSTRDE		; Move to string pool if needed
    2818/    3266 : E3                  	EX	(SP),HL		; Get first string
    2819/    3267 : CD 96 32            	CALL	GSTRHL		; Move to string pool if needed
    2820/    326A : E5                  	PUSH	HL		; Save first string
    2821/    326B : 2A 06 C1            	LD	HL,(TMPSTR+2)	; Temporary string address
    2822/    326E : EB                  	EX	DE,HL		; To DE
    2823/    326F : CD 7D 32            	CALL	SSTSA		; First string to string area
    2824/    3272 : CD 7D 32            	CALL	SSTSA		; Second string to string area
    2825/    3275 : 21 95 2C            	LD	HL,EVAL2	; Return to evaluation loop
    2826/    3278 : E3                  	EX	(SP),HL		; Save return,get code string
    2827/    3279 : E5                  	PUSH	HL		; Save code string address
    2828/    327A : C3 30 31            	JP	TSTOPL		; To temporary string to pool
    2829/    327D :                     ;
    2830/    327D : E1                  SSTSA:	POP	HL		; Return address
    2831/    327E : E3                  	EX	(SP),HL		; Get string block,save return
    2832/    327F : 7E                  	LD	A,(HL)		; Get length of string
    2833/    3280 : 23                  	INC	HL
    2834/    3281 : 23                  	INC	HL
    2835/    3282 : 4E                  	LD	C,(HL)		; Get LSB of string address
    2836/    3283 : 23                  	INC	HL
    2837/    3284 : 46                  	LD	B,(HL)		; Get MSB of string address
    2838/    3285 : 6F                  	LD	L,A		; Length to L
    2839/    3286 : 2C                  TOSTRA: INC	L		; INC - DECed after
    2840/    3287 : 2D                  TSALP:	DEC	L		; Count bytes moved
    2841/    3288 : C8                  	RET	Z		; End of string - Return
    2842/    3289 : 0A                  	LD	A,(BC)		; Get source
    2843/    328A : 12                  	LD	(DE),A		; Save destination
    2844/    328B : 03                  	INC	BC		; Next source
    2845/    328C : 13                  	INC	DE		; Next destination
    2846/    328D : C3 87 32            	JP	TSALP		; Loop until string moved
    2847/    3290 :                     ;
    2848/    3290 : CD 7B 2C            GETSTR: CALL	TSTSTR		; Make sure it's a string
    2849/    3293 : 2A 29 C1            GSTRCU: LD	HL,(FPREG)	; Get current string
    2850/    3296 : EB                  GSTRHL: EX	DE,HL		; Save DE
    2851/    3297 : CD B1 32            GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
    2852/    329A : EB                  	EX	DE,HL		; Restore DE
    2853/    329B : C0                  	RET	NZ		; No - Return
    2854/    329C : D5                  	PUSH	DE		; Save string
    2855/    329D : 50                  	LD	D,B		; String block address to DE
    2856/    329E : 59                  	LD	E,C
    2857/    329F : 1B                  	DEC	DE		; Point to length
    2858/    32A0 : 4E                  	LD	C,(HL)		; Get string length
    2859/    32A1 : 2A 08 C1            	LD	HL,(STRBOT)	; Current bottom of string area
    2860/    32A4 : CD 7C 26            	CALL	CPDEHL		; Last one in string area?
    2861/    32A7 : C2 AF 32            	JP	NZ,POPHL	; No - Return
    2862/    32AA : 47                  	LD	B,A		; Clear B (A=0)
    2863/    32AB : 09                  	ADD	HL,BC		; Remove string from str' area
    2864/    32AC : 22 08 C1            	LD	(STRBOT),HL	; Save new bottom of str' area
    2865/    32AF : E1                  POPHL:	POP	HL		; Restore string
    2866/    32B0 : C9                  	RET
    2867/    32B1 :                     ;
    2868/    32B1 : 2A F6 C0            BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
    2869/    32B4 : 2B                  	DEC	HL		; Back
    2870/    32B5 : 46                  	LD	B,(HL)		; Get MSB of address
    2871/    32B6 : 2B                  	DEC	HL		; Back
    2872/    32B7 : 4E                  	LD	C,(HL)		; Get LSB of address
    2873/    32B8 : 2B                  	DEC	HL		; Back
    2874/    32B9 : 2B                  	DEC	HL		; Back
    2875/    32BA : CD 7C 26            	CALL	CPDEHL		; String last in string pool?
    2876/    32BD : C0                  	RET	NZ		; Yes - Leave it
    2877/    32BE : 22 F6 C0            	LD	(TMSTPT),HL	; Save new string pool top
    2878/    32C1 : C9                  	RET
    2879/    32C2 :                     ;
    2880/    32C2 : 01 41 30            LEN:	LD	BC,PASSA	; To return integer A
    2881/    32C5 : C5                  	PUSH	BC		; Save address
    2882/    32C6 : CD 90 32            GETLEN: CALL	GETSTR		; Get string and its length
    2883/    32C9 : AF                  	XOR	A
    2884/    32CA : 57                  	LD	D,A		; Clear D
    2885/    32CB : 32 F2 C0            	LD	(TYPE),A	; Set type to numeric
    2886/    32CE : 7E                  	LD	A,(HL)		; Get length of string
    2887/    32CF : B7                  	OR	A		; Set status flags
    2888/    32D0 : C9                  	RET
    2889/    32D1 :                     ;
    2890/    32D1 : 01 41 30            ASC:	LD	BC,PASSA	; To return integer A
    2891/    32D4 : C5                  	PUSH	BC		; Save address
    2892/    32D5 : CD C6 32            GTFLNM: CALL	GETLEN		; Get length of string
    2893/    32D8 : CA D1 28            	JP	Z,FCERR		; Null string - Error
    2894/    32DB : 23                  	INC	HL
    2895/    32DC : 23                  	INC	HL
    2896/    32DD : 5E                  	LD	E,(HL)		; Get LSB of address
    2897/    32DE : 23                  	INC	HL
    2898/    32DF : 56                  	LD	D,(HL)		; Get MSB of address
    2899/    32E0 : 1A                  	LD	A,(DE)		; Get first byte of string
    2900/    32E1 : C9                  	RET
    2901/    32E2 :                     ;
    2902/    32E2 : 3E 01               CHR:	LD	A,1		; One character string
    2903/    32E4 : CD FF 30            	CALL	MKTMST		; Make a temporary string
    2904/    32E7 : CD DB 33            	CALL	MAKINT		; Make it integer A
    2905/    32EA : 2A 06 C1            	LD	HL,(TMPSTR+2)	; Get address of string
    2906/    32ED : 73                  	LD	(HL),E		; Save character
    2907/    32EE : C1                  TOPOOL: POP	BC		; Clean up stack
    2908/    32EF : C3 30 31            	JP	TSTOPL		; Temporary string to pool
    2909/    32F2 :                     ;
    2910/    32F2 : CD 8B 33            LEFT:	CALL	LFRGNM		; Get number and ending ")"
    2911/    32F5 : AF                  	XOR	A		; Start at first byte in string
    2912/    32F6 : E3                  RIGHT1: EX	(SP),HL		; Save code string,Get string
    2913/    32F7 : 4F                  	LD	C,A		; Starting position in string
    2914/    32F8 : E5                  MID1:	PUSH	HL		; Save string block address
    2915/    32F9 : 7E                  	LD	A,(HL)		; Get length of string
    2916/    32FA : B8                  	CP	B		; Compare with number given
    2917/    32FB : DA 00 33            	JP	C,ALLFOL	; All following bytes required
    2918/    32FE : 78                  	LD	A,B		; Get new length
    2919/    32FF : 11                  	DB	11H		; Skip "LD C,0"
    2920/    3300 : 0E 00               ALLFOL: LD	C,0		; First byte of string
    2921/    3302 : C5                  	PUSH	BC		; Save position in string
    2922/    3303 : CD 69 31            	CALL	TESTR		; See if enough string space
    2923/    3306 : C1                  	POP	BC		; Get position in string
    2924/    3307 : E1                  	POP	HL		; Restore string block address
    2925/    3308 : E5                  	PUSH	HL		; And re-save it
    2926/    3309 : 23                  	INC	HL
    2927/    330A : 23                  	INC	HL
    2928/    330B : 46                  	LD	B,(HL)		; Get LSB of address
    2929/    330C : 23                  	INC	HL
    2930/    330D : 66                  	LD	H,(HL)		; Get MSB of address
    2931/    330E : 68                  	LD	L,B		; HL = address of string
    2932/    330F : 06 00               	LD	B,0		; BC = starting address
    2933/    3311 : 09                  	ADD	HL,BC		; Point to that byte
    2934/    3312 : 44                  	LD	B,H		; BC = source string
    2935/    3313 : 4D                  	LD	C,L
    2936/    3314 : CD 02 31            	CALL	CRTMST		; Create a string entry
    2937/    3317 : 6F                  	LD	L,A		; Length of new string
    2938/    3318 : CD 86 32            	CALL	TOSTRA		; Move string to string area
    2939/    331B : D1                  	POP	DE		; Clear stack
    2940/    331C : CD 97 32            	CALL	GSTRDE		; Move to string pool if needed
    2941/    331F : C3 30 31            	JP	TSTOPL		; Temporary string to pool
    2942/    3322 :                     ;
    2943/    3322 : CD 8B 33            RIGHT:	CALL	LFRGNM		; Get number and ending ")"
    2944/    3325 : D1                  	POP	DE		; Get string length
    2945/    3326 : D5                  	PUSH	DE		; And re-save
    2946/    3327 : 1A                  	LD	A,(DE)		; Get length
    2947/    3328 : 90                  	SUB	B		; Move back N bytes
    2948/    3329 : C3 F6 32            	JP	RIGHT1		; Go and get sub-string
    2949/    332C :                     ;
    2950/    332C : EB                  MID:	EX	DE,HL		; Get code string address
    2951/    332D : 7E                  	LD	A,(HL)		; Get next byte ',' or ")"
    2952/    332E : CD 90 33            	CALL	MIDNUM		; Get number supplied
    2953/    3331 : 04                  	INC	B		; Is it character zero?
    2954/    3332 : 05                  	DEC	B
    2955/    3333 : CA D1 28            	JP	Z,FCERR		; Yes - Error
    2956/    3336 : C5                  	PUSH	BC		; Save starting position
    2957/    3337 : 1E FF               	LD	E,255		; All of string
    2958/    3339 : FE 29               	CP	')'		; Any length given?
    2959/    333B : CA 45 33            	JP	Z,RSTSTR	; No - Rest of string
    2960/    333E : CD 82 26            	CALL	CHKSYN		; Make sure ',' follows
    2961/    3341 : 2C                  	DB	','
    2962/    3342 : CD D8 33            	CALL	GETINT		; Get integer 0-255
    2963/    3345 : CD 82 26            RSTSTR: CALL	CHKSYN		; Make sure ")" follows
    2964/    3348 : 29                  	DB	")"
    2965/    3349 : F1                  	POP	AF		; Restore starting position
    2966/    334A : E3                  	EX	(SP),HL		; Get string,8ave code string
    2967/    334B : 01 F8 32            	LD	BC,MID1		; Continuation of MID$ routine
    2968/    334E : C5                  	PUSH	BC		; Save for return
    2969/    334F : 3D                  	DEC	A		; Starting position-1
    2970/    3350 : BE                  	CP	(HL)		; Compare with length
    2971/    3351 : 06 00               	LD	B,0		; Zero bytes length
    2972/    3353 : D0                  	RET	NC		; Null string if start past end
    2973/    3354 : 4F                  	LD	C,A		; Save starting position-1
    2974/    3355 : 7E                  	LD	A,(HL)		; Get length of string
    2975/    3356 : 91                  	SUB	C		; Subtract start
    2976/    3357 : BB                  	CP	E		; Enough string for it?
    2977/    3358 : 47                  	LD	B,A		; Save maximum length available
    2978/    3359 : D8                  	RET	C		; Truncate string if needed
    2979/    335A : 43                  	LD	B,E		; Set specified length
    2980/    335B : C9                  	RET			; Go and create string
    2981/    335C :                     ;
    2982/    335C : CD C6 32            VAL:	CALL	GETLEN		; Get length of string
    2983/    335F : CA 79 34            	JP	Z,RESZER	; Result zero
    2984/    3362 : 5F                  	LD	E,A		; Save length
    2985/    3363 : 23                  	INC	HL
    2986/    3364 : 23                  	INC	HL
    2987/    3365 : 7E                  	LD	A,(HL)		; Get LSB of address
    2988/    3366 : 23                  	INC	HL
    2989/    3367 : 66                  	LD	H,(HL)		; Get MSB of address
    2990/    3368 : 6F                  	LD	L,A		; HL = String address
    2991/    3369 : E5                  	PUSH	HL		; Save string address
    2992/    336A : 19                  	ADD	HL,DE
    2993/    336B : 46                  	LD	B,(HL)		; Get end of string+1 byte
    2994/    336C : 72                  	LD	(HL),D		; Zero it to terminate
    2995/    336D : E3                  	EX	(SP),HL		; Save string end,get start
    2996/    336E : C5                  	PUSH	BC		; Save end+1 byte
    2997/    336F : 7E                  	LD	A,(HL)		; Get starting byte
    2998/    3370 : FE 24               	CP	'$'		; Hex number indicated? [function added]
    2999/    3372 : C2 7A 33            	JP	NZ,VAL1
    3000/    3375 : CD A3 3B            	CALL	HEXTFP		; Convert Hex to FPREG
    3001/    3378 : 18 0D               	JR	VAL3
    3002/    337A : FE 25               VAL1:	CP	'%'		; Binary number indicated? [function added]
    3003/    337C : C2 84 33            	JP	NZ,VAL2
    3004/    337F : CD 13 3C            	CALL	BINTFP		; Convert Bin to FPREG
    3005/    3382 : 18 03               	JR	VAL3
    3006/    3384 : CD 60 37            VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
    3007/    3387 : C1                  VAL3:	POP	BC		; Restore end+1 byte
    3008/    3388 : E1                  	POP	HL		; Restore end+1 address
    3009/    3389 : 70                  	LD	(HL),B		; Put back original byte
    3010/    338A : C9                  	RET
    3011/    338B :                     ;
    3012/    338B : EB                  LFRGNM: EX	DE,HL		; Code string address to HL
    3013/    338C : CD 82 26            	CALL	CHKSYN		; Make sure ")" follows
    3014/    338F : 29                  	DB	")"
    3015/    3390 : C1                  MIDNUM: POP	BC		; Get return address
    3016/    3391 : D1                  	POP	DE		; Get number supplied
    3017/    3392 : C5                  	PUSH	BC		; Re-save return address
    3018/    3393 : 43                  	LD	B,E		; Number to B
    3019/    3394 : C9                  	RET
    3020/    3395 :                     ;
    3021/    3395 : CD DB 33            INP:	CALL	MAKINT		; Make it integer A
    3022/    3398 : 32 84 C0            	LD	(INPORT),A	; Set input port
    3023/    339B : CD 83 C0            	CALL	INPSUB		; Get input from port
    3024/    339E : C3 41 30            	JP	PASSA		; Return integer A
    3025/    33A1 :                     ;
    3026/    33A1 : CD C5 33            POUT:	CALL	SETIO		; Set up port number
    3027/    33A4 : C3 4B C0            	JP	OUTSUB		; Output data and return
    3028/    33A7 :                     ;
    3029/    33A7 : CD C5 33            WAIT:	CALL	SETIO		; Set up port number
    3030/    33AA : F5                  	PUSH	AF		; Save AND mask
    3031/    33AB : 1E 00               	LD	E,0		; Assume zero if none given
    3032/    33AD : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3033/    33AE : CD 0A 28            	CALL	GETCHR		; Get next character
    3034/    33B1 : CA BB 33            	JP	Z,NOXOR		; No XOR byte given
    3035/    33B4 : CD 82 26            	CALL	CHKSYN		; Make sure ',' follows
    3036/    33B7 : 2C                  	DB	','
    3037/    33B8 : CD D8 33            	CALL	GETINT		; Get integer 0-255 to XOR with
    3038/    33BB : C1                  NOXOR:	POP	BC		; Restore AND mask
    3039/    33BC : CD 83 C0            WAITLP: CALL	INPSUB		; Get input
    3040/    33BF : AB                  	XOR	E		; Flip selected bits
    3041/    33C0 : A0                  	AND	B		; Result non-zero?
    3042/    33C1 : CA BC 33            	JP	Z,WAITLP	; No = keep waiting
    3043/    33C4 : C9                  	RET
    3044/    33C5 :                     ;
    3045/    33C5 : CD D8 33            SETIO:	CALL	GETINT		; Get integer 0-255
    3046/    33C8 : 32 84 C0            	LD	(INPORT),A	; Set input port
    3047/    33CB : 32 4C C0            	LD	(OTPORT),A	; Set output port
    3048/    33CE : CD 82 26            	CALL	CHKSYN		; Make sure ',' follows
    3049/    33D1 : 2C                  	DB	','
    3050/    33D2 : C3 D8 33            	JP	GETINT		; Get integer 0-255 and return
    3051/    33D5 :                     ;
    3052/    33D5 : CD 0A 28            FNDNUM: CALL	GETCHR		; Get next character
    3053/    33D8 : CD 77 2C            GETINT: CALL	GETNUM		; Get a number from 0 to 255
    3054/    33DB : CD B6 28            MAKINT: CALL	DEPINT		; Make sure value 0 - 255
    3055/    33DE : 7A                  	LD	A,D		; Get MSB of number
    3056/    33DF : B7                  	OR	A		; Zero?
    3057/    33E0 : C2 D1 28            	JP	NZ,FCERR	; No - Error
    3058/    33E3 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3059/    33E4 : CD 0A 28            	CALL	GETCHR		; Get next character
    3060/    33E7 : 7B                  	LD	A,E		; Get number to A
    3061/    33E8 : C9                  	RET
    3062/    33E9 :                     ;
    3063/    33E9 : CD BC 28            PEEK:	CALL	DEINT		; Get memory address
    3064/    33EC : 1A                  	LD	A,(DE)		; Get byte in memory
    3065/    33ED : C3 41 30            	JP	PASSA		; Return integer A
    3066/    33F0 :                     ;
    3067/    33F0 : CD 77 2C            POKE:	CALL	GETNUM		; Get memory address
    3068/    33F3 : CD BC 28            	CALL	DEINT		; Get integer -32768 to 3276
    3069/    33F6 : D5                  	PUSH	DE		; Save memory address
    3070/    33F7 : CD 82 26            	CALL	CHKSYN		; Make sure ',' follows
    3071/    33FA : 2C                  	DB	','
    3072/    33FB : CD D8 33            	CALL	GETINT		; Get integer 0-255
    3073/    33FE : D1                  	POP	DE		; Restore memory address
    3074/    33FF : 12                  	LD	(DE),A		; Load it into memory
    3075/    3400 : C9                  	RET
    3076/    3401 :                     ;
    3077/    3401 : 21 D7 38            ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
    3078/    3404 : CD A8 36            ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
    3079/    3407 : C3 13 34            	JP	FPADD		; Add BCDE to FPREG
    3080/    340A :                     ;
    3081/    340A : CD A8 36            SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
    3082/    340D : 21                  	DB	21H		; Skip "POP BC" and "POP DE"
    3083/    340E : C1                  PSUB:	POP	BC		; Get FP number from stack
    3084/    340F : D1                  	POP	DE
    3085/    3410 : CD 82 36            SUBCDE: CALL	INVSGN		; Negate FPREG
    3086/    3413 : 78                  FPADD:	LD	A,B		; Get FP exponent
    3087/    3414 : B7                  	OR	A		; Is number zero?
    3088/    3415 : C8                  	RET	Z		; Yes - Nothing to add
    3089/    3416 : 3A 2C C1            	LD	A,(FPEXP)	; Get FPREG exponent
    3090/    3419 : B7                  	OR	A		; Is this number zero?
    3091/    341A : CA 9A 36            	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
    3092/    341D : 90                  	SUB	B		; BCDE number larger?
    3093/    341E : D2 2D 34            	JP	NC,NOSWAP	; No - Don't swap them
    3094/    3421 : 2F                  	CPL			; Two's complement
    3095/    3422 : 3C                  	INC	A		;	FP exponent
    3096/    3423 : EB                  	EX	DE,HL
    3097/    3424 : CD 8A 36            	CALL	STAKFP		; Put FPREG on stack
    3098/    3427 : EB                  	EX	DE,HL
    3099/    3428 : CD 9A 36            	CALL	FPBCDE		; Move BCDE to FPREG
    3100/    342B : C1                  	POP	BC		; Restore number from stack
    3101/    342C : D1                  	POP	DE
    3102/    342D : FE 19               NOSWAP: CP	24+1		; Second number insignificant?
    3103/    342F : D0                  	RET	NC		; Yes - First number is result
    3104/    3430 : F5                  	PUSH	AF		; Save number of bits to scale
    3105/    3431 : CD BF 36            	CALL	SIGNS		; Set MSBs & sign of result
    3106/    3434 : 67                  	LD	H,A		; Save sign of result
    3107/    3435 : F1                  	POP	AF		; Restore scaling factor
    3108/    3436 : CD D8 34            	CALL	SCALE		; Scale BCDE to same exponent
    3109/    3439 : B4                  	OR	H		; Result to be positive?
    3110/    343A : 21 29 C1            	LD	HL,FPREG	; Point to FPREG
    3111/    343D : F2 53 34            	JP	P,MINCDE	; No - Subtract FPREG from CDE
    3112/    3440 : CD B8 34            	CALL	PLUCDE		; Add FPREG to CDE
    3113/    3443 : D2 99 34            	JP	NC,RONDUP	; No overflow - Round it up
    3114/    3446 : 23                  	INC	HL		; Point to exponent
    3115/    3447 : 34                  	INC	(HL)		; Increment it
    3116/    3448 : CA C3 23            	JP	Z,OVERR		; Number overflowed - Error
    3117/    344B : 2E 01               	LD	L,1		; 1 bit to shift right
    3118/    344D : CD EE 34            	CALL	SHRT1		; Shift result right
    3119/    3450 : C3 99 34            	JP	RONDUP		; Round it up
    3120/    3453 :                     ;
    3121/    3453 : AF                  MINCDE: XOR	A		; Clear A and carry
    3122/    3454 : 90                  	SUB	B		; Negate exponent
    3123/    3455 : 47                  	LD	B,A		; Re-save exponent
    3124/    3456 : 7E                  	LD	A,(HL)		; Get LSB of FPREG
    3125/    3457 : 9B                  	SBC	A, E		; Subtract LSB of BCDE
    3126/    3458 : 5F                  	LD	E,A		; Save LSB of BCDE
    3127/    3459 : 23                  	INC	HL
    3128/    345A : 7E                  	LD	A,(HL)		; Get NMSB of FPREG
    3129/    345B : 9A                  	SBC	A,D		; Subtract NMSB of BCDE
    3130/    345C : 57                  	LD	D,A		; Save NMSB of BCDE
    3131/    345D : 23                  	INC	HL
    3132/    345E : 7E                  	LD	A,(HL)		; Get MSB of FPREG
    3133/    345F : 99                  	SBC	A,C		; Subtract MSB of BCDE
    3134/    3460 : 4F                  	LD	C,A		; Save MSB of BCDE
    3135/    3461 : DC C4 34            CONPOS: CALL	C,COMPL		; Overflow - Make it positive
    3136/    3464 :                     ;
    3137/    3464 : 68                  BNORM:	LD	L,B		; L = Exponent
    3138/    3465 : 63                  	LD	H,E		; H = LSB
    3139/    3466 : AF                  	XOR	A
    3140/    3467 : 47                  BNRMLP: LD	B,A		; Save bit count
    3141/    3468 : 79                  	LD	A,C		; Get MSB
    3142/    3469 : B7                  	OR	A		; Is it zero?
    3143/    346A : C2 86 34            	JP	NZ,PNORM	; No - Do it bit at a time
    3144/    346D : 4A                  	LD	C,D		; MSB = NMSB
    3145/    346E : 54                  	LD	D,H		; NMSB= LSB
    3146/    346F : 65                  	LD	H,L		; LSB = VLSB
    3147/    3470 : 6F                  	LD	L,A		; VLSB= 0
    3148/    3471 : 78                  	LD	A,B		; Get exponent
    3149/    3472 : D6 08               	SUB	8		; Count 8 bits
    3150/    3474 : FE E0               	CP	0E0H		; -24-8 Was number zero?
    3151/    3476 : C2 67 34            	JP	NZ,BNRMLP	; No - Keep normalising
    3152/    3479 : AF                  RESZER: XOR	A		; Result is zero
    3153/    347A : 32 2C C1            SAVEXP: LD	(FPEXP),A	; Save result as zero
    3154/    347D : C9                  	RET
    3155/    347E :                     ;
    3156/    347E : 05                  NORMAL: DEC	B		; Count bits
    3157/    347F : 29                  	ADD	HL,HL		; Shift HL left
    3158/    3480 : 7A                  	LD	A,D		; Get NMSB
    3159/    3481 : 17                  	RLA			; Shift left with last bit
    3160/    3482 : 57                  	LD	D,A		; Save NMSB
    3161/    3483 : 79                  	LD	A,C		; Get MSB
    3162/    3484 : 8F                  	ADC	A,A		; Shift left with last bit
    3163/    3485 : 4F                  	LD	C,A		; Save MSB
    3164/    3486 : F2 7E 34            PNORM:	JP	P,NORMAL	; Not done - Keep going
    3165/    3489 : 78                  	LD	A,B		; Number of bits shifted
    3166/    348A : 5C                  	LD	E,H		; Save HL in EB
    3167/    348B : 45                  	LD	B,L
    3168/    348C : B7                  	OR	A		; Any shifting done?
    3169/    348D : CA 99 34            	JP	Z,RONDUP	; No - Round it up
    3170/    3490 : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3171/    3493 : 86                  	ADD	A,(HL)		; Add shifted bits
    3172/    3494 : 77                  	LD	(HL),A		; Re-save exponent
    3173/    3495 : D2 79 34            	JP	NC,RESZER	; Underflow - Result is zero
    3174/    3498 : C8                  	RET	Z		; Result is zero
    3175/    3499 : 78                  RONDUP: LD	A,B		; Get VLSB of number
    3176/    349A : 21 2C C1            RONDB:	LD	HL,FPEXP	; Point to exponent
    3177/    349D : B7                  	OR	A		; Any rounding?
    3178/    349E : FC AB 34            	CALL	M,FPROND	; Yes - Round number up
    3179/    34A1 : 46                  	LD	B,(HL)		; B = Exponent
    3180/    34A2 : 23                  	INC	HL
    3181/    34A3 : 7E                  	LD	A,(HL)		; Get sign of result
    3182/    34A4 : E6 80               	AND	10000000B	; Only bit 7 needed
    3183/    34A6 : A9                  	XOR	C		; Set correct sign
    3184/    34A7 : 4F                  	LD	C,A		; Save correct sign in number
    3185/    34A8 : C3 9A 36            	JP	FPBCDE		; Move BCDE to FPREG
    3186/    34AB :                     ;
    3187/    34AB : 1C                  FPROND: INC	E		; Round LSB
    3188/    34AC : C0                  	RET	NZ		; Return if ok
    3189/    34AD : 14                  	INC	D		; Round NMSB
    3190/    34AE : C0                  	RET	NZ		; Return if ok
    3191/    34AF : 0C                  	INC	C		; Round MSB
    3192/    34B0 : C0                  	RET	NZ		; Return if ok
    3193/    34B1 : 0E 80               	LD	C,80H		; Set normal value
    3194/    34B3 : 34                  	INC	(HL)		; Increment exponent
    3195/    34B4 : C0                  	RET	NZ		; Return if ok
    3196/    34B5 : C3 C3 23            	JP	OVERR		; Overflow error
    3197/    34B8 :                     ;
    3198/    34B8 : 7E                  PLUCDE: LD	A,(HL)		; Get LSB of FPREG
    3199/    34B9 : 83                  	ADD	A,E		; Add LSB of BCDE
    3200/    34BA : 5F                  	LD	E,A		; Save LSB of BCDE
    3201/    34BB : 23                  	INC	HL
    3202/    34BC : 7E                  	LD	A,(HL)		; Get NMSB of FPREG
    3203/    34BD : 8A                  	ADC	A,D		; Add NMSB of BCDE
    3204/    34BE : 57                  	LD	D,A		; Save NMSB of BCDE
    3205/    34BF : 23                  	INC	HL
    3206/    34C0 : 7E                  	LD	A,(HL)		; Get MSB of FPREG
    3207/    34C1 : 89                  	ADC	A,C		; Add MSB of BCDE
    3208/    34C2 : 4F                  	LD	C,A		; Save MSB of BCDE
    3209/    34C3 : C9                  	RET
    3210/    34C4 :                     ;
    3211/    34C4 : 21 2D C1            COMPL:	LD	HL,SGNRES	; Sign of result
    3212/    34C7 : 7E                  	LD	A,(HL)		; Get sign of result
    3213/    34C8 : 2F                  	CPL			; Negate it
    3214/    34C9 : 77                  	LD	(HL),A		; Put it back
    3215/    34CA : AF                  	XOR	A
    3216/    34CB : 6F                  	LD	L,A		; Set L to zero
    3217/    34CC : 90                  	SUB	B		; Negate exponent,set carry
    3218/    34CD : 47                  	LD	B,A		; Re-save exponent
    3219/    34CE : 7D                  	LD	A,L		; Load zero
    3220/    34CF : 9B                  	SBC	A,E		; Negate LSB
    3221/    34D0 : 5F                  	LD	E,A		; Re-save LSB
    3222/    34D1 : 7D                  	LD	A,L		; Load zero
    3223/    34D2 : 9A                  	SBC	A,D		; Negate NMSB
    3224/    34D3 : 57                  	LD	D,A		; Re-save NMSB
    3225/    34D4 : 7D                  	LD	A,L		; Load zero
    3226/    34D5 : 99                  	SBC	A,C		; Negate MSB
    3227/    34D6 : 4F                  	LD	C,A		; Re-save MSB
    3228/    34D7 : C9                  	RET
    3229/    34D8 :                     ;
    3230/    34D8 : 06 00               SCALE:	LD	B,0		; Clear underflow
    3231/    34DA : D6 08               SCALLP: SUB	8		; 8 bits (a whole byte)?
    3232/    34DC : DA E7 34            	JP	C,SHRITE	; No - Shift right A bits
    3233/    34DF : 43                  	LD	B,E		; <- Shift
    3234/    34E0 : 5A                  	LD	E,D		; <- right
    3235/    34E1 : 51                  	LD	D,C		; <- eight
    3236/    34E2 : 0E 00               	LD	C,0		; <- bits
    3237/    34E4 : C3 DA 34            	JP	SCALLP		; More bits to shift
    3238/    34E7 :                     ;
    3239/    34E7 : C6 09               SHRITE: ADD	A,8+1		; Adjust count
    3240/    34E9 : 6F                  	LD	L,A		; Save bits to shift
    3241/    34EA : AF                  SHRLP:	XOR	A		; Flag for all done
    3242/    34EB : 2D                  	DEC	L		; All shifting done?
    3243/    34EC : C8                  	RET	Z		; Yes - Return
    3244/    34ED : 79                  	LD	A,C		; Get MSB
    3245/    34EE : 1F                  SHRT1:	RRA			; Shift it right
    3246/    34EF : 4F                  	LD	C,A		; Re-save
    3247/    34F0 : 7A                  	LD	A,D		; Get NMSB
    3248/    34F1 : 1F                  	RRA			; Shift right with last bit
    3249/    34F2 : 57                  	LD	D,A		; Re-save it
    3250/    34F3 : 7B                  	LD	A,E		; Get LSB
    3251/    34F4 : 1F                  	RRA			; Shift right with last bit
    3252/    34F5 : 5F                  	LD	E,A		; Re-save it
    3253/    34F6 : 78                  	LD	A,B		; Get underflow
    3254/    34F7 : 1F                  	RRA			; Shift right with last bit
    3255/    34F8 : 47                  	LD	B,A		; Re-save underflow
    3256/    34F9 : C3 EA 34            	JP	SHRLP		; More bits to do
    3257/    34FC :                     ;
    3258/    34FC : 00 00 00 81         UNITY:	DB	 000H,000H,000H,081H	; 1.00000
    3259/    3500 :                     ;
    3260/    3500 : 03                  LOGTAB: DB	3			; Table used by LOG
    3261/    3501 : AA 56 19 80         	DB	0AAH,056H,019H,080H	; 0.59898
    3262/    3505 : F1 22 76 80         	DB	0F1H,022H,076H,080H	; 0.96147
    3263/    3509 : 45 AA 38 82         	DB	045H,0AAH,038H,082H	; 2.88539
    3264/    350D :                     ;
    3265/    350D : CD 59 36            LOG:	CALL	TSTSGN		; Test sign of value
    3266/    3510 : B7                  	OR	A
    3267/    3511 : EA D1 28            	JP	PE,FCERR	; ?FC Error if <= zero
    3268/    3514 : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3269/    3517 : 7E                  	LD	A,(HL)		; Get exponent
    3270/    3518 : 01 35 80            	LD	BC,8035H	; BCDE = SQR(1/2)
    3271/    351B : 11 F3 04            	LD	DE,04F3H
    3272/    351E : 90                  	SUB	B		; Scale value to be < 1
    3273/    351F : F5                  	PUSH	AF		; Save scale factor
    3274/    3520 : 70                  	LD	(HL),B		; Save new exponent
    3275/    3521 : D5                  	PUSH	DE		; Save SQR(1/2)
    3276/    3522 : C5                  	PUSH	BC
    3277/    3523 : CD 13 34            	CALL	FPADD		; Add SQR(1/2) to value
    3278/    3526 : C1                  	POP	BC		; Restore SQR(1/2)
    3279/    3527 : D1                  	POP	DE
    3280/    3528 : 04                  	INC	B		; Make it SQR(2)
    3281/    3529 : CD AF 35            	CALL	DVBCDE		; Divide by SQR(2)
    3282/    352C : 21 FC 34            	LD	HL,UNITY	; Point to 1.
    3283/    352F : CD 0A 34            	CALL	SUBPHL		; Subtract FPREG from 1
    3284/    3532 : 21 00 35            	LD	HL,LOGTAB	; Coefficient table
    3285/    3535 : CD A1 39            	CALL	SUMSER		; Evaluate sum of series
    3286/    3538 : 01 80 80            	LD	BC,8080H	; BCDE = -0.5
    3287/    353B : 11 00 00            	LD	DE,0000H
    3288/    353E : CD 13 34            	CALL	FPADD		; Subtract 0.5 from FPREG
    3289/    3541 : F1                  	POP	AF		; Restore scale factor
    3290/    3542 : CD D4 37            	CALL	RSCALE		; Re-scale number
    3291/    3545 : 01 31 80            MULLN2: LD	BC,8031H	; BCDE = Ln(2)
    3292/    3548 : 11 18 72            	LD	DE,7218H
    3293/    354B : 21                  	DB	21H		; Skip "POP BC" and "POP DE"
    3294/    354C :                     ;
    3295/    354C : C1                  MULT:	POP	BC		; Get number from stack
    3296/    354D : D1                  	POP	DE
    3297/    354E : CD 59 36            FPMULT: CALL	TSTSGN		; Test sign of FPREG
    3298/    3551 : C8                  	RET	Z		; Return zero if zero
    3299/    3552 : 2E 00               	LD	L,0		; Flag add exponents
    3300/    3554 : CD 17 36            	CALL	ADDEXP		; Add exponents
    3301/    3557 : 79                  	LD	A,C		; Get MSB of multiplier
    3302/    3558 : 32 3B C1            	LD	(MULVAL),A	; Save MSB of multiplier
    3303/    355B : EB                  	EX	DE,HL
    3304/    355C : 22 3C C1            	LD	(MULVAL+1),HL	; Save rest of multiplier
    3305/    355F : 01 00 00            	LD	BC,0		; Partial product (BCDE) = zero
    3306/    3562 : 50                  	LD	D,B
    3307/    3563 : 58                  	LD	E,B
    3308/    3564 : 21 64 34            	LD	HL,BNORM	; Address of normalise
    3309/    3567 : E5                  	PUSH	HL		; Save for return
    3310/    3568 : 21 70 35            	LD	HL,MULT8	; Address of 8 bit multiply
    3311/    356B : E5                  	PUSH	HL		; Save for NMSB,MSB
    3312/    356C : E5                  	PUSH	HL		; 
    3313/    356D : 21 29 C1            	LD	HL,FPREG	; Point to number
    3314/    3570 : 7E                  MULT8:	LD	A,(HL)		; Get LSB of number
    3315/    3571 : 23                  	INC	HL		; Point to NMSB
    3316/    3572 : B7                  	OR	A		; Test LSB
    3317/    3573 : CA 9C 35            	JP	Z,BYTSFT	; Zero - shift to next byte
    3318/    3576 : E5                  	PUSH	HL		; Save address of number
    3319/    3577 : 2E 08               	LD	L,8		; 8 bits to multiply by
    3320/    3579 : 1F                  MUL8LP: RRA			; Shift LSB right
    3321/    357A : 67                  	LD	H,A		; Save LSB
    3322/    357B : 79                  	LD	A,C		; Get MSB
    3323/    357C : D2 8A 35            	JP	NC,NOMADD	; Bit was zero - Don't add
    3324/    357F : E5                  	PUSH	HL		; Save LSB and count
    3325/    3580 : 2A 3C C1            	LD	HL,(MULVAL+1)	; Get LSB and NMSB
    3326/    3583 : 19                  	ADD	HL,DE		; Add NMSB and LSB
    3327/    3584 : EB                  	EX	DE,HL		; Leave sum in DE
    3328/    3585 : E1                  	POP	HL		; Restore MSB and count
    3329/    3586 : 3A 3B C1            	LD	A,(MULVAL)	; Get MSB of multiplier
    3330/    3589 : 89                  	ADC	A,C		; Add MSB
    3331/    358A : 1F                  NOMADD: RRA			; Shift MSB right
    3332/    358B : 4F                  	LD	C,A		; Re-save MSB
    3333/    358C : 7A                  	LD	A,D		; Get NMSB
    3334/    358D : 1F                  	RRA			; Shift NMSB right
    3335/    358E : 57                  	LD	D,A		; Re-save NMSB
    3336/    358F : 7B                  	LD	A,E		; Get LSB
    3337/    3590 : 1F                  	RRA			; Shift LSB right
    3338/    3591 : 5F                  	LD	E,A		; Re-save LSB
    3339/    3592 : 78                  	LD	A,B		; Get VLSB
    3340/    3593 : 1F                  	RRA			; Shift VLSB right
    3341/    3594 : 47                  	LD	B,A		; Re-save VLSB
    3342/    3595 : 2D                  	DEC	L		; Count bits multiplied
    3343/    3596 : 7C                  	LD	A,H		; Get LSB of multiplier
    3344/    3597 : C2 79 35            	JP	NZ,MUL8LP	; More - Do it
    3345/    359A : E1                  POPHRT: POP	HL		; Restore address of number
    3346/    359B : C9                  	RET
    3347/    359C :                     ;
    3348/    359C : 43                  BYTSFT: LD	B,E		; Shift partial product left
    3349/    359D : 5A                  	LD	E,D
    3350/    359E : 51                  	LD	D,C
    3351/    359F : 4F                  	LD	C,A
    3352/    35A0 : C9                  	RET
    3353/    35A1 :                     ;
    3354/    35A1 : CD 8A 36            DIV10:	CALL	STAKFP		; Save FPREG on stack
    3355/    35A4 : 01 20 84            	LD	BC,8420H	; BCDE = 10.
    3356/    35A7 : 11 00 00            	LD	DE,0000H
    3357/    35AA : CD 9A 36            	CALL	FPBCDE		; Move 10 to FPREG
    3358/    35AD :                     ;
    3359/    35AD : C1                  DIV:	POP	BC		; Get number from stack
    3360/    35AE : D1                  	POP	DE
    3361/    35AF : CD 59 36            DVBCDE: CALL	TSTSGN		; Test sign of FPREG
    3362/    35B2 : CA B7 23            	JP	Z,DZERR		; Error if division by zero
    3363/    35B5 : 2E FF               	LD	L,-1		; Flag subtract exponents
    3364/    35B7 : CD 17 36            	CALL	ADDEXP		; Subtract exponents
    3365/    35BA : 34                  	INC	(HL)		; Add 2 to exponent to adjust
    3366/    35BB : 34                  	INC	(HL)
    3367/    35BC : 2B                  	DEC	HL		; Point to MSB
    3368/    35BD : 7E                  	LD	A,(HL)		; Get MSB of dividend
    3369/    35BE : 32 57 C0            	LD	(DIV3),A	; Save for subtraction
    3370/    35C1 : 2B                  	DEC	HL
    3371/    35C2 : 7E                  	LD	A,(HL)		; Get NMSB of dividend
    3372/    35C3 : 32 53 C0            	LD	(DIV2),A	; Save for subtraction
    3373/    35C6 : 2B                  	DEC	HL
    3374/    35C7 : 7E                  	LD	A,(HL)		; Get MSB of dividend
    3375/    35C8 : 32 4F C0            	LD	(DIV1),A	; Save for subtraction
    3376/    35CB : 41                  	LD	B,C		; Get MSB
    3377/    35CC : EB                  	EX	DE,HL		; NMSB,LSB to HL
    3378/    35CD : AF                  	XOR	A
    3379/    35CE : 4F                  	LD	C,A		; Clear MSB of quotient
    3380/    35CF : 57                  	LD	D,A		; Clear NMSB of quotient
    3381/    35D0 : 5F                  	LD	E,A		; Clear LSB of quotient
    3382/    35D1 : 32 5A C0            	LD	(DIV4),A	; Clear overflow count
    3383/    35D4 : E5                  DIVLP:	PUSH	HL		; Save divisor
    3384/    35D5 : C5                  	PUSH	BC
    3385/    35D6 : 7D                  	LD	A,L		; Get LSB of number
    3386/    35D7 : CD 4E C0            	CALL	DIVSUP		; Subt' divisor from dividend
    3387/    35DA : DE 00               	SBC	A,0		; Count for overflows
    3388/    35DC : 3F                  	CCF
    3389/    35DD : D2 E7 35            	JP	NC,RESDIV	; Restore divisor if borrow
    3390/    35E0 : 32 5A C0            	LD	(DIV4),A	; Re-save overflow count
    3391/    35E3 : F1                  	POP	AF		; Scrap divisor
    3392/    35E4 : F1                  	POP	AF
    3393/    35E5 : 37                  	SCF			; Set carry to
    3394/    35E6 : D2                  	DB	0D2H		; Skip "POP BC" and "POP HL"
    3395/    35E7 :                     ;
    3396/    35E7 : C1                  RESDIV: POP	BC		; Restore divisor
    3397/    35E8 : E1                  	POP	HL
    3398/    35E9 : 79                  	LD	A,C		; Get MSB of quotient
    3399/    35EA : 3C                  	INC	A
    3400/    35EB : 3D                  	DEC	A
    3401/    35EC : 1F                  	RRA			; Bit 0 to bit 7
    3402/    35ED : FA 9A 34            	JP	M,RONDB		; Done - Normalise result
    3403/    35F0 : 17                  	RLA			; Restore carry
    3404/    35F1 : 7B                  	LD	A,E		; Get LSB of quotient
    3405/    35F2 : 17                  	RLA			; Double it
    3406/    35F3 : 5F                  	LD	E,A		; Put it back
    3407/    35F4 : 7A                  	LD	A,D		; Get NMSB of quotient
    3408/    35F5 : 17                  	RLA			; Double it
    3409/    35F6 : 57                  	LD	D,A		; Put it back
    3410/    35F7 : 79                  	LD	A,C		; Get MSB of quotient
    3411/    35F8 : 17                  	RLA			; Double it
    3412/    35F9 : 4F                  	LD	C,A		; Put it back
    3413/    35FA : 29                  	ADD	HL,HL		; Double NMSB,LSB of divisor
    3414/    35FB : 78                  	LD	A,B		; Get MSB of divisor
    3415/    35FC : 17                  	RLA			; Double it
    3416/    35FD : 47                  	LD	B,A		; Put it back
    3417/    35FE : 3A 5A C0            	LD	A,(DIV4)	; Get VLSB of quotient
    3418/    3601 : 17                  	RLA			; Double it
    3419/    3602 : 32 5A C0            	LD	(DIV4),A	; Put it back
    3420/    3605 : 79                  	LD	A,C		; Get MSB of quotient
    3421/    3606 : B2                  	OR	D		; Merge NMSB
    3422/    3607 : B3                  	OR	E		; Merge LSB
    3423/    3608 : C2 D4 35            	JP	NZ,DIVLP	; Not done - Keep dividing
    3424/    360B : E5                  	PUSH	HL		; Save divisor
    3425/    360C : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3426/    360F : 35                  	DEC	(HL)		; Divide by 2
    3427/    3610 : E1                  	POP	HL		; Restore divisor
    3428/    3611 : C2 D4 35            	JP	NZ,DIVLP	; Ok - Keep going
    3429/    3614 : C3 C3 23            	JP	OVERR		; Overflow error
    3430/    3617 :                     ;
    3431/    3617 : 78                  ADDEXP: LD	A,B		; Get exponent of dividend
    3432/    3618 : B7                  	OR	A		; Test it
    3433/    3619 : CA 3B 36            	JP	Z,OVTST3	; Zero - Result zero
    3434/    361C : 7D                  	LD	A,L		; Get add/subtract flag
    3435/    361D : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3436/    3620 : AE                  	XOR	(HL)		; Add or subtract it
    3437/    3621 : 80                  	ADD	A,B		; Add the other exponent
    3438/    3622 : 47                  	LD	B,A		; Save new exponent
    3439/    3623 : 1F                  	RRA			; Test exponent for overflow
    3440/    3624 : A8                  	XOR	B
    3441/    3625 : 78                  	LD	A,B		; Get exponent
    3442/    3626 : F2 3A 36            	JP	P,OVTST2	; Positive - Test for overflow
    3443/    3629 : C6 80               	ADD	A,80H		; Add excess 128
    3444/    362B : 77                  	LD	(HL),A		; Save new exponent
    3445/    362C : CA 9A 35            	JP	Z,POPHRT	; Zero - Result zero
    3446/    362F : CD BF 36            	CALL	SIGNS		; Set MSBs and sign of result
    3447/    3632 : 77                  	LD	(HL),A		; Save new exponent
    3448/    3633 : 2B                  	DEC	HL		; Point to MSB
    3449/    3634 : C9                  	RET
    3450/    3635 :                     ;
    3451/    3635 : CD 59 36            OVTST1: CALL	TSTSGN		; Test sign of FPREG
    3452/    3638 : 2F                  	CPL			; Invert sign
    3453/    3639 : E1                  	POP	HL		; Clean up stack
    3454/    363A : B7                  OVTST2: OR	A		; Test if new exponent zero
    3455/    363B : E1                  OVTST3: POP	HL		; Clear off return address
    3456/    363C : F2 79 34            	JP	P,RESZER	; Result zero
    3457/    363F : C3 C3 23            	JP	OVERR		; Overflow error
    3458/    3642 :                     ;
    3459/    3642 : CD A5 36            MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
    3460/    3645 : 78                  	LD	A,B		; Get exponent
    3461/    3646 : B7                  	OR	A		; Is it zero?
    3462/    3647 : C8                  	RET	Z		; Yes - Result is zero
    3463/    3648 : C6 02               	ADD	A,2		; Multiply by 4
    3464/    364A : DA C3 23            	JP	C,OVERR		; Overflow - ?OV Error
    3465/    364D : 47                  	LD	B,A		; Re-save exponent
    3466/    364E : CD 13 34            	CALL	FPADD		; Add BCDE to FPREG (Times 5)
    3467/    3651 : 21 2C C1            	LD	HL,FPEXP	; Point to exponent
    3468/    3654 : 34                  	INC	(HL)		; Double number (Times 10)
    3469/    3655 : C0                  	RET	NZ		; Ok - Return
    3470/    3656 : C3 C3 23            	JP	OVERR		; Overflow error
    3471/    3659 :                     ;
    3472/    3659 : 3A 2C C1            TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
    3473/    365C : B7                  	OR	A
    3474/    365D : C8                  	RET	Z		; RETurn if number is zero
    3475/    365E : 3A 2B C1            	LD	A,(FPREG+2)	; Get MSB of FPREG
    3476/    3661 : FE                  	DB	0FEH		; Test sign
    3477/    3662 : 2F                  RETREL: CPL			; Invert sign
    3478/    3663 : 17                  	RLA			; Sign bit to carry
    3479/    3664 : 9F                  FLGDIF: SBC	A,A		; Carry to all bits of A
    3480/    3665 : C0                  	RET	NZ		; Return -1 if negative
    3481/    3666 : 3C                  	INC	A		; Bump to +1
    3482/    3667 : C9                  	RET			; Positive - Return +1
    3483/    3668 :                     ;
    3484/    3668 : CD 59 36            SGN:	CALL	TSTSGN		; Test sign of FPREG
    3485/    366B : 06 88               FLGREL: LD	B,80H+8		; 8 bit integer in exponent
    3486/    366D : 11 00 00            	LD	DE,0		; Zero NMSB and LSB
    3487/    3670 : 21 2C C1            RETINT: LD	HL,FPEXP	; Point to exponent
    3488/    3673 : 4F                  	LD	C,A		; CDE = MSB,NMSB and LSB
    3489/    3674 : 70                  	LD	(HL),B		; Save exponent
    3490/    3675 : 06 00               	LD	B,0		; CDE = integer to normalise
    3491/    3677 : 23                  	INC	HL		; Point to sign of result
    3492/    3678 : 36 80               	LD	(HL),80H	; Set sign of result
    3493/    367A : 17                  	RLA			; Carry = sign of integer
    3494/    367B : C3 61 34            	JP	CONPOS		; Set sign of result
    3495/    367E :                     ;
    3496/    367E : CD 59 36            ABS:	CALL	TSTSGN		; Test sign of FPREG
    3497/    3681 : F0                  	RET	P		; Return if positive
    3498/    3682 : 21 2B C1            INVSGN: LD	HL,FPREG+2	; Point to MSB
    3499/    3685 : 7E                  	LD	A,(HL)		; Get sign of mantissa
    3500/    3686 : EE 80               	XOR	80H		; Invert sign of mantissa
    3501/    3688 : 77                  	LD	(HL),A		; Re-save sign of mantissa
    3502/    3689 : C9                  	RET
    3503/    368A :                     ;
    3504/    368A : EB                  STAKFP: EX	DE,HL		; Save code string address
    3505/    368B : 2A 29 C1            	LD	HL,(FPREG)	; LSB,NLSB of FPREG
    3506/    368E : E3                  	EX	(SP),HL		; Stack them,get return
    3507/    368F : E5                  	PUSH	HL		; Re-save return
    3508/    3690 : 2A 2B C1            	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
    3509/    3693 : E3                  	EX	(SP),HL		; Stack them,get return
    3510/    3694 : E5                  	PUSH	HL		; Re-save return
    3511/    3695 : EB                  	EX	DE,HL		; Restore code string address
    3512/    3696 : C9                  	RET
    3513/    3697 :                     ;
    3514/    3697 : CD A8 36            PHLTFP: CALL	LOADFP		; Number at HL to BCDE
    3515/    369A : EB                  FPBCDE: EX	DE,HL		; Save code string address
    3516/    369B : 22 29 C1            	LD	(FPREG),HL	; Save LSB,NLSB of number
    3517/    369E : 60                  	LD	H,B		; Exponent of number
    3518/    369F : 69                  	LD	L,C		; MSB of number
    3519/    36A0 : 22 2B C1            	LD	(FPREG+2),HL	; Save MSB and exponent
    3520/    36A3 : EB                  	EX	DE,HL		; Restore code string address
    3521/    36A4 : C9                  	RET
    3522/    36A5 :                     ;
    3523/    36A5 : 21 29 C1            BCDEFP: LD	HL,FPREG	; Point to FPREG
    3524/    36A8 : 5E                  LOADFP: LD	E,(HL)		; Get LSB of number
    3525/    36A9 : 23                  	INC	HL
    3526/    36AA : 56                  	LD	D,(HL)		; Get NMSB of number
    3527/    36AB : 23                  	INC	HL
    3528/    36AC : 4E                  	LD	C,(HL)		; Get MSB of number
    3529/    36AD : 23                  	INC	HL
    3530/    36AE : 46                  	LD	B,(HL)		; Get exponent of number
    3531/    36AF : 23                  INCHL:	INC	HL		; Used for conditional "INC HL"
    3532/    36B0 : C9                  	RET
    3533/    36B1 :                     ;
    3534/    36B1 : 11 29 C1            FPTHL:	LD	DE,FPREG	; Point to FPREG
    3535/    36B4 : 06 04               DETHL4: LD	B,4		; 4 bytes to move
    3536/    36B6 : 1A                  DETHLB: LD	A,(DE)		; Get source
    3537/    36B7 : 77                  	LD	(HL),A		; Save destination
    3538/    36B8 : 13                  	INC	DE		; Next source
    3539/    36B9 : 23                  	INC	HL		; Next destination
    3540/    36BA : 05                  	DEC	B		; Count bytes
    3541/    36BB : C2 B6 36            	JP	NZ,DETHLB	; Loop if more
    3542/    36BE : C9                  	RET
    3543/    36BF :                     ;
    3544/    36BF : 21 2B C1            SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
    3545/    36C2 : 7E                  	LD	A,(HL)		; Get MSB
    3546/    36C3 : 07                  	RLCA			; Old sign to carry
    3547/    36C4 : 37                  	SCF			; Set MSBit
    3548/    36C5 : 1F                  	RRA			; Set MSBit of MSB
    3549/    36C6 : 77                  	LD	(HL),A		; Save new MSB
    3550/    36C7 : 3F                  	CCF			; Complement sign
    3551/    36C8 : 1F                  	RRA			; Old sign to carry
    3552/    36C9 : 23                  	INC	HL
    3553/    36CA : 23                  	INC	HL
    3554/    36CB : 77                  	LD	(HL),A		; Set sign of result
    3555/    36CC : 79                  	LD	A,C		; Get MSB
    3556/    36CD : 07                  	RLCA			; Old sign to carry
    3557/    36CE : 37                  	SCF			; Set MSBit
    3558/    36CF : 1F                  	RRA			; Set MSBit of MSB
    3559/    36D0 : 4F                  	LD	C,A		; Save MSB
    3560/    36D1 : 1F                  	RRA
    3561/    36D2 : AE                  	XOR	(HL)		; New sign of result
    3562/    36D3 : C9                  	RET
    3563/    36D4 :                     ;
    3564/    36D4 : 78                  CMPNUM: LD	A,B		; Get exponent of number
    3565/    36D5 : B7                  	OR	A
    3566/    36D6 : CA 59 36            	JP	Z,TSTSGN	; Zero - Test sign of FPREG
    3567/    36D9 : 21 62 36            	LD	HL,RETREL	; Return relation routine
    3568/    36DC : E5                  	PUSH	HL		; Save for return
    3569/    36DD : CD 59 36            	CALL	TSTSGN		; Test sign of FPREG
    3570/    36E0 : 79                  	LD	A,C		; Get MSB of number
    3571/    36E1 : C8                  	RET	Z		; FPREG zero - Number's MSB
    3572/    36E2 : 21 2B C1            	LD	HL,FPREG+2	; MSB of FPREG
    3573/    36E5 : AE                  	XOR	(HL)		; Combine signs
    3574/    36E6 : 79                  	LD	A,C		; Get MSB of number
    3575/    36E7 : F8                  	RET	M		; Exit if signs different
    3576/    36E8 : CD EE 36            	CALL	CMPFP		; Compare FP numbers
    3577/    36EB : 1F                  	RRA			; Get carry to sign
    3578/    36EC : A9                  	XOR	C		; Combine with MSB of number
    3579/    36ED : C9                  	RET
    3580/    36EE :                     ;
    3581/    36EE : 23                  CMPFP:	INC	HL		; Point to exponent
    3582/    36EF : 78                  	LD	A,B		; Get exponent
    3583/    36F0 : BE                  	CP	(HL)		; Compare exponents
    3584/    36F1 : C0                  	RET	NZ		; Different
    3585/    36F2 : 2B                  	DEC	HL		; Point to MBS
    3586/    36F3 : 79                  	LD	A,C		; Get MSB
    3587/    36F4 : BE                  	CP	(HL)		; Compare MSBs
    3588/    36F5 : C0                  	RET	NZ		; Different
    3589/    36F6 : 2B                  	DEC	HL		; Point to NMSB
    3590/    36F7 : 7A                  	LD	A,D		; Get NMSB
    3591/    36F8 : BE                  	CP	(HL)		; Compare NMSBs
    3592/    36F9 : C0                  	RET	NZ		; Different
    3593/    36FA : 2B                  	DEC	HL		; Point to LSB
    3594/    36FB : 7B                  	LD	A,E		; Get LSB
    3595/    36FC : 96                  	SUB	(HL)		; Compare LSBs
    3596/    36FD : C0                  	RET	NZ		; Different
    3597/    36FE : E1                  	POP	HL		; Drop RETurn
    3598/    36FF : E1                  	POP	HL		; Drop another RETurn
    3599/    3700 : C9                  	RET
    3600/    3701 :                     ;
    3601/    3701 : 47                  FPINT:	LD	B,A		; <- Move
    3602/    3702 : 4F                  	LD	C,A		; <- exponent
    3603/    3703 : 57                  	LD	D,A		; <- to all
    3604/    3704 : 5F                  	LD	E,A		; <- bits
    3605/    3705 : B7                  	OR	A		; Test exponent
    3606/    3706 : C8                  	RET	Z		; Zero - Return zero
    3607/    3707 : E5                  	PUSH	HL		; Save pointer to number
    3608/    3708 : CD A5 36            	CALL	BCDEFP		; Move FPREG to BCDE
    3609/    370B : CD BF 36            	CALL	SIGNS		; Set MSBs & sign of result
    3610/    370E : AE                  	XOR	(HL)		; Combine with sign of FPREG
    3611/    370F : 67                  	LD	H,A		; Save combined signs
    3612/    3710 : FC 25 37            	CALL	M,DCBCDE	; Negative - Decrement BCDE
    3613/    3713 : 3E 98               	LD	A,80H+24	; 24 bits
    3614/    3715 : 90                  	SUB	B		; Bits to shift
    3615/    3716 : CD D8 34            	CALL	SCALE		; Shift BCDE
    3616/    3719 : 7C                  	LD	A,H		; Get combined sign
    3617/    371A : 17                  	RLA			; Sign to carry
    3618/    371B : DC AB 34            	CALL	C,FPROND	; Negative - Round number up
    3619/    371E : 06 00               	LD	B,0		; Zero exponent
    3620/    3720 : DC C4 34            	CALL	C,COMPL		; If negative make positive
    3621/    3723 : E1                  	POP	HL		; Restore pointer to number
    3622/    3724 : C9                  	RET
    3623/    3725 :                     ;
    3624/    3725 : 1B                  DCBCDE: DEC	DE		; Decrement BCDE
    3625/    3726 : 7A                  	LD	A,D		; Test LSBs
    3626/    3727 : A3                  	AND	E
    3627/    3728 : 3C                  	INC	A
    3628/    3729 : C0                  	RET	NZ		; Exit if LSBs not FFFF
    3629/    372A : 0B                  	DEC	BC		; Decrement MSBs
    3630/    372B : C9                  	RET
    3631/    372C :                     ;
    3632/    372C : 21 2C C1            INT:	LD	HL,FPEXP	; Point to exponent
    3633/    372F : 7E                  	LD	A,(HL)		; Get exponent
    3634/    3730 : FE 98               	CP	80H+24		; Integer accuracy only?
    3635/    3732 : 3A 29 C1            	LD	A,(FPREG)	; Get LSB
    3636/    3735 : D0                  	RET	NC		; Yes - Already integer
    3637/    3736 : 7E                  	LD	A,(HL)		; Get exponent
    3638/    3737 : CD 01 37            	CALL	FPINT		; F.P to integer
    3639/    373A : 36 98               	LD	(HL),80H+24	; Save 24 bit integer
    3640/    373C : 7B                  	LD	A,E		; Get LSB of number
    3641/    373D : F5                  	PUSH	AF		; Save LSB
    3642/    373E : 79                  	LD	A,C		; Get MSB of number
    3643/    373F : 17                  	RLA			; Sign to carry
    3644/    3740 : CD 61 34            	CALL	CONPOS		; Set sign of result
    3645/    3743 : F1                  	POP	AF		; Restore LSB of number
    3646/    3744 : C9                  	RET
    3647/    3745 :                     ;
    3648/    3745 : 21 00 00            MLDEBC: LD	HL,0		; Clear partial product
    3649/    3748 : 78                  	LD	A,B		; Test multiplier
    3650/    3749 : B1                  	OR	C
    3651/    374A : C8                  	RET	Z		; Return zero if zero
    3652/    374B : 3E 10               	LD	A,16		; 16 bits
    3653/    374D : 29                  MLDBLP: ADD	HL,HL		; Shift P.P left
    3654/    374E : DA 85 2F            	JP	C,BSERR		; ?BS Error if overflow
    3655/    3751 : EB                  	EX	DE,HL
    3656/    3752 : 29                  	ADD	HL,HL		; Shift multiplier left
    3657/    3753 : EB                  	EX	DE,HL
    3658/    3754 : D2 5B 37            	JP	NC,NOMLAD	; Bit was zero - No add
    3659/    3757 : 09                  	ADD	HL,BC		; Add multiplicand
    3660/    3758 : DA 85 2F            	JP	C,BSERR		; ?BS Error if overflow
    3661/    375B : 3D                  NOMLAD: DEC	A		; Count bits
    3662/    375C : C2 4D 37            	JP	NZ,MLDBLP	; More
    3663/    375F : C9                  	RET
    3664/    3760 :                     ;
    3665/    3760 : FE 2D               ASCTFP: CP	'-'		; Negative?
    3666/    3762 : F5                  	PUSH	AF		; Save it and flags
    3667/    3763 : CA 6C 37            	JP	Z,CNVNUM	; Yes - Convert number
    3668/    3766 : FE 2B               	CP	'+'		; Positive?
    3669/    3768 : CA 6C 37            	JP	Z,CNVNUM	; Yes - Convert number
    3670/    376B : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3671/    376C : CD 79 34            CNVNUM: CALL	RESZER		; Set result to zero
    3672/    376F : 47                  	LD	B,A		; Digits after point counter
    3673/    3770 : 57                  	LD	D,A		; Sign of exponent
    3674/    3771 : 5F                  	LD	E,A		; Exponent of ten
    3675/    3772 : 2F                  	CPL
    3676/    3773 : 4F                  	LD	C,A		; Before or after point flag
    3677/    3774 : CD 0A 28            MANLP:	CALL	GETCHR		; Get next character
    3678/    3777 : DA BD 37            	JP	C,ADDIG		; Digit - Add to number
    3679/    377A : FE 2E               	CP	'.'
    3680/    377C : CA 98 37            	JP	Z,DPOINT	; '.' - Flag point
    3681/    377F : FE 45               	CP	'E'
    3682/    3781 : C2 9C 37            	JP	NZ,CONEXP	; Not 'E' - Scale number
    3683/    3784 : CD 0A 28            	CALL	GETCHR		; Get next character
    3684/    3787 : CD B0 2D            	CALL	SGNEXP		; Get sign of exponent
    3685/    378A : CD 0A 28            EXPLP:	CALL	GETCHR		; Get next character
    3686/    378D : DA DF 37            	JP	C,EDIGIT	; Digit - Add to exponent
    3687/    3790 : 14                  	INC	D		; Is sign negative?
    3688/    3791 : C2 9C 37            	JP	NZ,CONEXP	; No - Scale number
    3689/    3794 : AF                  	XOR	A
    3690/    3795 : 93                  	SUB	E		; Negate exponent
    3691/    3796 : 5F                  	LD	E,A		; And re-save it
    3692/    3797 : 0C                  	INC	C		; Flag end of number
    3693/    3798 : 0C                  DPOINT: INC	C		; Flag point passed
    3694/    3799 : CA 74 37            	JP	Z,MANLP		; Zero - Get another digit
    3695/    379C : E5                  CONEXP: PUSH	HL		; Save code string address
    3696/    379D : 7B                  	LD	A,E		; Get exponent
    3697/    379E : 90                  	SUB	B		; Subtract digits after point
    3698/    379F : F4 B5 37            SCALMI: CALL	P,SCALPL	; Positive - Multiply number
    3699/    37A2 : F2 AB 37            	JP	P,ENDCON	; Positive - All done
    3700/    37A5 : F5                  	PUSH	AF		; Save number of times to /10
    3701/    37A6 : CD A1 35            	CALL	DIV10		; Divide by 10
    3702/    37A9 : F1                  	POP	AF		; Restore count
    3703/    37AA : 3C                  	INC	A		; Count divides
    3704/    37AB :                     ;
    3705/    37AB : C2 9F 37            ENDCON: JP	NZ,SCALMI	; More to do
    3706/    37AE : D1                  	POP	DE		; Restore code string address
    3707/    37AF : F1                  	POP	AF		; Restore sign of number
    3708/    37B0 : CC 82 36            	CALL	Z,INVSGN	; Negative - Negate number
    3709/    37B3 : EB                  	EX	DE,HL		; Code string address to HL
    3710/    37B4 : C9                  	RET
    3711/    37B5 :                     ;
    3712/    37B5 : C8                  SCALPL: RET	Z		; Exit if no scaling needed
    3713/    37B6 : F5                  MULTEN: PUSH	AF		; Save count
    3714/    37B7 : CD 42 36            	CALL	MLSP10		; Multiply number by 10
    3715/    37BA : F1                  	POP	AF		; Restore count
    3716/    37BB : 3D                  	DEC	A		; Count multiplies
    3717/    37BC : C9                  	RET
    3718/    37BD :                     ;
    3719/    37BD : D5                  ADDIG:	PUSH	DE		; Save sign of exponent
    3720/    37BE : 57                  	LD	D,A		; Save digit
    3721/    37BF : 78                  	LD	A,B		; Get digits after point
    3722/    37C0 : 89                  	ADC	A,C		; Add one if after point
    3723/    37C1 : 47                  	LD	B,A		; Re-save counter
    3724/    37C2 : C5                  	PUSH	BC		; Save point flags
    3725/    37C3 : E5                  	PUSH	HL		; Save code string address
    3726/    37C4 : D5                  	PUSH	DE		; Save digit
    3727/    37C5 : CD 42 36            	CALL	MLSP10		; Multiply number by 10
    3728/    37C8 : F1                  	POP	AF		; Restore digit
    3729/    37C9 : D6 30               	SUB	'0'		; Make it absolute
    3730/    37CB : CD D4 37            	CALL	RSCALE		; Re-scale number
    3731/    37CE : E1                  	POP	HL		; Restore code string address
    3732/    37CF : C1                  	POP	BC		; Restore point flags
    3733/    37D0 : D1                  	POP	DE		; Restore sign of exponent
    3734/    37D1 : C3 74 37            	JP	MANLP		; Get another digit
    3735/    37D4 :                     ;
    3736/    37D4 : CD 8A 36            RSCALE: CALL	STAKFP		; Put number on stack
    3737/    37D7 : CD 6B 36            	CALL	FLGREL		; Digit to add to FPREG
    3738/    37DA : C1                  PADD:	POP	BC		; Restore number
    3739/    37DB : D1                  	POP	DE
    3740/    37DC : C3 13 34            	JP	FPADD		; Add BCDE to FPREG and return
    3741/    37DF :                     ;
    3742/    37DF : 7B                  EDIGIT: LD	A,E		; Get digit
    3743/    37E0 : 07                  	RLCA			; Times 2
    3744/    37E1 : 07                  	RLCA			; Times 4
    3745/    37E2 : 83                  	ADD	A,E		; Times 5
    3746/    37E3 : 07                  	RLCA			; Times 10
    3747/    37E4 : 86                  	ADD	A,(HL)		; Add next digit
    3748/    37E5 : D6 30               	SUB	'0'		; Make it absolute
    3749/    37E7 : 5F                  	LD	E,A		; Save new digit
    3750/    37E8 : C3 8A 37            	JP	EXPLP		; Look for another digit
    3751/    37EB :                     ;
    3752/    37EB : E5                  LINEIN: PUSH	HL		; Save code string address
    3753/    37EC : 21 4C 23            	LD	HL,INMSG	; Output " in "
    3754/    37EF : CD 50 31            	CALL	PRS		; Output string at HL
    3755/    37F2 : E1                  	POP	HL		; Restore code string address
    3756/    37F3 : EB                  PRNTHL: EX	DE,HL		; Code string address to DE
    3757/    37F4 : AF                  	XOR	A
    3758/    37F5 : 06 98               	LD	B,80H+24	; 24 bits
    3759/    37F7 : CD 70 36            	CALL	RETINT		; Return the integer
    3760/    37FA : 21 4F 31            	LD	HL,PRNUMS	; Print number string
    3761/    37FD : E5                  	PUSH	HL		; Save for return
    3762/    37FE : 21 2E C1            NUMASC: LD	HL,PBUFF	; Convert number to ASCII
    3763/    3801 : E5                  	PUSH	HL		; Save for return
    3764/    3802 : CD 59 36            	CALL	TSTSGN		; Test sign of FPREG
    3765/    3805 : 36 20               	LD	(HL),' '	; Space at start
    3766/    3807 : F2 0C 38            	JP	P,SPCFST	; Positive - Space to start
    3767/    380A : 36 2D               	LD	(HL),'-'	; '-' sign at start
    3768/    380C : 23                  SPCFST: INC	HL		; First byte of number
    3769/    380D : 36 30               	LD	(HL),'0'	; '0' if zero
    3770/    380F : CA C2 38            	JP	Z,JSTZER	; Return '0' if zero
    3771/    3812 : E5                  	PUSH	HL		; Save buffer address
    3772/    3813 : FC 82 36            	CALL	M,INVSGN	; Negate FPREG if negative
    3773/    3816 : AF                  	XOR	A		; Zero A
    3774/    3817 : F5                  	PUSH	AF		; Save it
    3775/    3818 : CD C8 38            	CALL	RNGTST		; Test number is in range
    3776/    381B : 01 43 91            SIXDIG: LD	BC,9143H	; BCDE - 99999.9
    3777/    381E : 11 F8 4F            	LD	DE,4FF8H
    3778/    3821 : CD D4 36            	CALL	CMPNUM		; Compare numbers
    3779/    3824 : B7                  	OR	A
    3780/    3825 : E2 39 38            	JP	PO,INRNG	; > 99999.9 - Sort it out
    3781/    3828 : F1                  	POP	AF		; Restore count
    3782/    3829 : CD B6 37            	CALL	MULTEN		; Multiply by ten
    3783/    382C : F5                  	PUSH	AF		; Re-save count
    3784/    382D : C3 1B 38            	JP	SIXDIG		; Test it again
    3785/    3830 :                     ;
    3786/    3830 : CD A1 35            GTSIXD: CALL	DIV10		; Divide by 10
    3787/    3833 : F1                  	POP	AF		; Get count
    3788/    3834 : 3C                  	INC	A		; Count divides
    3789/    3835 : F5                  	PUSH	AF		; Re-save count
    3790/    3836 : CD C8 38            	CALL	RNGTST		; Test number is in range
    3791/    3839 : CD 01 34            INRNG:	CALL	ROUND		; Add 0.5 to FPREG
    3792/    383C : 3C                  	INC	A
    3793/    383D : CD 01 37            	CALL	FPINT		; F.P to integer
    3794/    3840 : CD 9A 36            	CALL	FPBCDE		; Move BCDE to FPREG
    3795/    3843 : 01 06 03            	LD	BC,0306H	; 1E+06 to 1E-03 range
    3796/    3846 : F1                  	POP	AF		; Restore count
    3797/    3847 : 81                  	ADD	A,C		; 6 digits before point
    3798/    3848 : 3C                  	INC	A		; Add one
    3799/    3849 : FA 55 38            	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
    3800/    384C : FE 08               	CP	6+1+1		; More than 999999 ?
    3801/    384E : D2 55 38            	JP	NC,MAKNUM	; Yes - Do it in 'E' form
    3802/    3851 : 3C                  	INC	A		; Adjust for exponent
    3803/    3852 : 47                  	LD	B,A		; Exponent of number
    3804/    3853 : 3E 02               	LD	A,2		; Make it zero after
    3805/    3855 :                     ;
    3806/    3855 : 3D                  MAKNUM: DEC	A		; Adjust for digits to do
    3807/    3856 : 3D                  	DEC	A
    3808/    3857 : E1                  	POP	HL		; Restore buffer address
    3809/    3858 : F5                  	PUSH	AF		; Save count
    3810/    3859 : 11 DB 38            	LD	DE,POWERS	; Powers of ten
    3811/    385C : 05                  	DEC	B		; Count digits before point
    3812/    385D : C2 66 38            	JP	NZ,DIGTXT	; Not zero - Do number
    3813/    3860 : 36 2E               	LD	(HL),'.'	; Save point
    3814/    3862 : 23                  	INC	HL		; Move on
    3815/    3863 : 36 30               	LD	(HL),'0'	; Save zero
    3816/    3865 : 23                  	INC	HL		; Move on
    3817/    3866 : 05                  DIGTXT: DEC	B		; Count digits before point
    3818/    3867 : 36 2E               	LD	(HL),'.'	; Save point in case
    3819/    3869 : CC AF 36            	CALL	Z,INCHL		; Last digit - move on
    3820/    386C : C5                  	PUSH	BC		; Save digits before point
    3821/    386D : E5                  	PUSH	HL		; Save buffer address
    3822/    386E : D5                  	PUSH	DE		; Save powers of ten
    3823/    386F : CD A5 36            	CALL	BCDEFP		; Move FPREG to BCDE
    3824/    3872 : E1                  	POP	HL		; Powers of ten table
    3825/    3873 : 06 2F               	LD	B, '0'-1	; ASCII '0' - 1
    3826/    3875 : 04                  TRYAGN: INC	B		; Count subtractions
    3827/    3876 : 7B                  	LD	A,E		; Get LSB
    3828/    3877 : 96                  	SUB	(HL)		; Subtract LSB
    3829/    3878 : 5F                  	LD	E,A		; Save LSB
    3830/    3879 : 23                  	INC	HL
    3831/    387A : 7A                  	LD	A,D		; Get NMSB
    3832/    387B : 9E                  	SBC	A,(HL)		; Subtract NMSB
    3833/    387C : 57                  	LD	D,A		; Save NMSB
    3834/    387D : 23                  	INC	HL
    3835/    387E : 79                  	LD	A,C		; Get MSB
    3836/    387F : 9E                  	SBC	A,(HL)		; Subtract MSB
    3837/    3880 : 4F                  	LD	C,A		; Save MSB
    3838/    3881 : 2B                  	DEC	HL		; Point back to start
    3839/    3882 : 2B                  	DEC	HL
    3840/    3883 : D2 75 38            	JP	NC,TRYAGN	; No overflow - Try again
    3841/    3886 : CD B8 34            	CALL	PLUCDE		; Restore number
    3842/    3889 : 23                  	INC	HL		; Start of next number
    3843/    388A : CD 9A 36            	CALL	FPBCDE		; Move BCDE to FPREG
    3844/    388D : EB                  	EX	DE,HL		; Save point in table
    3845/    388E : E1                  	POP	HL		; Restore buffer address
    3846/    388F : 70                  	LD	(HL),B		; Save digit in buffer
    3847/    3890 : 23                  	INC	HL		; And move on
    3848/    3891 : C1                  	POP	BC		; Restore digit count
    3849/    3892 : 0D                  	DEC	C		; Count digits
    3850/    3893 : C2 66 38            	JP	NZ,DIGTXT	; More - Do them
    3851/    3896 : 05                  	DEC	B		; Any decimal part?
    3852/    3897 : CA A6 38            	JP	Z,DOEBIT	; No - Do 'E' bit
    3853/    389A : 2B                  SUPTLZ: DEC	HL		; Move back through buffer
    3854/    389B : 7E                  	LD	A,(HL)		; Get character
    3855/    389C : FE 30               	CP	'0'		; '0' character?
    3856/    389E : CA 9A 38            	JP	Z,SUPTLZ	; Yes - Look back for more
    3857/    38A1 : FE 2E               	CP	'.'		; A decimal point?
    3858/    38A3 : C4 AF 36            	CALL	NZ,INCHL	; Move back over digit
    3859/    38A6 :                     ;
    3860/    38A6 : F1                  DOEBIT: POP	AF		; Get 'E' flag
    3861/    38A7 : CA C5 38            	JP	Z,NOENED	; No 'E' needed - End buffer
    3862/    38AA : 36 45               	LD	(HL),'E'	; Put 'E' in buffer
    3863/    38AC : 23                  	INC	HL		; And move on
    3864/    38AD : 36 2B               	LD	(HL),'+'	; Put '+' in buffer
    3865/    38AF : F2 B6 38            	JP	P,OUTEXP	; Positive - Output exponent
    3866/    38B2 : 36 2D               	LD	(HL),'-'	; Put '-' in buffer
    3867/    38B4 : 2F                  	CPL			; Negate exponent
    3868/    38B5 : 3C                  	INC	A
    3869/    38B6 : 06 2F               OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
    3870/    38B8 : 04                  EXPTEN: INC	B		; Count subtractions
    3871/    38B9 : D6 0A               	SUB	10		; Tens digit
    3872/    38BB : D2 B8 38            	JP	NC,EXPTEN	; More to do
    3873/    38BE : C6 3A               	ADD	A,'0'+10	; Restore and make ASCII
    3874/    38C0 : 23                  	INC	HL		; Move on
    3875/    38C1 : 70                  	LD	(HL),B		; Save MSB of exponent
    3876/    38C2 : 23                  JSTZER: INC	HL		;
    3877/    38C3 : 77                  	LD	(HL),A		; Save LSB of exponent
    3878/    38C4 : 23                  	INC	HL
    3879/    38C5 : 71                  NOENED: LD	(HL),C		; Mark end of buffer
    3880/    38C6 : E1                  	POP	HL		; Restore code string address
    3881/    38C7 : C9                  	RET
    3882/    38C8 :                     ;
    3883/    38C8 : 01 74 94            RNGTST: LD	BC,9474H	; BCDE = 999999.
    3884/    38CB : 11 F7 23            	LD	DE,23F7H
    3885/    38CE : CD D4 36            	CALL	CMPNUM		; Compare numbers
    3886/    38D1 : B7                  	OR	A
    3887/    38D2 : E1                  	POP	HL		; Return address to HL
    3888/    38D3 : E2 30 38            	JP	PO,GTSIXD	; Too big - Divide by ten
    3889/    38D6 : E9                  	JP	(HL)		; Otherwise return to caller
    3890/    38D7 :                     ;
    3891/    38D7 : 00 00 00 80         HALF:	DB	00H,00H,00H,80H	; 0.5
    3892/    38DB :                     ;
    3893/    38DB : A0 86 01            POWERS: DB	0A0H,086H,001H	; 100000
    3894/    38DE : 10 27 00            	DB	010H,027H,000H	; 10000
    3895/    38E1 : E8 03 00            	DB	0E8H,003H,000H	; 1000
    3896/    38E4 : 64 00 00            	DB	064H,000H,000H	; 100
    3897/    38E7 : 0A 00 00            	DB	00AH,000H,000H	; 10
    3898/    38EA : 01 00 00            	DB	001H,000H,000H	; 1
    3899/    38ED :                     ;
    3900/    38ED : 21 82 36            NEGAFT: LD	HL,INVSGN	; Negate result
    3901/    38F0 : E3                  	EX	(SP),HL		; To be done after caller
    3902/    38F1 : E9                  	JP	(HL)		; Return to caller
    3903/    38F2 :                     ;
    3904/    38F2 : CD 8A 36            SQR:	CALL	STAKFP		; Put value on stack
    3905/    38F5 : 21 D7 38            	LD	HL,HALF		; Set power to 1/2
    3906/    38F8 : CD 97 36            	CALL	PHLTFP		; Move 1/2 to FPREG
    3907/    38FB :                     ;
    3908/    38FB : C1                  POWER:	POP	BC		; Get base
    3909/    38FC : D1                  	POP	DE
    3910/    38FD : CD 59 36            	CALL	TSTSGN		; Test sign of power
    3911/    3900 : 78                  	LD	A,B		; Get exponent of base
    3912/    3901 : CA 40 39            	JP	Z,EXP		; Make result 1 if zero
    3913/    3904 : F2 0B 39            	JP	P,POWER1	; Positive base - Ok
    3914/    3907 : B7                  	OR	A		; Zero to negative power?
    3915/    3908 : CA B7 23            	JP	Z,DZERR		; Yes - ?/0 Error
    3916/    390B : B7                  POWER1: OR	A		; Base zero?
    3917/    390C : CA 7A 34            	JP	Z,SAVEXP	; Yes - Return zero
    3918/    390F : D5                  	PUSH	DE		; Save base
    3919/    3910 : C5                  	PUSH	BC
    3920/    3911 : 79                  	LD	A,C		; Get MSB of base
    3921/    3912 : F6 7F               	OR	01111111B	; Get sign status
    3922/    3914 : CD A5 36            	CALL	BCDEFP		; Move power to BCDE
    3923/    3917 : F2 28 39            	JP	P,POWER2	; Positive base - Ok
    3924/    391A : D5                  	PUSH	DE		; Save power
    3925/    391B : C5                  	PUSH	BC
    3926/    391C : CD 2C 37            	CALL	INT		; Get integer of power
    3927/    391F : C1                  	POP	BC		; Restore power
    3928/    3920 : D1                  	POP	DE
    3929/    3921 : F5                  	PUSH	AF		; MSB of base
    3930/    3922 : CD D4 36            	CALL	CMPNUM		; Power an integer?
    3931/    3925 : E1                  	POP	HL		; Restore MSB of base
    3932/    3926 : 7C                  	LD	A,H		; but don't affect flags
    3933/    3927 : 1F                  	RRA			; Exponent odd or even?
    3934/    3928 : E1                  POWER2: POP	HL		; Restore MSB and exponent
    3935/    3929 : 22 2B C1            	LD	(FPREG+2),HL	; Save base in FPREG
    3936/    392C : E1                  	POP	HL		; LSBs of base
    3937/    392D : 22 29 C1            	LD	(FPREG),HL	; Save in FPREG
    3938/    3930 : DC ED 38            	CALL	C,NEGAFT	; Odd power - Negate result
    3939/    3933 : CC 82 36            	CALL	Z,INVSGN	; Negative base - Negate it
    3940/    3936 : D5                  	PUSH	DE		; Save power
    3941/    3937 : C5                  	PUSH	BC
    3942/    3938 : CD 0D 35            	CALL	LOG		; Get LOG of base
    3943/    393B : C1                  	POP	BC		; Restore power
    3944/    393C : D1                  	POP	DE
    3945/    393D : CD 4E 35            	CALL	FPMULT		; Multiply LOG by power
    3946/    3940 :                     ;
    3947/    3940 : CD 8A 36            EXP:	CALL	STAKFP		; Put value on stack
    3948/    3943 : 01 38 81            	LD	BC,08138H	; BCDE = 1/Ln(2)
    3949/    3946 : 11 3B AA            	LD	DE,0AA3BH
    3950/    3949 : CD 4E 35            	CALL	FPMULT		; Multiply value by 1/LN(2)
    3951/    394C : 3A 2C C1            	LD	A,(FPEXP)	; Get exponent
    3952/    394F : FE 88               	CP	80H+8		; Is it in range?
    3953/    3951 : D2 35 36            	JP	NC,OVTST1	; No - Test for overflow
    3954/    3954 : CD 2C 37            	CALL	INT		; Get INT of FPREG
    3955/    3957 : C6 80               	ADD	A,80H		; For excess 128
    3956/    3959 : C6 02               	ADD	A,2		; Exponent > 126?
    3957/    395B : DA 35 36            	JP	C,OVTST1	; Yes - Test for overflow
    3958/    395E : F5                  	PUSH	AF		; Save scaling factor
    3959/    395F : 21 FC 34            	LD	HL,UNITY	; Point to 1.
    3960/    3962 : CD 04 34            	CALL	ADDPHL		; Add 1 to FPREG
    3961/    3965 : CD 45 35            	CALL	MULLN2		; Multiply by LN(2)
    3962/    3968 : F1                  	POP	AF		; Restore scaling factor
    3963/    3969 : C1                  	POP	BC		; Restore exponent
    3964/    396A : D1                  	POP	DE
    3965/    396B : F5                  	PUSH	AF		; Save scaling factor
    3966/    396C : CD 10 34            	CALL	SUBCDE		; Subtract exponent from FPREG
    3967/    396F : CD 82 36            	CALL	INVSGN		; Negate result
    3968/    3972 : 21 80 39            	LD	HL,EXPTAB	; Coefficient table
    3969/    3975 : CD B0 39            	CALL	SMSER1		; Sum the series
    3970/    3978 : 11 00 00            	LD	DE,0		; Zero LSBs
    3971/    397B : C1                  	POP	BC		; Scaling factor
    3972/    397C : 4A                  	LD	C,D		; Zero MSB
    3973/    397D : C3 4E 35            	JP	FPMULT		; Scale result to correct value
    3974/    3980 :                     ;
    3975/    3980 : 08                  EXPTAB: DB	8			; Table used by EXP
    3976/    3981 : 40 2E 94 74         	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
    3977/    3985 : 70 4F 2E 77         	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
    3978/    3989 : 6E 02 88 7A         	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
    3979/    398D : E6 A0 2A 7C         	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
    3980/    3991 : 50 AA AA 7E         	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
    3981/    3995 : FF FF 7F 7F         	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
    3982/    3999 : 00 00 80 81         	DB	000H,000H,080H,081H	; -1/1! (-1/1)
    3983/    399D : 00 00 00 81         	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
    3984/    39A1 :                     ;
    3985/    39A1 : CD 8A 36            SUMSER: CALL	STAKFP		; Put FPREG on stack
    3986/    39A4 : 11 4C 35            	LD	DE,MULT		; Multiply by "X"
    3987/    39A7 : D5                  	PUSH	DE		; To be done after
    3988/    39A8 : E5                  	PUSH	HL		; Save address of table
    3989/    39A9 : CD A5 36            	CALL	BCDEFP		; Move FPREG to BCDE
    3990/    39AC : CD 4E 35            	CALL	FPMULT		; Square the value
    3991/    39AF : E1                  	POP	HL		; Restore address of table
    3992/    39B0 : CD 8A 36            SMSER1: CALL	STAKFP		; Put value on stack
    3993/    39B3 : 7E                  	LD	A,(HL)		; Get number of coefficients
    3994/    39B4 : 23                  	INC	HL		; Point to start of table
    3995/    39B5 : CD 97 36            	CALL	PHLTFP		; Move coefficient to FPREG
    3996/    39B8 : 06                  	DB	06H		; Skip "POP AF"
    3997/    39B9 : F1                  SUMLP:	POP	AF		; Restore count
    3998/    39BA : C1                  	POP	BC		; Restore number
    3999/    39BB : D1                  	POP	DE
    4000/    39BC : 3D                  	DEC	A		; Cont coefficients
    4001/    39BD : C8                  	RET	Z		; All done
    4002/    39BE : D5                  	PUSH	DE		; Save number
    4003/    39BF : C5                  	PUSH	BC
    4004/    39C0 : F5                  	PUSH	AF		; Save count
    4005/    39C1 : E5                  	PUSH	HL		; Save address in table
    4006/    39C2 : CD 4E 35            	CALL	FPMULT		; Multiply FPREG by BCDE
    4007/    39C5 : E1                  	POP	HL		; Restore address in table
    4008/    39C6 : CD A8 36            	CALL	LOADFP		; Number at HL to BCDE
    4009/    39C9 : E5                  	PUSH	HL		; Save address in table
    4010/    39CA : CD 13 34            	CALL	FPADD		; Add coefficient to FPREG
    4011/    39CD : E1                  	POP	HL		; Restore address in table
    4012/    39CE : C3 B9 39            	JP	SUMLP		; More coefficients
    4013/    39D1 :                     ;
    4014/    39D1 : CD 59 36            RND:	CALL	TSTSGN		; Test sign of FPREG
    4015/    39D4 : 21 5E C0            	LD	HL,SEED+2	; Random number seed
    4016/    39D7 : FA 32 3A            	JP	M,RESEED	; Negative - Re-seed
    4017/    39DA : 21 7F C0            	LD	HL,LSTRND	; Last random number
    4018/    39DD : CD 97 36            	CALL	PHLTFP		; Move last RND to FPREG
    4019/    39E0 : 21 5E C0            	LD	HL,SEED+2	; Random number seed
    4020/    39E3 : C8                  	RET	Z		; Return if RND(0)
    4021/    39E4 : 86                  	ADD	A,(HL)		; Add (SEED)+2)
    4022/    39E5 : E6 07               	AND	00000111B	; 0 to 7
    4023/    39E7 : 06 00               	LD	B,0
    4024/    39E9 : 77                  	LD	(HL),A		; Re-save seed
    4025/    39EA : 23                  	INC	HL		; Move to coefficient table
    4026/    39EB : 87                  	ADD	A,A		; 4 bytes
    4027/    39EC : 87                  	ADD	A,A		; per entry
    4028/    39ED : 4F                  	LD	C,A		; BC = Offset into table
    4029/    39EE : 09                  	ADD	HL,BC		; Point to coefficient
    4030/    39EF : CD A8 36            	CALL	LOADFP		; Coefficient to BCDE
    4031/    39F2 : CD 4E 35            	CALL	FPMULT	;	; Multiply FPREG by coefficient
    4032/    39F5 : 3A 5D C0            	LD	A,(SEED+1)	; Get (SEED+1)
    4033/    39F8 : 3C                  	INC	A		; Add 1
    4034/    39F9 : E6 03               	AND	00000011B	; 0 to 3
    4035/    39FB : 06 00               	LD	B,0
    4036/    39FD : FE 01               	CP	1		; Is it zero?
    4037/    39FF : 88                  	ADC	A,B		; Yes - Make it 1
    4038/    3A00 : 32 5D C0            	LD	(SEED+1),A	; Re-save seed
    4039/    3A03 : 21 36 3A            	LD	HL,RNDTAB-4	; Addition table
    4040/    3A06 : 87                  	ADD	A,A		; 4 bytes
    4041/    3A07 : 87                  	ADD	A,A		; per entry
    4042/    3A08 : 4F                  	LD	C,A		; BC = Offset into table
    4043/    3A09 : 09                  	ADD	HL,BC		; Point to value
    4044/    3A0A : CD 04 34            	CALL	ADDPHL		; Add value to FPREG
    4045/    3A0D : CD A5 36            RND1:	CALL	BCDEFP		; Move FPREG to BCDE
    4046/    3A10 : 7B                  	LD	A,E		; Get LSB
    4047/    3A11 : 59                  	LD	E,C		; LSB = MSB
    4048/    3A12 : EE 4F               	XOR	01001111B	; Fiddle around
    4049/    3A14 : 4F                  	LD	C,A		; New MSB
    4050/    3A15 : 36 80               	LD	(HL),80H	; Set exponent
    4051/    3A17 : 2B                  	DEC	HL		; Point to MSB
    4052/    3A18 : 46                  	LD	B,(HL)		; Get MSB
    4053/    3A19 : 36 80               	LD	(HL),80H	; Make value -0.5
    4054/    3A1B : 21 5C C0            	LD	HL,SEED		; Random number seed
    4055/    3A1E : 34                  	INC	(HL)		; Count seed
    4056/    3A1F : 7E                  	LD	A,(HL)		; Get seed
    4057/    3A20 : D6 AB               	SUB	171		; Do it modulo 171
    4058/    3A22 : C2 29 3A            	JP	NZ,RND2		; Non-zero - Ok
    4059/    3A25 : 77                  	LD	(HL),A		; Zero seed
    4060/    3A26 : 0C                  	INC	C		; Fillde about
    4061/    3A27 : 15                  	DEC	D		; with the
    4062/    3A28 : 1C                  	INC	E		; number
    4063/    3A29 : CD 64 34            RND2:	CALL	BNORM		; Normalise number
    4064/    3A2C : 21 7F C0            	LD	HL,LSTRND	; Save random number
    4065/    3A2F : C3 B1 36            	JP	FPTHL		; Move FPREG to last and return
    4066/    3A32 :                     ;
    4067/    3A32 : 77                  RESEED: LD	(HL),A		; Re-seed random numbers
    4068/    3A33 : 2B                  	DEC	HL
    4069/    3A34 : 77                  	LD	(HL),A
    4070/    3A35 : 2B                  	DEC	HL
    4071/    3A36 : 77                  	LD	(HL),A
    4072/    3A37 : C3 0D 3A            	JP	RND1		; Return RND seed
    4073/    3A3A :                     ;
    4074/    3A3A : 68 B1 46 68         RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
    4075/    3A3E : 99 E9 92 69         	DB	099H,0E9H,092H,069H
    4076/    3A42 : 10 D1 75 68         	DB	010H,0D1H,075H,068H
    4077/    3A46 :                     ;
    4078/    3A46 : 21 90 3A            COS:	LD	HL,HALFPI	; Point to PI/2
    4079/    3A49 : CD 04 34            	CALL	ADDPHL		; Add it to PPREG
    4080/    3A4C : CD 8A 36            SIN:	CALL	STAKFP		; Put angle on stack
    4081/    3A4F : 01 49 83            	LD	BC,8349H	; BCDE = 2 PI
    4082/    3A52 : 11 DB 0F            	LD	DE,0FDBH
    4083/    3A55 : CD 9A 36            	CALL	FPBCDE		; Move 2 PI to FPREG
    4084/    3A58 : C1                  	POP	BC		; Restore angle
    4085/    3A59 : D1                  	POP	DE
    4086/    3A5A : CD AF 35            	CALL	DVBCDE		; Divide angle by 2 PI
    4087/    3A5D : CD 8A 36            	CALL	STAKFP		; Put it on stack
    4088/    3A60 : CD 2C 37            	CALL	INT		; Get INT of result
    4089/    3A63 : C1                  	POP	BC		; Restore number
    4090/    3A64 : D1                  	POP	DE
    4091/    3A65 : CD 10 34            	CALL	SUBCDE		; Make it 0 <= value < 1
    4092/    3A68 : 21 94 3A            	LD	HL,QUARTR	; Point to 0.25
    4093/    3A6B : CD 0A 34            	CALL	SUBPHL		; Subtract value from 0.25
    4094/    3A6E : CD 59 36            	CALL	TSTSGN		; Test sign of value
    4095/    3A71 : 37                  	SCF			; Flag positive
    4096/    3A72 : F2 7C 3A            	JP	P,SIN1		; Positive - Ok
    4097/    3A75 : CD 01 34            	CALL	ROUND		; Add 0.5 to value
    4098/    3A78 : CD 59 36            	CALL	TSTSGN		; Test sign of value
    4099/    3A7B : B7                  	OR	A		; Flag negative
    4100/    3A7C : F5                  SIN1:	PUSH	AF		; Save sign
    4101/    3A7D : F4 82 36            	CALL	P,INVSGN	; Negate value if positive
    4102/    3A80 : 21 94 3A            	LD	HL,QUARTR	; Point to 0.25
    4103/    3A83 : CD 04 34            	CALL	ADDPHL		; Add 0.25 to value
    4104/    3A86 : F1                  	POP	AF		; Restore sign
    4105/    3A87 : D4 82 36            	CALL	NC,INVSGN	; Negative - Make positive
    4106/    3A8A : 21 98 3A            	LD	HL,SINTAB	; Coefficient table
    4107/    3A8D : C3 A1 39            	JP	SUMSER		; Evaluate sum of series
    4108/    3A90 :                     ;
    4109/    3A90 : DB 0F 49 81         HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
    4110/    3A94 :                     ;
    4111/    3A94 : 00 00 00 7F         QUARTR: DB	000H,000H,000H,07FH	; 0.25
    4112/    3A98 :                     ;
    4113/    3A98 : 05                  SINTAB: DB	5			; Table used by SIN
    4114/    3A99 : BA D7 1E 86         	DB	0BAH,0D7H,01EH,086H	; 39.711
    4115/    3A9D : 64 26 99 87         	DB	064H,026H,099H,087H	;-76.575
    4116/    3AA1 : 58 34 23 87         	DB	058H,034H,023H,087H	; 81.602
    4117/    3AA5 : E0 5D A5 86         	DB	0E0H,05DH,0A5H,086H	;-41.342
    4118/    3AA9 : DA 0F 49 83         	DB	0DAH,00FH,049H,083H	; 6.2832
    4119/    3AAD :                     ;
    4120/    3AAD : CD 8A 36            TAN:	CALL	STAKFP		; Put angle on stack
    4121/    3AB0 : CD 4C 3A            	CALL	SIN		; Get SIN of angle
    4122/    3AB3 : C1                  	POP	BC		; Restore angle
    4123/    3AB4 : E1                  	POP	HL
    4124/    3AB5 : CD 8A 36            	CALL	STAKFP		; Save SIN of angle
    4125/    3AB8 : EB                  	EX	DE,HL		; BCDE = Angle
    4126/    3AB9 : CD 9A 36            	CALL	FPBCDE		; Angle to FPREG
    4127/    3ABC : CD 46 3A            	CALL	COS		; Get COS of angle
    4128/    3ABF : C3 AD 35            	JP	DIV		; TAN = SIN / COS
    4129/    3AC2 :                     ;
    4130/    3AC2 : CD 59 36            ATN:	CALL	TSTSGN		; Test sign of value
    4131/    3AC5 : FC ED 38            	CALL	M,NEGAFT	; Negate result after if -ve
    4132/    3AC8 : FC 82 36            	CALL	M,INVSGN	; Negate value if -ve
    4133/    3ACB : 3A 2C C1            	LD	A,(FPEXP)	; Get exponent
    4134/    3ACE : FE 81               	CP	81H		; Number less than 1?
    4135/    3AD0 : DA DF 3A            	JP	C,ATN1		; Yes - Get arc tangnt
    4136/    3AD3 : 01 00 81            	LD	BC,8100H	; BCDE = 1
    4137/    3AD6 : 51                  	LD	D,C
    4138/    3AD7 : 59                  	LD	E,C
    4139/    3AD8 : CD AF 35            	CALL	DVBCDE		; Get reciprocal of number
    4140/    3ADB : 21 0A 34            	LD	HL,SUBPHL	; Sub angle from PI/2
    4141/    3ADE : E5                  	PUSH	HL		; Save for angle > 1
    4142/    3ADF : 21 E9 3A            ATN1:	LD	HL,ATNTAB	; Coefficient table
    4143/    3AE2 : CD A1 39            	CALL	SUMSER		; Evaluate sum of series
    4144/    3AE5 : 21 90 3A            	LD	HL,HALFPI	; PI/2 - angle in case > 1
    4145/    3AE8 : C9                  	RET			; Number > 1 - Sub from PI/2
    4146/    3AE9 :                     ;
    4147/    3AE9 : 09                  ATNTAB: DB	9			; Table used by ATN
    4148/    3AEA : 4A D7 3B 78         	DB	04AH,0D7H,03BH,078H	; 1/17
    4149/    3AEE : 02 6E 84 7B         	DB	002H,06EH,084H,07BH	;-1/15
    4150/    3AF2 : FE C1 2F 7C         	DB	0FEH,0C1H,02FH,07CH	; 1/13
    4151/    3AF6 : 74 31 9A 7D         	DB	074H,031H,09AH,07DH	;-1/11
    4152/    3AFA : 84 3D 5A 7D         	DB	084H,03DH,05AH,07DH	; 1/9
    4153/    3AFE : C8 7F 91 7E         	DB	0C8H,07FH,091H,07EH	;-1/7
    4154/    3B02 : E4 BB 4C 7E         	DB	0E4H,0BBH,04CH,07EH	; 1/5
    4155/    3B06 : 6C AA AA 7F         	DB	06CH,0AAH,0AAH,07FH	;-1/3
    4156/    3B0A : 00 00 00 81         	DB	000H,000H,000H,081H	; 1/1
    4157/    3B0E :                     ;
    4158/    3B0E :                     
    4159/    3B0E : C9                  ARET:	RET			; A RETurn instruction
    4160/    3B0F :                     ;
    4161/    3B0F : D7                  GETINP: RST	10H		;input a character
    4162/    3B10 : C9                  	RET
    4163/    3B11 :                     ;
    4164/    3B11 :                     CLS: 
    4165/    3B11 : 3E 0C               	LD	A,CS		; ASCII Clear screen
    4166/    3B13 :                     ;	JP	MONOUT		; Output character
    4167/    3B13 : CF                  	rst	08h
    4168/    3B14 : C9                  	ret
    4169/    3B15 :                     ;
    4170/    3B15 : CD D8 33            WIDTH:	CALL	GETINT		; Get integer 0-255
    4171/    3B18 : 7B                  	LD	A,E		; Width to A
    4172/    3B19 : 32 87 C0            	LD	(LWIDTH),A	; Set width
    4173/    3B1C : C9                  	RET
    4174/    3B1D :                     ;
    4175/    3B1D : CD 77 2C            LINES:	CALL	GETNUM		; Get a number
    4176/    3B20 : CD BC 28            	CALL	DEINT		; Get integer -32768 to 32767
    4177/    3B23 : ED 53 8B C0         	LD	(LINESC),DE	; Set lines counter
    4178/    3B27 : ED 53 8D C0         	LD	(LINESN),DE	; Set lines number
    4179/    3B2B : C9                  	RET
    4180/    3B2C :                     ;
    4181/    3B2C : CD BC 28            DEEK:	CALL	DEINT		; Get integer -32768 to 32767
    4182/    3B2F : D5                  	PUSH	DE		; Save number
    4183/    3B30 : E1                  	POP	HL		; Number to HL
    4184/    3B31 : 46                  	LD	B,(HL)		; Get LSB of contents
    4185/    3B32 : 23                  	INC	HL
    4186/    3B33 : 7E                  	LD	A,(HL)		; Get MSB of contents
    4187/    3B34 : C3 32 30            	JP	ABPASS		; Return integer AB
    4188/    3B37 :                     ;
    4189/    3B37 : CD 77 2C            DOKE:	CALL	GETNUM		; Get a number
    4190/    3B3A : CD BC 28            	CALL	DEINT		; Get integer -32768 to 32767
    4191/    3B3D : D5                  	PUSH	DE		; Save address
    4192/    3B3E : CD 82 26            	CALL	CHKSYN		; Make sure ',' follows
    4193/    3B41 : 2C                  	DB	','
    4194/    3B42 : CD 77 2C            	CALL	GETNUM		; Get a number
    4195/    3B45 : CD BC 28            	CALL	DEINT		; Get integer -32768 to 32767
    4196/    3B48 : E3                  	EX	(SP),HL		; Save value,get address
    4197/    3B49 : 73                  	LD	(HL),E		; Save LSB of value
    4198/    3B4A : 23                  	INC	HL
    4199/    3B4B : 72                  	LD	(HL),D		; Save MSB of value
    4200/    3B4C : E1                  	POP	HL		; Restore code string address
    4201/    3B4D : C9                  	RET
    4202/    3B4E :                     ;
    4203/    3B4E :                     
    4204/    3B4E :                     ; HEX$(nn) Convert 16 bit number to Hexadecimal string
    4205/    3B4E :                     ;
    4206/    3B4E : CD 7A 2C            HEX: 	CALL	TSTNUM		; Verify it's a number
    4207/    3B51 : CD BC 28            	CALL	DEINT		; Get integer -32768 to 32767
    4208/    3B54 : C5                  	PUSH	BC		; Save contents of BC
    4209/    3B55 : 21 2E C1            	LD	HL,PBUFF
    4210/    3B58 : 7A                  	LD	A,D		; Get high order into A
    4211/    3B59 : FE 00               	CP	0
    4212/    3B5B : 28 0C               	JR	Z,HEX2		; Skip output if both high digits are zero
    4213/    3B5D : CD 86 3B            	CALL	BYT2ASC		; Convert D to ASCII
    4214/    3B60 : 78                  	LD	A,B
    4215/    3B61 : FE 30               	CP	'0'
    4216/    3B63 : 28 02               	JR	Z,HEX1		; Don't store high digit if zero
    4217/    3B65 : 70                  	LD	(HL),B		; Store it to PBUFF
    4218/    3B66 : 23                  	INC	HL		; Next location
    4219/    3B67 : 71                  HEX1:	LD	(HL),C		; Store C to PBUFF+1
    4220/    3B68 : 23                  	INC	HL		; Next location
    4221/    3B69 : 7B                  HEX2:	LD	A,E		; Get lower byte
    4222/    3B6A : CD 86 3B            	CALL	BYT2ASC		; Convert E to ASCII
    4223/    3B6D : 7A                  	LD	A,D
    4224/    3B6E : FE 00               	CP	0
    4225/    3B70 : 20 05               	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
    4226/    3B72 : 78                  	LD	A,B
    4227/    3B73 : FE 30               	CP	'0'		; If high digit of lower byte is zero then don't print
    4228/    3B75 : 28 02               	JR	Z,HEX4
    4229/    3B77 : 70                  HEX3:	LD	(HL),B		; to PBUFF+2
    4230/    3B78 : 23                  	INC	HL		; Next location
    4231/    3B79 : 71                  HEX4:	LD	(HL),C		; to PBUFF+3
    4232/    3B7A : 23                  	INC	HL		; PBUFF+4 to zero
    4233/    3B7B : AF                  	XOR	A		; Terminating character
    4234/    3B7C : 77                  	LD	(HL),A		; Store zero to terminate
    4235/    3B7D : 23                  	INC	HL		; Make sure PBUFF is terminated
    4236/    3B7E : 77                  	LD	(HL),A		; Store the double zero there
    4237/    3B7F : C1                  	POP	BC		; Get BC back
    4238/    3B80 : 21 2E C1            	LD	HL,PBUFF	; Reset to start of PBUFF
    4239/    3B83 : C3 E0 30            	JP	STR1		; Convert the PBUFF to a string and return it
    4240/    3B86 :                     ;
    4241/    3B86 : 47                  BYT2ASC: LD	B,A		; Save original value
    4242/    3B87 : E6 0F               	AND	0FH		; Strip off upper nybble
    4243/    3B89 : FE 0A               	CP	0AH		; 0-9?
    4244/    3B8B : 38 02               	JR	C,ADD30		; If A-F, add 7 more
    4245/    3B8D : C6 07               	ADD	A,07H		; Bring value up to ASCII A-F
    4246/    3B8F : C6 30               ADD30:	ADD	A,30H		; And make ASCII
    4247/    3B91 : 4F                  	LD	C,A		; Save converted char to C
    4248/    3B92 : 78                  	LD	A,B		; Retrieve original value
    4249/    3B93 : 0F                  	RRCA			; and Rotate it right
    4250/    3B94 : 0F                  	RRCA
    4251/    3B95 : 0F                  	RRCA
    4252/    3B96 : 0F                  	RRCA
    4253/    3B97 : E6 0F               	AND	0FH		; Mask off upper nybble
    4254/    3B99 : FE 0A               	CP	0AH		; 0-9? < A hex?
    4255/    3B9B : 38 02               	JR	C,ADD301	; Skip Add 7
    4256/    3B9D : C6 07               	ADD	A,07H		; Bring it up to ASCII A-F
    4257/    3B9F : C6 30               ADD301:	ADD	A,30H		; And make it full ASCII
    4258/    3BA1 : 47                  	LD	B,A		; Store high order byte
    4259/    3BA2 : C9                  	RET	
    4260/    3BA3 :                     ;
    4261/    3BA3 :                     ; Convert "&Hnnnn" to FPREG
    4262/    3BA3 :                     ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
    4263/    3BA3 :                     ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
    4264/    3BA3 : EB                  HEXTFP:	EX	DE,HL		; Move code string pointer to DE
    4265/    3BA4 : 21 00 00            	LD	HL,0000H	; Zero out the value
    4266/    3BA7 : CD BC 3B            	CALL	GETHEX		; Check the number for valid hex
    4267/    3BAA : DA DC 3B            	JP	C,HXERR		; First value wasn't hex, HX error
    4268/    3BAD : 18 05               	JR	HEXLP1		; Convert first character
    4269/    3BAF : CD BC 3B            HEXLP:	CALL	GETHEX		; Get second and addtional characters
    4270/    3BB2 : 38 1F               	JR	C,HEXIT		; Exit if not a hex character
    4271/    3BB4 : 29                  HEXLP1:	ADD	HL,HL		; Rotate 4 bits to the left
    4272/    3BB5 : 29                  	ADD	HL,HL
    4273/    3BB6 : 29                  	ADD	HL,HL
    4274/    3BB7 : 29                  	ADD	HL,HL
    4275/    3BB8 : B5                  	OR	L		; Add in D0-D3 into L
    4276/    3BB9 : 6F                  	LD	L,A		; Save new value
    4277/    3BBA : 18 F3               	JR	HEXLP		; And continue until all hex characters are in
    4278/    3BBC :                     ;
    4279/    3BBC : 13                  GETHEX:	INC	DE		; Next location
    4280/    3BBD : 1A                  	LD	A,(DE)		; Load character at pointer
    4281/    3BBE : FE 20               	CP	' '
    4282/    3BC0 : CA BC 3B            	JP	Z,GETHEX	; Skip spaces
    4283/    3BC3 : D6 30               	SUB	30H		; Get absolute value
    4284/    3BC5 : D8                  	RET	C		; < "0", error
    4285/    3BC6 : FE 0A               	CP	0AH
    4286/    3BC8 : 38 05               	JR	C,NOSUB7	; Is already in the range 0-9
    4287/    3BCA : D6 07               	SUB	07H		; Reduce to A-F
    4288/    3BCC : FE 0A               	CP	0AH		; Value should be $0A-$0F at this point
    4289/    3BCE : D8                  	RET	C		; CY set if was :		; < = > ? @
    4290/    3BCF : FE 10               NOSUB7:	CP	10H		; > Greater than "F"?
    4291/    3BD1 : 3F                  	CCF
    4292/    3BD2 : C9                  	RET			; CY set if it wasn't valid hex
    4293/    3BD3 :                     	
    4294/    3BD3 : EB                  HEXIT:	EX	DE,HL		; Value into DE, Code string into HL
    4295/    3BD4 : 7A                  	LD	A,D		; Load DE into AC
    4296/    3BD5 : 4B                  	LD	C,E		; For prep to 
    4297/    3BD6 : E5                  	PUSH	HL
    4298/    3BD7 : CD 31 30            	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
    4299/    3BDA : E1                  	POP	HL
    4300/    3BDB : C9                  	RET
    4301/    3BDC :                     ;
    4302/    3BDC : 1E 26               HXERR:	LD	E,HX		; ?HEX Error
    4303/    3BDE : C3 C8 23            	JP	ERROR_
    4304/    3BE1 :                     ;
    4305/    3BE1 :                     ; BIN$(NN) Convert integer to a 1-16 char binary string
    4306/    3BE1 : CD 7A 2C            BIN:	CALL	TSTNUM		; Verify it's a number
    4307/    3BE4 : CD BC 28            	CALL	DEINT		; Get integer -32768 to 32767
    4308/    3BE7 : C5                  BIN2:	PUSH	BC		; Save contents of BC
    4309/    3BE8 : 21 2E C1            	LD	HL,PBUFF
    4310/    3BEB : 06 11               	LD	B,17		; One higher than max char count
    4311/    3BED :                     ZEROSUP:			; Suppress leading zeros
    4312/    3BED : 05                  	DEC	B		; Max 16 chars
    4313/    3BEE : 78                  	LD	A,B
    4314/    3BEF : FE 01               	CP	01H
    4315/    3BF1 : 28 08               	JR	Z,BITOUT	; Always output at least one character
    4316/    3BF3 : CB 13               	RL	E
    4317/    3BF5 : CB 12               	RL	D
    4318/    3BF7 : 30 F4               	JR	NC,ZEROSUP
    4319/    3BF9 : 18 04               	JR	BITOUT2
    4320/    3BFB :                     BITOUT:	
    4321/    3BFB : CB 13               	RL	E
    4322/    3BFD : CB 12               	RL	D		; Top bit now in carry
    4323/    3BFF :                     BITOUT2:
    4324/    3BFF : 3E 30               	LD	A,'0'		; Char for '0'
    4325/    3C01 : CE 00               	ADC	A,0		; If carry set then '0' --> '1'
    4326/    3C03 : 77                  	LD	(HL),A
    4327/    3C04 : 23                  	INC	HL
    4328/    3C05 : 05                  	DEC	B
    4329/    3C06 : 20 F3               	JR	NZ,BITOUT
    4330/    3C08 : AF                  	XOR	A		; Terminating character
    4331/    3C09 : 77                  	LD	(HL),A		; Store zero to terminate
    4332/    3C0A : 23                  	INC	HL		; Make sure PBUFF is terminated
    4333/    3C0B : 77                  	LD	(HL),A		; Store the double zero there
    4334/    3C0C : C1                  	POP	BC
    4335/    3C0D : 21 2E C1            	LD	HL,PBUFF
    4336/    3C10 : C3 E0 30            	JP	STR1
    4337/    3C13 :                     ;
    4338/    3C13 :                     ; Convert "&Bnnnn" to FPREG
    4339/    3C13 :                     ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
    4340/    3C13 : EB                  BINTFP: EX	DE,HL		; Move code string pointer to DE
    4341/    3C14 : 21 00 00            	LD	HL,0000H	; Zero out the value
    4342/    3C17 : CD 30 3C            	CALL	CHKBIN		; Check the number for valid bin
    4343/    3C1A : DA 3E 3C            	JP	C,BINERR	; First value wasn't bin, HX error
    4344/    3C1D : D6 30               BINIT:	SUB	'0'
    4345/    3C1F : 29                  	ADD	HL,HL		; Rotate HL left
    4346/    3C20 : B5                  	OR	L
    4347/    3C21 : 6F                  	LD	L,A
    4348/    3C22 : CD 30 3C            	CALL	CHKBIN		; Get second and addtional characters
    4349/    3C25 : 30 F6               	JR	NC,BINIT	; Process if a bin character
    4350/    3C27 : EB                  	EX	DE,HL		; Value into DE, Code string into HL
    4351/    3C28 : 7A                  	LD	A,D		; Load DE into AC
    4352/    3C29 : 4B                  	LD	C,E		; For prep to 
    4353/    3C2A : E5                  	PUSH	HL
    4354/    3C2B : CD 31 30            	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
    4355/    3C2E : E1                  	POP	HL
    4356/    3C2F : C9                  	RET
    4357/    3C30 :                     ;
    4358/    3C30 :                     ; Char is in A, NC if char is 0 or 1
    4359/    3C30 : 13                  CHKBIN: INC	DE
    4360/    3C31 : 1A                  	LD	A,(DE)
    4361/    3C32 : FE 20               	CP	' '
    4362/    3C34 : CA 30 3C            	JP	Z,CHKBIN	; Skip spaces
    4363/    3C37 : FE 30               	CP	'0'		; Set C if < '0'
    4364/    3C39 : D8                  	RET	C
    4365/    3C3A : FE 32               	CP	'2'
    4366/    3C3C : 3F                  	CCF			; Set C if > '1'
    4367/    3C3D : C9                  	RET
    4368/    3C3E :                     ;
    4369/    3C3E : 1E 28               BINERR: LD	E,BN		; ?BIN Error
    4370/    3C40 : C3 C8 23            	JP	ERROR_
    4371/    3C43 :                     ;
    4372/    3C43 :                     ;JJUMP1: JP	CSTART		; Go and initialise
    4373/    3C43 :                     ;
    4374/    3C43 :                     ;MONOUT: JP	TXA		; output a char
    4375/    3C43 :                     ;
    4376/    3C43 : C3 00 00            MONITR: JP	UNI_CST		; Restart unimon
    4377/    3C46 :                     ;
    4378/    3C46 : 3E 00               INITST: LD	A,0		; Clear break flag
    4379/    3C48 : 32 92 C0            	LD	(BRKFLG),A
    4380/    3C4B : C3 14 20            	JP	INIT
    4381/    3C4E :                     ;
    4382/    3C4E : F5                  TSTBIT: PUSH	AF		; Save bit mask
    4383/    3C4F : A0                  	AND	B		; Get common bits
    4384/    3C50 : C1                  	POP	BC		; Restore bit mask
    4385/    3C51 : B8                  	CP	B		; Same bit set?
    4386/    3C52 : 3E 00               	LD	A,0		; Return 0 in A
    4387/    3C54 : C9                  	RET
    4388/    3C55 :                     ;
    4389/    3C55 : CD 8D 26            OUTNCR: CALL	OUTC		; Output character in A
    4390/    3C58 : C3 B2 2A            	JP	PRCRLF		; Output CRLF
    4391/    3C5B :                     
    4392/    3C5B : FF FF FF FF FF FF   	db	($ & 0FF00H)+100H-$ dup(0FFH)
             3C61 : FF FF FF FF FF FF 
             3C67 : FF FF FF FF FF FF 
             3C6D : FF FF FF FF FF FF 
             3C73 : FF FF FF FF FF FF 
             3C79 : FF FF FF FF FF FF 
             3C7F : FF FF FF FF FF FF 
             3C85 : FF FF FF FF FF FF 
             3C8B : FF FF FF FF FF FF 
             3C91 : FF FF FF FF FF FF 
             3C97 : FF FF FF FF FF FF 
             3C9D : FF FF FF FF FF FF 
             3CA3 : FF FF FF FF FF FF 
             3CA9 : FF FF FF FF FF FF 
             3CAF : FF FF FF FF FF FF 
             3CB5 : FF FF FF FF FF FF 
             3CBB : FF FF FF FF FF FF 
             3CC1 : FF FF FF FF FF FF 
             3CC7 : FF FF FF FF FF FF 
             3CCD : FF FF FF FF FF FF 
             3CD3 : FF FF FF FF FF FF 
             3CD9 : FF FF FF FF FF FF 
             3CDF : FF FF FF FF FF FF 
             3CE5 : FF FF FF FF FF FF 
             3CEB : FF FF FF FF FF FF 
             3CF1 : FF FF FF FF FF FF 
             3CF7 : FF FF FF FF FF FF 
             3CFD : FF FF FF          
    4393/    3D00 :                     
    4394/    3D00 :                     	END
 AS V1.42 Beta [Bld 227] - Source File add_EMUBASIC.ASM - Page 2 - 10/3/2022 13:24:0


  Symbol Table (* = unused):
  --------------------------

 ABPASS :                      3032 C |  ABS :                         367E C |
*ACCSUM :                      289B C |  ACPASS :                      3031 C |
 ADD30 :                       3B8F C |  ADD301 :                      3B9F C |
 ADDEXP :                      3617 C |  ADDIG :                       37BD C |
 ADDPHL :                      3404 C |  ALLFOL :                      3300 C |
 ANTVLU :                      2B9B C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
*ARET :                        3B0E C |  ARLDSV :                      2F52 C |
 ARREND :                     0C11F - |  ARRLP :                       31CB C |
 ASC :                         32D1 C |  ASCTFP :                      3760 C |
 ASPCS :                       2AFD C |  ATN :                         3AC2 C |
 ATN1 :                        3ADF C |  ATNTAB :                      3AE9 C |
 ATOH :                        28D6 C |  BADINP :                      2B22 C |
 BAKSTK :                      235D C |  BAKTMP :                      32B1 C |
 BASTXT :                     0C0A3 - |  BCDEFP :                      36A5 C |
 BFREE :                       208D C |  BIN :                         3BE1 C |
*BIN2 :                        3BE7 C |  BINERR :                      3C3E C |
 BINIT :                       3C1D C |  BINTFP :                      3C13 C |
 BITOUT :                      3BFB C |  BITOUT2 :                     3BFF C |
 BKSP :                           8 - |  BN :                            28 - |
 BNORM :                       3464 C |  BNRMLP :                      3467 C |
 BRK :                         284D C |  BRKFLG :                     0C092 - |
 BRKLIN :                     0C113 - |  BRKMSG :                      2357 C |
 BRKRET :                      207E C |  BS :                            10 - |
 BSERR :                       2F85 C |  BUFFER :                     0C0A6 - |
 BYT2ASC :                     3B86 C |  BYTSFT :                      359C C |
*CASESENSITIVE :                  0 - |  CFEVAL :                      2EE8 C |
 CHARTY :                      2E96 C |  CHEKFN :                      30C9 C |
 CHKBIN :                      3C30 C |  CHKLTR :                      28A8 C |
 CHKSTK :                      2391 C |  CHKSUM :                     0C08F - |
 CHKSYN :                      2682 C |  CHKTYP :                      2C7C C |
 CHR :                         32E2 C |  CLEAR :                       28FB C |
 CLOTST :                      26B5 C |  CLREG :                       24E6 C |
 CLRPTR :                      24C1 C |  CLS :                         3B11 C |
 CMPFP :                       36EE C |  CMPLG1 :                      2DFC C |
 CMPLOG :                      2DFA C |  CMPNUM :                      36D4 C |
 CMPRES :                      2E3E C |  CMPSTR :                      2E26 C |
 CN :                            20 - |  CNVNUM :                      376C C |
 COMMAN :                     0C088 - |  COMPL :                       34C4 C |
*COMPMODE :                       0 - |  CONCAT :                      3246 C |
 CONEXP :                      379C C |  CONPOS :                      3461 C |
*CONSTPI :        3.141592653589793 - |  CONT :                        2880 C |
 CONTAD :                     0C119 - |  CONVAR :                      2D67 C |
 COPY :                        201C C |  COS :                         3A46 C |
 COUNT :                       2725 C |  CPDEHL :                      267C C |
 CPYLIT :                      25B8 C |  CR :                            0D - |
 CRARLP :                      2FA5 C |  CREARY :                      2F8A C |
 CRESTR :                      29FA C |  CRNCLP :                      2519 C |
 CRTMST :                      3102 C |  CRTST :                       310E C |
 CRTSTE :                      3124 C |  CRUNCH :                      2510 C |
 CS :                            0C - |  CSTART :                      200D C |
 CTLOFG :                     0C08A - |  CTRLC :                          3 - |
 CTRLG :                          7 - |  CTRLO :                         0F - |
 CTRLQ :                         11 - |  CTRLR :                         12 - |
 CTRLS :                         13 - |  CTRLU :                         15 - |
 CUROPR :                     0C10A - |  CURPOS :                     0C0F0 - |
 DATA :                        29A1 C | *DATE :                 "10/3/2022" - |
 DATFLG :                     0C0F3 - |  DATLIN :                     0C10E - |
 DATSNR :                      23AE C |  DCBCDE :                      3725 C |
 DDERR :                       23BD C |  DEEK :                        3B2C C |
 DEF :                         3046 C |  DEFSIZ :                      2FAD C |
 DEINT :                       28BC C |  DEL :                           7F - |
 DELCHR :                      25E8 C |  DEPINT :                      28B6 C |
 DETHL4 :                      36B4 C |  DETHLB :                      36B6 C |
 DIGTXT :                      3866 C |  DIM :                         2E68 C |
 DIMRET :                      2E5F C |  DINPOS :                      26B1 C |
 DIV :                         35AD C |  DIV1 :                       0C04F - |
 DIV10 :                       35A1 C |  DIV2 :                       0C053 - |
 DIV3 :                       0C057 - |  DIV4 :                       0C05A - |
 DIVLP :                       35D4 C |  DIVSUP :                     0C04E - |
 DOAGN :                       24FF C |  DOCOM :                       2ACE C |
 DODEL :                       25C8 C |  DOEBIT :                      38A6 C |
 DOFN :                        3073 C |  DOKE :                        3B37 C |
 DONULL :                      2ABC C |  DOSPC :                       2AF8 C |
 DOTAB :                       2AE5 C |  DPOINT :                      3798 C |
 DTSTR :                       3112 C |  DVBCDE :                      35AF C |
 DZ :                            14 - |  DZERR :                       23B7 C |
 ECHDEL :                      25DC C |  EDIGIT :                      37DF C |
 ENDBUF :                      25BF C |  ENDCON :                      37AB C |
 ENDDIM :                      300C C |  ENDINP :                      2AAD C |
 ENDNAM :                      2E8A C |  ENDPRG :                      285C C |
 ENFMEM :                      239A C |  ERRIN :                       23E8 C |
 ERRLIN :                     0C117 - |  ERRMSG :                      2345 C |
 ERRORS :                      22BB C |  ERROR_ :                      23C8 C |
 ESC :                           1B - |  EVAL :                        2C89 C |
 EVAL1 :                       2C8C C |  EVAL2 :                       2C95 C |
 EVAL3 :                       2C98 C |  EVLPAR :                      2D4E C |
 EVNOT :                       2E48 C |  EXCUTE :                      27EA C |
 EXP :                         3940 C |  EXPLP :                       378A C |
 EXPTAB :                      3980 C |  EXPTEN :                      38B8 C |
 EXTIG :                       2BF7 C | *FALSE :                          0 - |
 FANDT :                       2C21 C |  FC :                             8 - |
 FCERR :                       28D1 C |  FDTLP :                       2C08 C |
 FINDEL :                      2FE8 C |  FLGDIF :                      3664 C |
 FLGREL :                      366B C |  FNARG :                      0C125 - |
 FNCTAB :                      2105 C |  FNDARY :                      2F58 C |
 FNDELP :                      2FED C |  FNDEND :                      2494 C |
 FNDNUM :                      33D5 C |  FNDTOK :                      2704 C |
 FNDVAR :                      2ECF C |  FNDWRD :                      2543 C |
 FNOFST :                      2D78 C |  FNRGNM :                     0C123 - |
 FNTHR :                       2EDD C |  FNVAL :                       2D9F C |
 FOPRND :                      2CC1 C |  FOR :                         2751 C |
 FORFLG :                     0C110 - |  FORFND :                      2781 C |
 FORSLP :                      2765 C |  FPADD :                       3413 C |
 FPBCDE :                      369A C |  FPEXP :                      0C12C - |
 FPINT :                       3701 C |  FPMULT :                      354E C |
 FPREG :                      0C129 - |  FPROND :                      34AB C |
 FPSINT :                      28B0 C |  FPTHL :                       36B1 C |
 FRE :                         3010 C |  FRENUM :                      302C C |
 FRMEVL :                      2D6A C | *FULLPMMU :                       1 - |
 GARBGE :                      3193 C |  GARBLP :                      3196 C |
 GETCHR :                      280A C |  GETCMD :                      240C C |
 GETHEX :                      3BBC C |  GETINP :                      3B0F C |
 GETINT :                      33D8 C |  GETLEN :                      32C6 C |
 GETLIN :                      25F9 C |  GETLN :                       28D7 C |
 GETNUM :                      2C77 C |  GETNXT :                      255E C |
 GETSTR :                      3290 C |  GETVAR :                      2E6D C |
 GNXARY :                      31CA C |  GOFUNC :                      2DA7 C |
 GOSUB :                       294D C |  GOTO :                        295E C |
 GRBARY :                      31EA C |  GRBDON :                      316B C |
 GRBLP :                       31A4 C |  GSTRCU :                      3293 C |
 GSTRDE :                      3297 C |  GSTRHL :                      3296 C |
*GTFLNM :                      32D5 C |  GTFNAM :                      2E72 C |
 GTLNLP :                      28DA C |  GTSIXD :                      3830 C |
 GTVLUS :                      2B73 C |  HALF :                        38D7 C |
 HALFPI :                      3A90 C | *HAS64 :                          0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
 HEX :                         3B4E C |  HEX1 :                        3B67 C |
 HEX2 :                        3B69 C |  HEX3 :                        3B77 C |
 HEX4 :                        3B79 C |  HEXIT :                       3BD3 C |
 HEXLP :                       3BAF C |  HEXLP1 :                      3BB4 C |
 HEXTFP :                      3BA3 C |  HX :                            26 - |
 HXERR :                       3BDC C |  ID :                            16 - |
 IDTEST :                      30BB C |  IFGO :                        2A3E C |
 IFJMP :                       27F1 C |  IF_ :                         2A30 C |
 INCHL :                       36AF C |  INCLEN :                      26AD C |
 INDFND :                      2377 C |  INEWLN :                      245C C |
 INIT :                        2014 C |  INITAB :                      22E5 C |
 INITBE :                      2345 C |  INITST :                      3C46 C |
 INMSG :                       234C C |  INP :                         3395 C |
 INPBIN :                      2BC5 C |  INPBRK :                      2859 C |
 INPORT :                     0C084 - |  INPSUB :                     0C083 - |
 INPUT :                       2B33 C |  INRNG :                       3839 C |
*INSUPMODE :                      0 - |  INT :                         372C C |
 INTVAR :                      24D0 C |  INVSGN :                      3682 C |
 ITMSEP :                      2BB6 C |  JSTZER :                      38C2 C |
 KILFOR :                      2C67 C |  KILIN :                       25F3 C |
 LCRFLG :                     0C0F1 - |  LEFT :                        32F2 C |
 LEN :                         32C2 C |  LET :                         29B8 C |
 LETNUM :                      2A0B C |  LETSTR :                      29D3 C |
 LF :                            0A - |  LFRGNM :                      338B C |
 LINEAT :                     0C0A1 - |  LINEIN :                      37EB C |
 LINES :                       3B1D C |  LINESC :                     0C08B - |
 LINESN :                     0C08D - |  LINFND :                      2445 C |
 LIST :                        26C6 C |  LISTLP :                      26D2 C |
*LISTON :                         1 - |  LOADFP :                      36A8 C |
 LOG :                         350D C |  LOGTAB :                      3500 C |
 LOKFOR :                      2361 C |  LOOPST :                     0C10C - |
 LS :                            1C - |  LSTBIN :                     0C111 - |
 LSTLP2 :                      26F2 C |  LSTLP3 :                      26F5 C |
 LSTRAM :                     0C0F4 - |  LSTRND :                     0C07F - |
 LTSTND :                      2BD0 C |  LWIDTH :                     0C087 - |
*MACEXP :                         7 - |  MAKINT :                      33DB C |
 MAKNUM :                      3855 C |  MANLP :                       3774 C |
 MATCH :                       2590 C |  MEMMSG :                      20D3 C |
 MID :                         332C C |  MID1 :                        32F8 C |
 MIDNUM :                      3390 C |  MINCDE :                      3453 C |
 MINUS :                       2D56 C |  MKTMST :                      30FF C |
 MLDBLP :                      374D C |  MLDEBC :                      3745 C |
 MLOOP :                       2034 C |  MLSP10 :                      3642 C |
 MO :                            24 - | *MOMCPU :                        80 - |
*MOMCPUNAME :                 "Z80" - |  MONITR :                      3C43 C |
 MORDT :                       2BDC C |  MORINP :                      2602 C |
 MOVBUF :                      247B C |  MOVDIR :                      2598 C |
 MOVLP :                       2386 C |  MOVSTR :                      2383 C |
 MOVUP :                       2380 C |  MRPRNT :                      2A50 C |
*MSIZE :                       2031 C |  MUL8LP :                      3579 C |
 MULLN2 :                      3545 C |  MULT :                        354C C |
 MULT8 :                       3570 C |  MULTEN :                      37B6 C |
 MULVAL :                     0C13B - |  MVSTPT :                      2A02 C |
 NEDMOR :                      2B6F C |  NEGAFT :                      38ED C |
 NEMEM :                       2084 C | *NESTMAX :                      100 - |
 NEW :                         24C0 C |  NEXITM :                      2B08 C |
 NEXT :                        2C2C C |  NEXT1 :                       2C2F C |
 NF :                             0 - |  NFERR :                       23BA C |
*NMIFLG :                     0C091 - |  NOCHNG :                      2588 C |
 NOENED :                      38C5 C |  NOLIN :                       286F C |
 NOMADD :                      358A C |  NOMLAD :                      375B C |
 NOPMPT :                      2B4D C |  NORMAL :                      347E C |
 NOSPC :                       257F C |  NOSUB7 :                      3BCF C |
 NOSWAP :                      342D C |  NOTAMP :                      2D2B C |
 NOTSTR :                      2EA5 C |  NOXOR :                       33BB C |
 NSCFOR :                      2EB5 C |  NULFLG :                     0C089 - |
 NULL :                        2893 C |  NULLP :                       2AC3 C |
 NULLS :                      0C086 - |  NUMASC :                      37FE C |
 NXTARY :                      2F6C C |  NXTBYT :                      256E C |
 NXTCHR :                      25AF C |  NXTDAT :                     0C121 - |
 NXTDTA :                      29A0 C |  NXTITM :                      2B67 C |
 NXTOPR :                     0C115 - |  NXTSTL :                      29A7 C |
 NXTSTT :                      29AA C |  OD :                             6 - |
 OKMSG :                       2351 C |  OM :                            0C - |
 OMERR :                       23A9 C |  ON :                          2A12 C |
 ONGO :                        2A21 C |  ONGOLP :                      2A22 C |
 ONJMP :                       27F2 C |  OPNPAR :                      2C85 C |
 OPRND :                       2D00 C |  OS :                            1A - |
 OTKLN :                       25F0 C |  OTPORT :                     0C04C - |
 OUTC :                        268D C |  OUTEXP :                      38B6 C |
 OUTIT :                       266E C |  OUTNBS :                      2674 C |
 OUTNCR :                      3C55 C |  OUTSUB :                     0C04B - |
 OUTWRD :                      270E C |  OV :                            0A - |
 OVERR :                       23C3 C |  OVTST1 :                      3635 C |
 OVTST2 :                      363A C |  OVTST3 :                      363B C |
 PADD :                        37DA C | *PADDING :                        1 - |
 PAND :                        2DC1 C |  PASSA :                       3041 C |
 PBUFF :                      0C12E - |  PEEK :                        33E9 C |
 PEND :                        2854 C |  PHLTFP :                      3697 C |
 PLUCDE :                      34B8 C |  PNORM :                       3486 C |
 POINT :                      0C096 - |  POKE :                        33F0 C |
 POPAF :                       3185 C |  POPHL :                       32AF C |
 POPHRT :                      359A C |  POPNOK :                      23FE C |
 POR :                         2DC0 C |  POR1 :                        2DE3 C |
 POS :                         303E C |  POSINT :                      28B3 C |
 POUT :                        33A1 C |  POWER :                       38FB C |
 POWER1 :                      390B C |  POWER2 :                      3928 C |
 POWERS :                      38DB C |  PRCRLF :                      2AB2 C |
 PRINT :                       2A54 C |  PRITAB :                      22A6 C |
 PRNTHL :                      37F3 C |  PRNTLP :                      2A57 C |
 PRNTNB :                      2A9A C |  PRNTOK :                      23FF C |
 PRNTST :                      2A9E C |  PRNUMS :                      314F C |
 PROCES :                      261B C |  PROGND :                     0C11B - |
 PROGST :                     0C13E - |  PROMPT :                      2503 C |
 PRS :                         3150 C |  PRS1 :                        3153 C |
 PRSLP :                       315A C |  PSET :                       0C099 - |
 PSUB :                        340E C |  PTRLP :                       2488 C |
 PUTBUF :                      265A C |  PUTCTL :                      265F C |
 PUTFID :                      27C6 C |  QTSTLP :                      3115 C |
 QTSTR :                       310F C |  QUARTR :                      3A94 C |
 RAM12K :                         1 - |  RAMTOP :                     0C000 - |
 RD :                            12 - |  READ :                        2B62 C |
 READFG :                     0C112 - |  REDO :                        2B0F C |
*RELAXED :                        0 - |  REM :                         29A3 C |
 RESDIV :                      35E7 C |  RESEED :                      3A32 C |
 RESET :                      0C09C - |  RESTNL :                      282F C |
 RESTOR :                      281A C |  RESZER :                      3479 C |
 RETADR :                      2F1C C |  RETINT :                      3670 C |
 RETLIN :                      299B C |  RETNAD :                      2594 C |
 RETNUL :                      2F1F C |  RETNUM :                      2D62 C |
 RETREL :                      3662 C |  RETURN :                      297C C |
 RG :                             4 - |  RIGHT :                       3322 C |
 RIGHT1 :                      32F6 C |  RINPUT :                     0C093 - |
 RLTLP :                       2CA5 C |  RND :                         39D1 C |
 RND1 :                        3A0D C |  RND2 :                        3A29 C |
 RNDTAB :                      3A3A C |  RNGTST :                      38C8 C |
 ROMTOP :                      2000 - |  RONDB :                       349A C |
 RONDUP :                      3499 C |  ROUND :                       3401 C |
 RSCALE :                      37D4 C |  RSLNBK :                      2748 C |
 RSTSTR :                      3345 C |  RUN :                         2941 C |
 RUNCNT :                      27CA C |  RUNFST :                      24CC C |
 RUNLIN :                      295D C |  SAVEXP :                      347A C |
 SAVSTP :                      27BD C |  SAVSTR :                      30EA C |
 SBSCPT :                      2F2A C |  SCALE :                       34D8 C |
 SCALLP :                      34DA C |  SCALMI :                      379F C |
 SCALPL :                      37B5 C |  SCNEND :                      3221 C |
 SCPTLP :                      2F30 C |  SEARCH :                      255C C |
 SEED :                       0C05C - |  SETIO :                       33C5 C |
 SETLIN :                      271C C |  SETLIT :                      25A6 C |
 SETPTR :                      2483 C |  SETTOP :                      2043 C |
 SFTPRG :                      244D C |  SGN :                         3668 C |
 SGNEXP :                      2DB0 C |  SGNRES :                     0C12D - |
 SHRITE :                      34E7 C |  SHRLP :                       34EA C |
 SHRT1 :                       34EE C |  SIGNON :                      209C C |
 SIGNS :                       36BF C |  SIN :                         3A4C C |
 SIN1 :                        3A7C C |  SINTAB :                      3A98 C |
 SIXDIG :                      381B C |  SMPVAR :                      31B5 C |
 SMSER1 :                      39B0 C |  SN :                             2 - |
 SNERR :                       23B4 C |  SPCFST :                      380C C |
 SPCLP :                       2B01 C |  SQR :                         38F2 C |
 SRCHLN :                      24A0 C |  SRCHLP :                      24A3 C |
 SSTSA :                       327D C |  ST :                            1E - |
 STACK :                      0C0AB - |  STAKFP :                      368A C |
 STALL :                       2843 C |  STARTB :                      2006 C |
 STKTHS :                      2CE9 C |  STLOOK :                     0C1A2 - |
 STOP :                        2852 C |  STORED :                      291E C |
 STPOOL :                      31F8 C |  STR :                         30DA C |
 STR1 :                        30E0 C |  STRADD :                      31FB C |
 STRBOT :                     0C108 - |  STRENT :                      2BB9 C |
 STRSPC :                     0C09F - |  STTLIN :                      2AA5 C |
 SUBCDE :                      3410 C |  SUBPHL :                      340A C |
 SUMLP :                       39B9 C |  SUMSER :                      39A1 C |
 SUPTLZ :                      389A C |  SVNAM2 :                      2E89 C |
 SVSTAD :                      3108 C |  TAN :                         3AAD C |
 TESTOS :                      3187 C |  TESTR :                       3169 C |
*TIME :                   "13:24:0" - |  TM :                            18 - |
 TMERR :                       23C6 C |  TMPSTR :                     0C104 - |
 TMSTPL :                     0C0F8 - |  TMSTPT :                     0C0F6 - |
 TOPOOL :                      32EE C |  TOSTRA :                      3286 C |
*TRUE :                           1 - |  TRYAGN :                      3875 C |
 TSALP :                       3287 C | *TSTBIT :                      3C4E C |
 TSTBRK :                      2835 C |  TSTNUM :                      2C7A C |
 TSTOPL :                      3130 C |  TSTRED :                      2DE8 C |
 TSTREM :                      25A9 C |  TSTSGN :                      3659 C |
 TSTSTR :                      2C7B C |  TTYLIN :                      25F9 C |
 TYPE :                       0C0F2 - | *UARTCR :                     0FF01 - |
*UARTDR :                     0FF00 - |  UF :                            22 - |
 UFERR :                       23C0 C |  UL :                            0E - |
 ULERR :                       2977 C |  UNITY :                       34FC C |
 UNI_CST :                        0 - |  UPDATA :                      2830 C |
 USR :                        0C048 - |  VAL :                         335C C |
 VAL1 :                        337A C |  VAL2 :                        3384 C |
 VAL3 :                        3387 C |  VAREND :                     0C11D - |
*VERSION :                     142F - |  WAIT :                        33A7 C |
 WAITLP :                      33BC C |  WARMST :                      207B C |
 WIDTH :                       3B15 C |  WORDS :                       213D C |
 WORDTB :                      225C C |  WRKSPC :                     0C045 - |
 XXXXX :                       208A C |  ZDATA :                         83 - |
*ZDIV :                         0AF - |  ZEND :                          80 - |
 ZEQUAL :                       0B4 - |  ZERARY :                      2FCB C |
 ZERBYT :                      2350 - |  ZEROLP :                      2F0E C |
 ZEROSUP :                     3BED C |  ZFN :                          0A7 - |
 ZFOR :                          81 - |  ZGOSUB :                        8C - |
 ZGOTO :                         88 - |  ZGTR :                         0B3 - |
 ZLEFT :                        0CF - |  ZLTH :                         0B5 - |
 ZMINUS :                       0AD - |  ZNEW :                         0A4 - |
 ZNOT :                         0AA - |  ZONELP :                      2ADC C |
 ZOR :                          0B2 - |  ZPLUS :                        0AC - |
*ZPOINT :                       0C7 - |  ZPRINT :                        9E - |
 ZREM :                          8E - |  ZSGN :                         0B6 - |
 ZSPC :                         0A8 - |  ZSTEP :                        0AB - |
 ZTAB :                         0A5 - |  ZTHEN :                        0A9 - |
*ZTIMES :                       0AE - |  ZTO :                          0A6 - |

    658 symbols
     33 unused symbols

 AS V1.42 Beta [Bld 227] - Source File add_EMUBASIC.ASM - Page 3 - 10/3/2022 13:24:0


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.06 seconds assembly time

   4395 lines source file
      2 passes
      0 errors
      0 warnings
